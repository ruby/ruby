.\" spec -  -*- Indented-Text -*- created at: Tue May 25 15:18:26 JST 1993

* はじめに

Rubyは「UNIXで手軽にオブジェクト指向プログラミング」をしたいという望み
を実現するために生まれた．そのために必要だと思われた性質は:

    * 文法や機能が単純である．
    * オブジェクト指向プログラミングをサポートする機能を
      持つ言語として設計されている．
    * ターンアラウンドタイムが短い(インタプリタである)．
    * OS(UNIX)の機能が簡単に利用できる．
    * スクリプト言語として使える．
    * 処理系がfreeである．

などである．オブジェクト指向言語として一般的であるSmalltalkやC++などは
上の条件の一部を満たしてはいるが，特に手軽なプログラミングという点に欠
けており，以上の条件の全てを満たすものではなかった．一方スクリプト言語
であるPerlや Tclにオブジェクト指向機能を追加したシステムも存在するが，
これらは「手軽にプログラミング」という性質は満たしてはいても，逆にオブ
ジェクト指向機能に不備や不満があった．よって，これらの条件を満たすため
に設計されたRubyの特徴は:

    * インタプリタである．
    * 単純で例外の少ない文法．
    * 十分なオブジェクト指向機能を持つ．
    * できるだけ書きやすい(演算子形式など)．
    * ガーベージコレクタがある．
    * 例外処理機能がある．
    * 十分に強力なクラスが組み込まれている．
    * OSをアクセスする機能が提供される．
    * 拡張しやすい．

などである．RubyはshやPerlを知っている人にとっての常識になるたけ従った
ので，それらの言語からの自然な移行が可能であると思われる．プログラマが 
Rubyのオブジェクト指向機能について学べば，より強力なこともできるように
なるだろう．

更にC言語でクラスやメソッドを記述し，追加することでRubyを更に強力にす
ることができる．一部のプラットフォームではRubyは動的にオブジェクトファ
イルをリンクできるし，そうでなくてもRubyを再コンパイルして組み込みクラ
スを追加するのは容易である(Perlなどよりもはるかに容易である)．

* Lexical structure

現在のrubyの実装はキャラクタセットとしてASCIIを用いる．rubyは大文字と
小文字を区別する．識別子の途中でなければ任意のところに空白文字をおくこ
とが出来る．空白文字はスペース(space)，タブ(tab)，垂直タブ(vertical
tab)， CR(carriage return)，改頁(form feed)である．改行(newline)は明ら
かに式が継続する場合には空白文字として，それ以外では文の区切りとして解
釈される．

識別子は英文字("_"を含む)から始まり，英数字が続いたものである．rubyの
識別子の長さに制限はない．現在の実装は識別子としてマルチバイトコード 
(EUC,SJIS)も通すが勧められない．

グローバル変数名は"$"に続く識別子または記号1文字，インスタンス変数は
"@"に続く識別子，クラス定数は"%"に続く識別子である．メソッド名，ローカ
ル変数名とクラス名は単なる識別子を用いる．

** コメント

スクリプト言語の習慣にならい，文字列中や文字表現(?#)以外の`#'から行末
まではコメントと見なす．

** 予約語

予約語は以下の通りである

  alias		def		if		resque		when
  and		else		in		retry		while
  begin		elsif		include		return		yield
  break		end		module		self		__END__
  case		ensure		nil		super		__FILE__
  class		fail		or		then		__LINE__
  continue	for		redo		undef

予約語はクラス名，メソッド名，変数名などに用いることはできない．

** 区切り文字

文字列などのリテラルの内部以外の場所の空白文字(タブとスペース)および改
行(\n)が区切り記号となる．更に改行は

    a +
    b

のように行が式の途中で終り，次の行に続くことが明白な場合を除き，式の区
切りとしても認識される．

* プログラム

例:

  print "hello world!\n"

プログラムは式を並べたものである．式と式の間はセミコロン(`;')または改
行で区切られる(※)．

※ 式が次の行に継続することが明白な時には改行は式の区切りにならない．

* 式

Rubyではnilが偽，それ以外が真と評価される．CやPerl などとは異なり，0や 
""(空文字列)は偽とは評価されないので気をつけること．

** 文字列式

  "..."   # バックスラッシュの解釈と変数展開あり
  '...'   # バックスラッシュの解釈なし(\\と\'は解釈する)

バックスラッシュ記法

          \t      タブ(0x09)
          \n      改行文字(0x0a)
          \r      復帰文字(0x0d)
          \f      改ページ文字(0x0c)
          \b      バックスペース(0x08)
          \a      ベル(0x07)
          \e      エスケープ(0x1b)
  	  \#	  文字`#'そのもの
        \nnn      8進数表記(nは0-7)
        \xnn      16進数表記(nは0-9,a-f)
         \^c      コントロール文字(cはASCII文字)
        \C-c      コントロール文字(同上)
        \M-c      メタ文字(c|0x80)
   \それ以外      文字そのもの

変数展開

ダブルクォート(`"')で囲まれた文字列と正規表現の中では `#{変数名}'とい
う形式で変数の内容を展開することができる．変数が変数記号(`$',`@',`%')
 で始まる場合には`#変数名'という形式でも展開できる．文字`#'に続く文字
が `{',`$',`@',`%'でなければ，そのまま`#'として解釈される．

** コマンド出力

Rubyではshのようにコマンドの実行結果を文字列リテラルのように使うことが
できる．``で囲まれた文字列は，ダブルクォートと同様にバックスラッシュ記
法の解釈と変数展開が行なわれた後，コマンドとして実行され，その実行結果
が文字列として与えられる．コマンドは評価されるたびに実行される．

** 正規表現式

  /.../

           ^      行頭
           $      行末
           .      任意の1文字
          \w      英数字．[0-9A-Za-z_]と同じ
          \W      非英数字
          \s      空白文字．[ \t\n\r\f]と同じ
          \S      非空白文字
          \d      数字．[0-9] と同じ
          \D      非数字
          \b      語境界文字(文字クラス外)
          \B      非語境界文字
          \b      後退(0x08)(文字クラス内)
         [ ]      文字クラス指定
           *      直前の表現の0回以上の繰り返し
           +      直前の表現の1回以上の繰り返し
       {m,n}      m回からn回の繰り返し
           ?      0または1回
           |      選択
         ( )      正規表現をまとめる

その他に文字列と同じバックスラッシュ記法や変数展開も有効である．

** ワイルドカード式

  <...>

	   *	  任意の文字列(空文字列を含む)と一致
	   ?	  任意の1文字と一致
	 [ ]	  []内のいずれか1文字と一致
	{..}	  {}内の(コンマで区切られた)いずれかの文字列と一致

その他に文字列と同じバックスラッシュ記法や変数展開も有効である．

** 数値リテラル

         123      整数
        -123      整数(符合つき数)
       1_234      整数(10進数は`_'を含むことができる)
      123.45      浮動小数点数
      1.2e-3      浮動小数点数
      0xffff      16進整数
        0377      8進整数
          ?a      文字`a'のコード(97)
       ?\C-a      コントロールaのコード(1)
       ?\M-a      メタaのコード(225)
    ?\M-\C-a      メタ-コントロールaのコード(129)

   :シンボル       識別子/変数名/演算子と一対一対応する整数．applyなど
		  でメソッドを指定する時などに使う．

?表現では全てのバックスラッシュ記法が有効である．

** 変数と定数

Rubyの変数はスコープ(有効範囲)と寿命(有効期限)によって4種類に分類され，
その種類は変数名の最初の一文字で決定される．通常の変数の2文字目以降は
英数時または`_'であるが，システム変数の一部は「`$'+1文字の記号」という
変数がある．変数名の長さに関して特別な制限はない．

変数のスコープに関わらず，初期化されていない変数を参照した時の値はnil
である．いずれの種類の変数も宣言は必要ない．

*** グローバル変数

例:

  $foobar
  $/

`$'で始まる変数のスコープはグローバルであり，プログラムのどこからでも
参照できる．その寿命はプログラムの寿命と等しい．

*** インスタンス変数

例:

  @foobar

`@'で始まる変数はインスタンス変数であり，そのクラスまたはサブクラスの
メソッドから参照できる．スコープはメソッド内であり，その寿命はオブジェ
クトの寿命に等しい．

*** クラス名/モジュール名/ローカル変数

例:

  Array
  Math
  foobar

アルファベットまたは`_'で始まる変数は識別子とも呼ばれ，ローカル変数，
クラス名またはモジュール名である．

初期状態では識別子はクラス/モジュール名とみなされるが(該当するクラスが
存在しない場合の値はnil)，代入式の左辺に現れた識別子は，そのスコープ内
ではローカル変数として見なされ，同名のクラスやモジュールは隠される．こ
の意味で識別子への代入は宣言としての働きも持つ．

        Array       		# 配列クラス Array
        Array = 15		# 代入．以後Arrayはローカル変数
        print Array, "\n"	# `15'が出力される

この宣言としての代入の解釈はコンパイル時に行なわれるため，識別子への代
入式が実際に実行されてもされなくても，以降のスコープ内ではその識別子は
ローカル変数とみなされる．

        Array       		# 配列クラス Array
        if %FALSE
          Array = 15    	# このコードは実行されないが，
				# 以降Arrayはローカル変数とみなされる．
        end
        print Array, "\n"  	# `nil'が出力される

このルールは一見複雑だが，クラス/モジュール名とローカル変数名が重複し
ない限り，未初期化のローカル変数の値はnilであると考えても差し支えはな
い．Rubyの組み込みクラスは大文字のアルファベットで始まる名前がついて
おり，ユーザもクラス/モジュール名には大文字で始まる識別子を，ローカル
変数名には小文字または`_'で始まる識別子を使うことを強く推奨する．

ローカル変数のスコープも寿命もそのブロックの終りまで(トップレベルのロー
カル変数はプログラムの終了まで)である．

*** クラス定数

例:

  %foobar

`%'で始まる変数はクラス定数であり，そのクラスと全てのサブクラスのイン
スタンスから参照できる．この定数へはトップレベル，すなわちメソッドが定
義できるレベルでのみ代入可能である．この変数はクラス間で値が共有され，
一度代入すると値を変更することができない．

*** 疑似変数

通常の変数以外に疑似変数と呼ばれる特殊な変数が4つある．

      self   | 現在のメソッドの実行主体
       nil   | Nilクラスの唯一のインスタンス(偽を表す)
    __FILE__ | スクリプトのファイル名(文字列)
    __LINE__ | 現在の行番号(整数)

これらの疑似変数は代入によってその値を変更することはできない．これらの
変数への代入は例外を発生させる．

** 括弧によるグルーピング

例:

  (1+2)*3
  (foo();bar())

式は括弧によってグルーピングすることができる．

  `(' 式 `)'

括弧の中には単なる式だけではなく，式の並び(＝プログラム)を置くことが出
来る．

  `(' 式 `;' 式.. `)'

式の並びの値は最後に評価した式の値である．つまりの値は最後に評価した式
の値になる．

** 配列式

例:

  [1, 2, 3]

配列はArrayクラスのインスタンスである．配列を生成する式は以下の形式で
ある．

  `[' 式, .. `]'

それぞれの式を評価した結果を含む配列を返す．要素数が0の空配列を生成す
るためには空の配列式

  `[' `]'

を用いる．

** 連想配列式

例:

  {1=>2, 2=>4, 3=>6}

連想配列とは任意のオブジェクトをキー(添字)として持つ配列である．Ruby 
の連想配列はDict(辞書)クラスのインスタンスである．詳細はクラスDictの項
を参照されたい．連想配列を生成する連想配列式は以下の形式である．

  `{' 式 `=>' 式.. `}'

それぞれの式を評価した結果をキーと値とする連想配列オブジェクトを返す．
要素数が0の連想配列を生成するためには空の連想配列式

  `{' `}'

を用いる．要素が1つ以上ある場合，曖昧でなければ`{', `}'は省略できる．

** メソッド呼出式

例:

  foo.bar()
  foo.bar
  bar()

オブジェクトにメッセージを送る基本的な構文がメッセージ式であり，その基
本形式は以下の通りである．

  式1 `.' メソッド名 `(' 引数1.. [`,' `*' 引数n ]`)'

式1を評価して得られるオブジェクトの，識別子で指定されるメソッドを呼び
出す．一番最後の引数が`*'に続く(単一の)式である場合，その式を評価した
結果(配列でなければ変換される)を展開して，引数として追加する．

メッセージ式で，レシーバがselfの場合，レシーバを省略して通常のプログラ
ミング言語における関数のような形式でメソッドを呼び出すことができる．

メソッド呼び出しでは曖昧さがない時には括弧を省略できる．曖昧さがある時
とは第一引数が以下の文字または予約語で始まる場合である．

	(, [, {, <, /, %, +, -, if, while

例：
	      foo bar+baz	# メソッド呼び出しfoo(bar+baz)
	      foo (1+2)*5	# メソッド呼び出し(foo(1+2)) * 5
	      foo 1		# メソッド呼び出しfoo(1)
	      foo -1		# ローカル変数foo - 1

レシーバを指定したメソッド呼び出しではの場合引数が1つもない時にも括弧
を省略できる．

メソッド名としては任意の識別子を用いることができる．変数名とは識別子の
名前空間が違うので重複しても構わない．

クラス定義文の外で指定されたメソッドとクラスModuleのunexportメソッドで
指定されたメソッドは関数的メソッドと呼ばれ，関数形式でしか呼び出すこと
ができない(DEF参照)．

** SUPER

例:

  super
  super(1,2,3)

メッセージ式の特殊なケースとしてスーパークラスのメソッドの呼び出しがあ
る．この形式はメソッドを再定義した時にスーパークラスの定義を利用するた
めに使う．

  super

現在のメソッドに与えられた引数のままスーパクラスの同名のメソッドを呼び
出す．引数として与えられた変数の値を変更しても，渡されるのは元の引数の
値である．

  super`(' 引数.. `)'

引数とともにスーパークラスの同名のメソッドを呼び出す．一番最後の引数が
`*'に続く場合は通常のメソッド呼び出しと同様に展開して渡される．

** 代入

例:

  foo = bar
  foo[0] = bar
  foo.bar = baz

代入には変数に対する代入(真の代入)と，プログラムを簡単にするためのシン
タックスシュガーとしての代入がある．真の代入は以下の形式である．

  変数 `=' 式

これは式を評価し，変数の値として代入する．クラスやモジュールや疑似変数
には代入できない．クラスやモジュールの定義を変更するためにはclass式，
module式を用いる．代入式は演算子形式をとっているが，メソッドではないの
で再定義することはできない．

シンタックスシュガーとしての代入式は以下のものがある．

配列要素への代入

  式1`[' 式2.. `]' `=' 式n

式1を評価して得られるオブジェクトに，式2から式nまでを引数として，"[]="
というメソッドを呼び出す．

属性代入

  式1 `.' 識別子 `=' 式2

式1を評価して得られるオブジェクト(レシーバが省略された場合は`self')に
対して，"識別子="というメソッドを式 2を引数として呼び出す．

** 自己代入

例:

  foo += 12

式の値そのものに演算を加えるために自己代入形式がある．

  式1 op= 式2     # 式1は代入可能でなければならない．

この形式は内部的に「式1 = 式1 op 式2」と同様に評価される．ただし，式1
は1回しか評価されないので，式1に副作用がある場合は，「式1 = 式1 op 式2」
とは動作が異なる結果となる．opとして使える演算子は

        +, -, *, /, %, **, &, |, ^, <<, >>

の11種類である．演算子と`='の間にスペースを空けてはいけない．

** 多重代入

例:

  foo, bar, baz = 1, 2, 3
  foo, = list()
  foo, *rest = list2()

同時に複数の変数に代入を行なうことができる．その形式は以下の通りである．

    左辺 `,' [左辺 `,'..] [`*' 左辺]= 式 [, 式..]

右辺の式が一つしかない場合は，その値を配列として(必要ならばto_aメソッ
ドで配列に変換して)，要素をそれぞれ左辺に代入する．それ以外の場合には，
それぞれの式の値が左辺に代入される．左辺の数と右辺の要素の数が合わない
時には足りない変数には nilが代入され，余った要素は無視される．多重代入
の最後の要素の前に`*'がある場合，残りの全て引数が配列として代入される．

    foo, bar = [1, 2]		# foo = 1; bar = 2
    foo, bar = 1, 2		# foo = 1; bar = 2
    foo, bar = 1		# foo = 1; bar = nil

    foo, bar, baz = 1, 2	# foo = 1; bar = 2; baz = nil
    foo, bar = 1, 2, 3		# foo = 1; bar = 2
    foo,*bar = 1, 2, 3		# foo = 1; bar = [2, 3]

多重代入の値は(配列に変換された)右辺である．

** 演算子式

例:

  1+2*3/4

プログラミングの利便のために一部のメソッド呼び出しと制御構造は演算子形
式をとる．Rubyには以下にあげる演算子がある．上のものほど結合順位が強く，
同じ列の演算子の結合順位は同じである．

   強   [](配列参照), []=(配列代入)
	-(unary)  +(unary)  !  ~
        **
        *  /  % 
        +  -
        <<  >>
        &
        |  ^
        >  >=  <  <=
        <=> ==  !=  =~  !~
        &&
        ||
        .. ...
        ::
        =(代入) 自己代入(+=, -=,..)
	and
	or
   弱   if修飾子 while修飾子

ほとんどの演算式にはメソッド呼び出しとして解釈される(クラス毎に再定義
できる)が，一部再定義できない特殊なものがある．再定義できない特殊演算
子は

        =(代入), ...(範囲), !(否定), &&(論理積), and, |(論理和), or,
        if修飾子, while修飾子

の9つの演算子とこれらとの組み合わせになる !=, !~ および自己代入演算子
である．
  
上であげた特殊演算子以外の演算子形式は以下のようなメソッド呼び出しと見
なされる．

単項演算子(+, -, ~)

  式1. 演算子 ()

配列(連想配列を含む)の要素の参照(式1 `[' 式2.. `]')

  式1. `[]' (式2..)

配列要素の代入( 式1 `[' 式2.. `]' `=' 式n)

  式1. `[]=' (式2..)

それ以外の2項演算子(式 演算子 式)

  式1. 演算子 (式2)

これはあくまでもそういう形式のメソッド呼び出しとして解釈されるというだ
けで，rubyプログラムでこういう記述が許されるというわけではない．

** IF

  if 式1 [then]
    式..
  [elsif 式2 [then]
    式.. ].. 
  [else 
    式.. ]
  end

条件判断式．式1が真の場合に式1を評価する．それ以外の場合は式2を評価す
る．Rubyのif式はelse ifでもelifでもなくelsifでifの連続を行なうことに注
意すること．

ifの条件判断部の式では文字列と正規表現リテラルは式「$_=~ リテラル」の
省略であるとみなされる．

** IF修飾子

  式 if 式

条件修飾子(if)の式は先行する式に先だって評価される．動作も対応するif式
と同様である．if修飾子のついた式の値は条件が成立した場合には式の値，不
成立の場合にはnilである．

** CASE

  case 式0
  [when 式1 [, 式2].. [then]
    式.. ]..
  [else
    式.. ]
  end

条件分岐，CのswitchよりもPascalのcaseに似ている．breakで脱出することも
後ろの式に継続することもないので注意．

条件の一致は「式n =~ 式0]で行なわれる．つまり，

	case expr0
	when expr1, expr2
	  stmt1
	when expr3, expr4
	  stmt2
	else
	  stmt3
	end

は以下のif式とほぼ等価である．

        _tmp = expr0
        if expr1 =~ _tmp || expr2 =~ _tmp
          stmt1
        elsif expr3 =~ _tmp || expr4 =~ _tmp
           stmt2
        else
           stmt3
        end

** AND 式

  式1 `&&' 式2
  式1 `and' 式2

式1を評価し，その値が真(nil以外)であれば，式2を評価する．`and'は優先順
位が低い別名である．

andの両辺の式では文字列と正規表現リテラルは式「$_=~ リテラル」の省略で
あるとみなされる．

** OR 式

  式1 `||' 式2
  式1 'or 式2

式1を評価し，その値が偽であれば，式2を評価する．`or'は優先順位が低い別
名である．

orの両辺の式では文字列と正規表現リテラルは式「$_=~ リテラル」の省略で
あるとみなされる．

** 範囲指定式

  式1 `...' 式2

式1が真になるまでは偽を返し，その後は式2が真を返すまでは真を返す．式2 
が真になれば状態は偽に戻る．

演算子`...'の両辺は条件式であり，更に `...'の両辺の式では文字列と正規
表現リテラルは式「$_=~ リテラル」の省略，整数定数が「$.==定数」の省略
と解釈される．

** NOT 式

  `!' 式

式が真であれば偽，偽であれば真を返す．

`!'式では文字列と正規表現リテラルは式「$_=~ リテラル」の省略であるとみ
なされる．


  式1 `!=' 式2

「!(式1 == 式2)」の省略形

  式1 `!~' 式2

「!(式1 ~= 式2)」の省略形

** WHILE

  while 式
    式..
  end

式を評価した値が真の間，式を繰り返し実行する．while式の値はnilである．

whileの条件判断部の式では文字列と正規表現リテラルは式「$_=~ リテラル」
の省略であるとみなされる．

** WHILE 修飾子

  単純式 while 式

繰り返し修飾子(while)はまず先行する式を評価してから条件式を評価するの
で，最低一度は式を実行することになる．while修飾子のついた式の値はnilで
ある．

** イテレータ(繰り返し子)

イテレータとは制御構造(特にループ)の抽象化のために用いられるメソッドの
一種である．コードの断片(ブロックと呼ばれる)を指定してイテレータを呼び
出すと，イテレータは適当な値をセットしてブロックを評価する(おそらくは
複数回)．イテレータからのブロックの呼び出しはyield式を用いる(後述)．

イテレータの呼び出しは以下の構文で行なわれる．

イテレータとは制御構造(特にループ)の抽象化のために用いられるメソッドの
一種である．イテレータの呼び出しは以下の構文で行なわれる．

  式 `{' 変数.. `|' 式.. `}'

「式」をブロックとして設定し，「式」のメソッドをイテレータとして評価す
る．「式」のトップレベルのメソッドだけがイテレータとして呼び出され，
レシーバを表す式や，引数の式はイテレータとしては呼び出されない．「式」
が複数の式を含む時，各々がイテレータとして順に呼ばれる．

イテレータ内でyield式が実行されると，そこで指定された値がdo式で指定さ
れた変数に代入され，ブロックが実行される．ブロックの実行が終了するとそ
の値は yield式の値として返される．あるメソッドがイテレータとして呼び出
されたかどうかはメソッドiterator_p()の戻り値で知ることができる．中には 
Enumerableモジュールのgrepメソッドのようにイテレータとして呼ばれた時と
普通のメソッドとして呼ばれた時とで動作が異なるメソッドもある．

** FOR

オブジェクトの各要素に対して操作を行なうための形式も提供されている．形
式は以下の通り．

  for 変数.. in 式
    式
  end

式の各要素に対し式を実行する．これは以下の式と等価である．

  (式).each `{' 変数.. `|' 式 `}'

よって式の値のオブジェクトがメソッドeachを持たない場合，forを実行する
と例外が発生する．

** YIELD

  yield `(' [式 [`,' 式..]])
  yield

イテレータの中でブロックの呼び出しを行なう．yieldを実行したメソッドが
イテレータとして呼び出されていない時には例外が発生する．yield の値はブ
ロックの戻り値である．

yieldの引数の括弧は曖昧でない限り省略できる．

** FAIL

  fail `(' [メッセージ] `)'

例外を発生させる．メッセージが与えられた場合には発生したソースファイル
名，行番号をシステム変数`$@'に，メッセージを`$!'にセットする．

failの引数の括弧は曖昧でない限り省略できる．

** BEGIN

複数の式をまとめるためにbegin式がある．begin式の形式は以下の通りである．

  begin
    式..
  [resque
    式.. ]
  [ensure
    式..]
  end

begin式の値は一番最後に評価された式の値である．begin式の処理中に発生し
た時に例外はresque節で捕獲することが出来る．この場合の値はresque部で最
後に評価した式の値である．更にensure節が存在する時はbegin式を終了する
前に必ず(正常終了時だけでなく，例外, return, break, continue, redoなど
による脱出でも)ensure節の式を評価する．

** RETURN

  return [式[`,' 式..]]

式の値を戻り値としてメソッドの実行を終了する．式が2つ以上与えられた時
には，それらを要素とする配列をメソッドの戻り値とする．式が一つもない場
合には nil が戻り値となる．

** BREAK

  break

break はループを脱出する．Cと違い，breakはもっとも内側のループを脱出す
る作用だけを持ち，case を抜ける作用は持たない．

** CONTINUE
  continue

continueはもっとも内側のループの次の繰り返しを始める．

** REDO

  redo

redoはループ条件のチェックを行なわず，現在の繰り返しをやり直す．

** RETRY

  retry

begin式のresque節で使い，begin式を始めから実行する．例外処理を行なって
から再試行するのに使う．resque節以外でretryが用いられた場合例外が発生
する．

** クラス定義

クラスを定義する構式は以下の通りである．

   class クラス名 [`:' スーパークラス名 ]
       定義実体
   end

クラス名は任意の識別子である(大文字で始めることを推奨する)．クラス定義
のネストはできないので他の定義式内ではクラスを定義できない．

** モジュール定義

モジュールを定義する構式は以下の通りである．

   module クラス名
       定義実体
   end

モジュール名は大文字で始まる識別子である．クラス同様，モジュール定義も
ネストできない．

** メソッド定義

通常(特異メソッドでない)メソッド定義の形式は以下の通りである．通常メソッ
ド定義はネストできないので，メソッド定義式中ではメソッド定義式を再び呼
び出せない．

    def メソッド名 [`(' 引数 [`,' 引数..][`,' `*'引数 ] `)']
        定義実体
    end

メソッド名は識別子または文字列である．演算子の再定義をする時には文字列
で指定する．仮引数並びの最後に`*'がある場合，仮引数より多く与えられた
実引数は，最後の引数に配列として与えられる(足りない時にはエラー)．

メソッドには関数的メソッドと通常メソッドがある．関数的メソッドは関数形
式でしか呼び出すことができず，よって該当するクラスとそのサブクラスのメ
ソッドからしか呼び出すことができない．

新規にメソッドを定義する場合，クラス定義式の外にあるdef式は関数的メソッ
ドを定義し，クラス定義式の中にあるdef式は通常のメソッドを定義する．スー
パークラスのメソッドを再定義する場合には定義されるメソッドの可視性はスー
パークラスのメソッドのものを受け継ぐ．

メソッドの可視性を変更する場合にはModuleクラスのexport/unexportメソッ
ドを用いる．

** 特異メソッド定義

メソッド定義にはもう一つ特異メソッドの定義がある．特異メソッドとはある
特定のオブジェクトに固有のメソッドである．形式は以下の通りである．

   def 式 `.' メソッド名 [`(' 引数 [`,' 引数..][`,' `*'引数 ] `)']
       定義実体
   end

この形式は式の値であるオブジェクトに特異メソッドを定義する．式の値は 
(ビルトインクラスでない)通常オブジェクトか，クラスまたはモジュールであ
る必要がある．通常メソッド定義とは異なり，特異メソッドはメソッド本体内
でもネストして定義することができる．

特異メソッドは通常は継承しえないが，例外としてクラスの特異メソッドはそ
のサブクラスにも継承される．言い替えればクラスの特異メソッドは他のオブ
ジェクト指向システムにおけるクラスメソッドの働きをする．

** INCLUDE

モジュールをインクルードすることによって，クラスまたはモジュールに機能
を追加できる．モジュールをインクルードした場合，そのモジュール(および
そのモジュールが更にインクルードしているモジュール)の全てのメソッドを
受け継ぐ．別のいい方をすればインクルードは限定された多重継承といえる．

他のモジュールをインクルードする構式は以下の通りである．

   include モジュール名 [`,' モジュール名..]

現在の定義中のクラスまたはモジュール(トップレベルではObjectクラス)に指
定したモジュールをインクルードする．

** ALIAS

以下の形式でメソッドに別名をつけることができる．

   alias メソッド名1 メソッド名2

別名を付けられたメソッドは，その時点でのメソッド定義を引き継ぎ，元のメ
ソッドが再定義されても，古いメソッドが呼び出されたのと全く同じ働きをす
る．

** UNDEF

メソッドの定義を取り消すためにはundefを用いる．

   undef メソッド名

指定したメソッドの定義を取り消す．

defによる別名定義とundefによる定義取り消しを使うとクラスのインタフェー
スをスーパークラスと独立に変更することができる．ただし，メソッドがself 
にメッセージを送っている場合もあるので，よく注意しないと既存のメソッド
が動作しなくなる可能性がある．

* 組み込み関数

Rubyには厳密な意味では関数はないがKernelクラスの関数メソッドは(全ての
通常クラスから関数形式で呼び出せるので)，関数的に用いられる．関数的に
用いられるメソッドを以下にあげる．これらのメソッドを再定義する際には互
換性を考えて行なうべきである．

   _exit(status)

	プログラムの実行を終了する．整数statusを終了ステータスとする．
	exit()とは違って，例外処理などは一切行なわない．fork()の後，子
	プロセスを終了させる時などに用いる．

   do()

	ブロックを1度だけ実行するイテレータ．ブロックをまとめるためだ
	けに存在する．使い方の例:

	  do { foobar() } while (baz())

   eof()

	コマンドラインからの入力がEOFに到達している場合，真を返す．

   eval(expr)

        exprとして与えられた文字列をrubyプログラムとして解釈，実行する．

   exec(command)

        現在実行しているプロセスを終了して，command文字列で指定される
        別プロセスを起動する．

   exit([status])

        プログラムの実行を終了する．statusとして整数が与えられた場合，
        その値をRubyコマンドの終了ステータスとする．デフォルトは0．

   fork()

        forkシステムコールを実行し，子プロセスを生成する．詳細は
        fork(2)を参照のこと．親プロセス側では子プロセスのプロセスidを
        返し，子プロセス側ではnilを返す．何らかの原因で子プロセスの生
        成に失敗した時には例外が発生する．

   format(format, ...)

        フォーマットとして与えられた文字列をC言語のsprintfと同じように
        解釈し，引数を展開した文字列を返す．メソッドsprintf()の別名．

	Rubyにおけるformat指定子の拡張についてはsprintf()の項を参照の
	こと．

   getc()

        標準入力から一文字取り出す．戻り値は読み込んだ文字の文字コード
        (ASCII)を表すFixnumである．

   getenv(name)

        nameに該当する環境変数を取り出す．$ENV[name]と同義．

   gets()

        引数として与えられたファイル(なければ標準入力)で構成される仮想
        的なファイル(システム変数`$<'でアクセスできる)から一行読み込ん
        で，読み込みに成功した時にはその文字列を返す．ファイルの終りに
        到達した時にはnilを返す．行の区切りはシステム変数`$/'によって
        変更できる．読み込んだ文字列はシステム変数`$_'にもセットされる．

   gsub(pattern, replace)

        システム変数`$_'の指す文字列に対して置換を行なう．文字列内で
        patternにマッチする部分を全てreplaceに置き換える．Stringクラス
        のgsubメソッドの解説を参照のこと．gsubメソッドは`$_'の値を更新
        する．

   iterator_p()

        メソッドがイテレータとして呼び出された時に真，そうでない時に偽
        を返す述語．

   kill(signal, pid..)

        pidで指定されたプロセスにシグナルを送る．シグナルはシグナル番
        号か名前で指定する．負の値を持つシグナル(あるいはシグナル名の
        前に`-')を与えるとプロセスではなくプロセスグループにシグナルを
        送る．

   load(file)

        fileをロードする．fileをロードするパスはシステム変数$LOAD_PATH
        で決定される．

   open(file[, mode])

        fileをオープンして，Fileオブジェクトを返す．ファイル名はオープ
        ンするファイルを示す．ファイル名が`|'で始まる時には続く文字列
        をコマンドとして起動し，パイプラインを生成する．

        コマンド名が"-"である時，open()はRubyの子プロセスを生成し，そ
        の子プロセスとのパイプを返す．

        modeはファイルのアクセスモードを指定する．これは以下のうちのい
        ずれかの文字列である．

            r   読み込み専用．openするファイルはあらかじめ存在している
                必要がある．

            r+  読み書き両用．openするファイルはあらかじめ存在している
                必要がある．

            w   書き込み専用．ファイルが存在していた場合，長さを0にす
                る．存在していなければ新たにファイルを作成する．

            w+  読み書き両用．読み込みが行なえること以外は"w"と同じ働き
                をする．

            a   追加書き込み専用．ファイルはあらかじめ存在している必要
                がある．書き込みはファイルの最後に追加される．

            a+  読み書き両用．ファイルが存在していなければ新たに作成す
                る．アクセス位置はファイルの最後に初期化される．

        モードが省略された場合のデフォルトは"r"である．

   print(arg1, ..., argn)

        引数を順に出力する．引数が与えられない時にはレシーバを出力する．
        文字列以外のオブジェクトが引数として与えられた場合には，当該オ
	ブジェクトのto_sメソッドによって文字列に変換してから出力される．
        システム変数`$;'(出力フィールドセパレータ)にnilでない値がセッ
        トされている時には，各引数の間にその文字列を出力する．システム
        変数`$\'(出力フィールドセパレータ)にnil でない値がセットされて
        いる時には，最後にそれを出力する．

   printf([port, ]format, arg1, ..., argn)

        C言語のprintf()と同じformatに従い引数を文字列に変換し，出力す
        る．第1引数がIOのサブクラスのインスタンスであった場合はそのオ
        ブジェクトに対して出力を行なう．デフォルトは$stdoutに出力する．

	Rubyにおけるformat指定子の拡張についてはsprintf()の項を参照の
	こと．

   rand(max)

        0からmaxを越えない範囲の整数の乱数を発生する．戻り値はFixnum．

   require(file)

	fileをロードする．loadとの動作の違いはrequireはロードしたファ
	イルのフルパスを変数`$"'に覚えていて，既にロードしたファイルは
	再ロードしない点である．実際にロードした時には%TRUE，既にロー
	ドされている時には%FALSEを返す．

   select(reads[, writes[, execpts[, timeout]]])

        select(2)を実行する．reads/writes/execptsにはIO(またはそのサブ
        クラス)のインスタンスの配列を与える．timeoutはFixnum / Float
        / Timeのいずれかで指定する．戻り値はtimeoutが成立した場合には
        nil，そうでないときは3要素の配列を返し，その各要素が入力/出力/
        例外待ちのオブジェクトを要素として持つ．

   setenv(name, value)

        nameで指定される環境変数をvalueにセットする．$ENV[name]=value
        と同じ働きをする．

   sleep([sec])

        sec秒だけプログラムの実行を停止する．secが省略された場合，プロ
        セスにSIGALRMが送られない限り，永久にスリープする．実際にスリー
        プした秒数を返す．

   sprintf(format, ...)

        format文字列をC言語のsprintfと同じように解釈し，引数を展開した
        文字列を返す．メソッドformat()の別名．


	format指定子はC言語のsprintf()が受け付けるもの(ただし，Rubyに
	は unsignedがないので，%uは除く)に加えて, %b, %B, %O, %Xを使う
	ことができる．%bは数値の2進表示，%B, %O, %Xはそれぞれ2進，8進，
	16進数の表示を行なうが，負の数の処理の際に2の補数表現ではなく，
 	その絶対値表記の先頭に`-'をつけたものを表示する．

   srand([初期値])

        乱数の初期値を設定し，古い初期値を返す．初期値が省略された時に
        はtime(3)の返す値をデフォルトとする．

   sub(pattern, replace)

        システム変数`$_'の指す文字列に対して置換を行なう．文字列内で最
        初にpatternにマッチする部分をreplaceに置き換える．subメソッド
        は`$_'の値を更新する．その他の詳細に関してはStringクラスのsub
        メソッドの解説を参照のこと．

   syscall(num, arg..)

	numで指定された番号のシステムコールを実行する．第2引数以降をシ
	ステムコールの引数として渡す．引数は文字列または整数でなければ
	ならない．

   system(command)

        コマンドを実行し，その終了ステータスを返す．

   trap(command, signal..)

        signalの割り込みがかかった時にcommandを実行する．signalはシグ
        ナル名かシグナルの番号．commandとして"SIG_IGN"または"IGNORE"を
        指定した時にはそのシグナルを無視する(可能ならば)．"SIG_DFL"ま
        たは"DEFAULT"を指定した時はデフォルトの動作を行なう．

   wait()

        子プロセスが終了するのを待ち，終了した子プロセスのpidを返す．
        子プロセスが一つもなければnilを返す．

   waitpid(pid, flags)

        特定の子プロセスの終了を待ち，そのプロセスが終了した時に真を返
        す．子プロセスが存在しないか，ノンブロッキングモードで子プロセ
        スがまだ終了していない時にはnilを返す．waitpid(2)かwait4(2)の
        実装されていないマシンではflagsはいつもnilまたは0でなければな
        らない．

* 組み込み変数と定数

   $!           エラーメッセージ．failで設定する．

   $@           エラーが発生した時点のファイル名と行番号が

                    "ファイル:行番号[:メソッド名(あれば)]"

                の形式で格納される．

   $&           最後に成功したパターンマッチ

   $`		最後のパターンマッチでマッチした文字列の前の文字列

   $'		最後のパターンマッチでマッチした文字列の後に続く文字列

   $+		最後の検索パターンでマッチした最後の括弧

   $1..$9       最後に成功したパターンマッチでn番目の括弧にマッチした
                値が格納される．該当する括弧がなければnilが入っている．

   $~           最後のマッチに関する情報．これをセットすると$&や$1..$9
                の値が変化する．

   $=           この変数の値がnilでない時，パターンマッチや文字列の比
                較でアルファベットの大文字小文字を区別しない．デフォル
                トはnil(区別する)．

   $/           入力レコードセパレータ．ファイルや文字列に対してeachを
                行なう時の分割文字を指定する．$/に空文字列("")を指定す
                ると段落単位で入力を行ない，nilを指定すると全体を一度
                に読み込む．$/には正規表現は使えない．デフォルトは
                "\n"．

   $\           出力レコードセパレータ．この変数に文字列を指定すると
                write()やprint()の度に最後にこの文字列を付加して出力す
                る．デフォルトはnil(なにも追加しない)．

   $,		Array:join()のデフォルトの区切り文字列．print()の各引
		数の間に出力される文字列．

   $;		String:split()のデフォルトの区切り文字．

   $.           最後に読んだ入力ファイルの行番号．

   $<		引数(なければ標準入力)で構成される仮想ファイル．つまり
		gets()は$<.gets()と同じ意味である．$<.fileで現在読み込
		み中のファイルオブジェクトが，$<.filenameでそのファイ
		ル名が得られる．(覚え方: `<'はシェルの入力元指定)

   $>		printやprintfのデフォルトの出力先．初期値は$stdout．-i 
		オプションを指定した場合には読み込み元と同じ名前のファ
		イル．(覚え方: `>'はシェルの出力先指定)

   $_           最後にgets()などで読み込んだ文字列．

   $0           rubyスクリプトの名前．この変数に代入するとps(1)の出力
		が変化する．

   $*           rubyスクリプトに与えられた引数．ruby自身に対する引数は
                取り除かれている．

   $$           現在実行中のrubyプロセスのpid．

   $?           最後に実行した子プロセスのstatus．

   $:		ファイルをロードする時に検索するディレクトリへのパスを
                含む配列．起動時にはデフォルト値(コンパイル時に指定す
                る)に加えて，環境変数RUBYLIBの値とruby起動時の-Iオプショ
                ンで指定された値が追加される．(覚え方: コロンは環境変
                数PATHの区切り文字である)

   $"		既にロードされたファイル名を含む配列．require()で同じ
		ファイルを2回ロードしないために用いられる．(覚え方:
		prevent files to be doubly quoted(loaded))

   $ARGF	$<の別名．

   $ARGV        $*の別名．

   $DEBUG	`-d'フラグの状態(真偽値)．

   $ENV		環境変数にアクセスする連想配列．文字列をキーとして与え
		ると対応する環境変数の値が得られる．環境変数が存在しな
		い場合はnilが返る．

   $FILENAME	仮想ファイル`$<'で現在読み込み中の(メソッドgets()が今
	     	読んでいる)ファイル名．$<.filenameと同じ．

   $LOAD_PATH   $:の別名．

   $stdin       標準入力
   $stdout      標準出力
   $stderr      標準エラー出力

   $VERBOSE	`-v'フラグの状態(真偽値)

   $VERSION     rubyのバージョンを示す文字列


   %TRUE        t
   %FALSE       nil

        それぞれ真偽値を表す．条件判断はnilを偽，それ以外の全ての値を
        真として判断するため，%TRUEの値は代表的な真の値という以上の意
        味を持たない．よって，あるメソッドの返値が真であるということと，
        それが%TRUEを返すということは厳密には同じではない(述語的に用い
        られるメソッドは大抵真の値として%TRUEを返すようにはなっている
        が)．つまり

	  if some.method() then ... else ... end

	と

	  if some.method() == %TRUE then ... else ... end

        は完全には同義ではない．%FALSEに関しては，このような問題は生じ
        ない．

* 組み込みクラスとモジュール

** Array(クラス)

数字を添字とした配列のクラスである．生成は一般的には配列式``[..]''で
行なわれる．

SuperClass: Object

Included Modules: Enumerable

Methods:

   self[nth]
   self[start..end]
   self[start, length]

        配列の要素にアクセスする．最初の形式では配列のnth番目の要素を
        返し，2番目の形式ではstart番目の要素からend番目の要素を含む部
        分配列を返す．3番目の形式ではstart番目からlength個の要素を含む
        部分配列を返す．

   self[nth] = val
   self[start..end] = val
   self[start, length] = val

        配列の要素を変更する．最初の形式では配列のnth番目の要素をvalに
        変更する．2番目の形式はstart番目の要素からend番目の要素までを
        valに変更する．3番目の形式ではstart番目からlength個の要素をval
        に変更する．

        2番目，3番目の形式ではvalは配列でなければならない．

        例:

          ary = [1, 2, 3, 4, 5]
          ary[0..2] = [0, 0] # 配列の内容は [0, 0, 4, 5]
          ary[1, 0] = [7]    # 配列の内容は [0, 7, 0, 6, 5]

   self + other

        配列の連結．selfとotherの両方の配列の内容を繋げた新しい配列を
        返す．

   self * times

        配列の繰り返し．

   self - other

        集合の差演算．selfからotherの要素を取り除いた内容の新しい配列
        を返す．重複する要素は1度だけ現れる．

   self * other

	集合の積演算．両方の配列に含まれる要素からなる新しい配列を返す．
	重複する要素は1度だけ現れる．

   self | other

	集合の和演算．両方の配列にいずれかに含まれる要素を全て含む新し
	い配列を返す．重複する要素は1度だけ現れる．

   self << obj

        objを配列の末尾に追加する．selfを返すのでC++的に連鎖できる．

   assoc(key)

        連想リスト(CONSペアを要素とする配列)を検索し，第1要素がkeyと等
        しい("=="で比較する)配列を返す．

   clear

	配列の大きさを0にする．

   delete(val)

	valと一致する要素を削除する．

   delete_if

        要素を削除するイテレータ．ブロックを評価した値が真の時，対応す
        る要素を配列から削除する．

   each

        配列の各要素を順に与えるイテレータ．

   fill(val)
   fill(val, start[, length])
   fill(val, start..end)

	配列(の指定された部分)の要素の値をvalに設定する．2番めの形式で
	lengthが省略された時は配列の終りまでの長さをとる．指定された部
	分配列が元の配列の範囲を越える時は自動的に拡張される．

   index(val)

	valと等しい最初の要素のインデックスを返す．該当する要素が存在
	しない場合はnilを返す．

   indexes(ary)
   indexes(index-1, ..., index-n)

	1番目の形式では整数の配列を引数として受けて，その要素をインデッ
	クスとする要素を含む配列を返す．2番目の形式では各引数の値をイ
	ンデックスとする要素を含む配列を返す．

   join([sep])

        配列の要素を連結した文字列を返す．各要素は文字列に変換され，間
        にsepを挟んで連結される．sepが省略された時にはシステム変数`$,'
        の値が用いられる．

   length
   size

        配列の長さ(要素数)を返す．

   push(obj)

        objを配列の末尾に追加する．

   pack(template)

        配列の内容をtemplate文字列にしたがって，1つの文字列にパックす
        る．パックした文字列を返す．テンプレートは型指定文字列とその長
        さ(省略時は1)を並べたものである．長さとして`*'が指定された時は
        「残りのデータ全て」の長さを表す．

        型指定文字は以下のものがある．

          a     ASCII文字列(null文字を詰める)
          A     ASCII文字列(スペースを詰める)
          b     ビットストリング(下位ビットから上位ビット)
          B     ビットストリング(上位ビットから下位ビット)
          h     16進文字列(下位ニブルが先)
          H     16進文字列(上位ニブルが先)
          c     char
          C     unsigned char
          s     sort
          S     unsigned sort
          i     int
          I     unsigned int
          l     long
          L     unsigned int
          n     ネットワークバイトオーダーのshort
          N     ネットワークバイトオーダーのlong
          f     単精度浮動小数点数(機種依存)
          d     倍精度浮動小数点数(機種依存)
          x     ナルバイト
          X     1バイト後退
          @     絶対位置への移動

   pop

        配列の末尾の要素を取り除いて，それを返す．

   rassoc(value)

        連想リスト(2要素の配列を要素とする配列)を検索し，第2要素が
        valueと等しい("=="で比較する)配列を返す．

   shift

        配列の先頭の要素を取り除いて，それを返す．

   sort

        配列の内容をソートする．イテレータとして呼び出された場合はブロッ
        クを評価した値で要素の大小を決定する．大きい時に正，等しい時に
        0，小さき時に負．通常のメソッドとして呼び出された場合は各要素
        を`<=>'で比較する．

   to_a

	自分自身を返す．対称性のために用意されているメソッドであまり面
	白くない．

   unshift(obj)

        objを配列の先頭に追加する．

Single Methods:

   Array[item..]

	引数を要素とする配列を生成する．

** Bignum(クラス)

無限多倍長整数のクラス．演算の結果がこのFixnumの範囲内である場合には自
動的にクラスはFixnumに変換される．一般的にRubyプログラムではFixnumと 
Bignumの変換は暗黙のうちに行われるので，意識する必要は無い．Floatとの
混合に関しては，Bignumより Floatの方がgenericityが高いのにも関わらず，
Bignumの方が，大きな値を表現できるので，変換時に桁落ちが生じる可能性が
ある．


SuperClass: Integer

Methods:

   self + other
   self - other
   self * other
   self / other
   self % other
   self ** other

        算術演算．それぞれ和，差，積，商，剰余，冪乗を返す．

   ~ self
   self | other
   self & other
   self ^ other

        ビット演算．それぞれビット反転，論理和，論理積，排他的論理和を
        返す．

   self << bits
   self >> bits

        シフト演算．それぞれbitsビットだけ左右にビットシフトを行なう．

   divmod(other)

	商と剰余の2要素の配列を返す．

** Block(クラス)

イテレータに渡される手続きをまとめたオブジェクト．実行するコードだけで
なくコンテキスト(ローカル変数)なども保存する．

SuperClass: Object

Methods:

    call(arg[,..])

	ブロックを実行する．

Single Methods:

    new

	新しいブロックを生成する．yieldを実行できる場所でこのメソッド
	が呼ばれると，その時点で実行されるべきコードを包み込んだオブジェ
	クト(Block)を生成する．

** Class(クラス)

クラスのクラス．より厳密に説明するとクラスは特異メソッドを継承するため
に，それぞれメタクラスと呼ばれる名前のないクラスをクラスとして持ち，
Classはそのメタクラスのクラスである(分かったかな?)．が，この解説が理解
できなくても，Rubyを使うことに何の支障もない．クラスには特異メソッドを
定義できる事と，スーパークラスで定義された特異メソッドはそのサブクラス
でも有効である事を知れば十分である．

SuperClass: Module

Private Methods:

   attr(name[, public])

	そのクラスのインスタンスに対してnameで指定される属性を定義する．
	詳しくはModuleのattrメソッドの項を参照のこと．

Methods:

   new(..)

        クラスのインスタンスを生成する．多くの場合このメソッドはサブク
        ラスの特異メソッドによってオーバーライドされ，クラスによって引
        数が異なる．

** Comparable(モジュール)

比較演算を許すクラスのためのMixin．このモジュールをインクルードするこ
とによって，`<=>'演算子を定義するだけで他の演算子はその定義を利用して
派生できる．

Methods:

   self == other

        selfがotherと等しい時真を返す．

   self > other

        selfがotherより大きい時真を返す．

   self >= other

        selfがotherより大きいか等しい時真を返す．

   self < other

        selfがotherより小さい時真を返す．

   self <= other

        selfがotherより小さいか等しい時真を返す．

   between(min, max)

        selfがminとmaxの範囲内にある時真を返す．

** Cons(クラス)

データの組(ペア)を表現するクラス．通常，生成は`::'演算子を用いて行なわ
れる．LispのCONSペアと同様にListを構成する形で用いられることもある．
Consクラスのメソッド`[]',`[]=',`each'はCONSペアからなるリストに対して
も動作するように設計されている．

例:
	a=1::2::3
	a[0]		# a[0] => 1
	a[2] = 5	# a => 1::5::3
	for i in a
	  print i
	end		# prints `153'

SuperClass: Object

Included Modules: Enumerable

Methods:

   self [nth]

	CONSペアからなるリストのnth番目の要素を返す．対応する要素が存
	在しない場合はnilを返す．

   self [nth]= val

	CONSペアからなるリストのnth番目の要素を変更する．リストの長さ
	がnthで指定した長さよりも短くて，対応する要素が存在しない場合
	は例外が発生する．nthがリストの長さと等しい時にはリストの末尾
	に要素を追加する．

   car

	CONSペアのデータのCAR部を返す．

   car=(val)

	CONSペアのCAR部のデータを変更する．

   cdr

	CONSペアのデータのCDR部を返す．

   cdr=(val)

	CONSペアのCDR部のデータを変更する．

   copy

	CONSペアからなるリストの複製を返す(shallow copy)．

   each

	CONSペアからなるリストの各要素を与えるイテレータ．

** DBM(クラス)

NDBMファイルをアクセスするクラス．キー，データともに文字列でなければな
らないという制限と，データがファイルに保存されるという点を除いては 
Dictクラスと全く同様に扱うことができる．NDBMを備えていないシステムでは
このクラスは定義されない．

SuperClass: Object

Included Modules: Enumerable

Methods:

   self [key]

        keyをキーとする値を返す．

   self [key]= value

        keyをキーとして，valueを格納する．valueとしてnilを指定すると，
        keyに対する項目の削除となる．

   clear

	DBMファイルの中身を空にする．

   close

        DBMファイルをクローズする．以後の操作は例外を発生させる．

   delete(key)

        keyをキーとする組を削除する．

   delete_if

	要素を削除するイテレータ．key::valueというペアを与えて，ブロッ
	クを評価した値が真の時，該当する項目を削除する．

   each
   each_pair

        key::valueなるペアを与えるイテレータ．

   each_key

        全てのkeyに対して繰り返すイテレータ．

   each_value

        全てのvalueに対して繰り返すイテレータ．

   has_key(key)
   includes(key)

        keyがデータベース中に存在する時，真を返す

   has_value(value)

        valueを値とする組がデータベース中に存在する時，真を
        返す

   indexes(ary)
   indexes(key-1, ..., key-n)

	1番目の形式では文字列の配列を引数として受けて，その要素をキー
	とする要素を含む配列を返す．2番目の形式では各引数の値をキーと
	する要素を含む配列を返す.

   keys

        データベース中に存在するキー全てを含む配列を返す．

   length
   size

	データベース中の要素の数を返す．(注意:現在の実現では要素数を数
	えるためにデータベースを全部検索するので，結構コストが高い．気
	をつけて使うこと.)

   to_a

	データベース中のkey-valueペアを要素とする配列を返す．

   values

        データベース中に存在する値全てを含む配列を返す．

Single Methods:

   open(dbname[, mode])

        dbnameで指定したデータベースをモードをmodeに設定してオープンす
        る．modeの省略値は0666である．modeとしてnilを指定するとデータ
        ベースが既に存在しない時には新たにオープンせず，nilを返す．

** Dict(クラス)

辞書あるいは連想配列．任意のオブジェクトを添字とできる配列のクラスであ
る．Hashという名前でもアクセスできる．連想配列オブジェクトの生成は一般
的には連想配列式``{a=>b,..}'' で行なわれる．

SuperClass: Object

Included Modules: Enumerable

Methods:

   self [key]

        keyをキーとする値を返す．

   self [key]= value

        keyをキーとして，valueを格納する．valueとしてnilを指定するとそ
        のkeyに対する項目の削除となる．つまり，Dictは値としてnilを持つ
        ことはできない．

   clear

	連想配列を空にする．

   delete(key)

        keyをキーとする組を削除する．

   delete_if

	要素を削除するイテレータ．key::valueというペアを与えて，ブロッ
	クを評価した値が真の時，該当する項目を削除する．

   each
   each_pair

        key::valueなるペアを与えるイテレータ．

   each_key

        全てのkeyに対して繰り返すイテレータ．

   each_value

        全てのvalueに対して繰り返すイテレータ．

   has_key(key)
   includes(key)

        keyが辞書中に存在する時，真を返す

   has_value(value)

        valueを値とする組が辞書中に存在する時，真を返す

   indexes(ary)
   indexes(key-1, ..., key-n)

	1番目の形式では配列を引数として受けて，その要素をキーとする要
	素を含む配列を返す．2番目の形式では各引数の値をキーとする要素
	を含む配列を返す．

   keys

        辞書中に存在するキー全てを含む配列を返す．

   length
   size

	辞書中の要素の数を返す．

   to_a

	辞書中のkey-valueペアを要素とする配列を返す．

   values

        辞書中に存在する値全てを含む配列を返す．

Single Methods:

   Dict[key, value..]

	奇数番目の引数をkey，偶数番目の引数をvalueとする辞書を生成する．

   new

        新しい(空の)辞書オブジェクトを返す．

** Directory(クラス)

ディレクトリ内の要素を順に返すディレクトリストリーム操作のためのクラス．
Dirという名前でもアクセスできる．

SuperClass: Object

Included Modules: Enumerable

Methods:

   close

        ディレクトリストリームをクローズする．以後の操作は例外を発生さ
        せる．

   each

        ディレクトリ内の各要素を順に与えるイテレータ．

   getwd
   pwd

        カレントディレクトリを返す．

   rewind

        ディレクトリストリームを先頭にリセットする．

   seek(pos)

        ディレクトリストリームの位置をposに設定する．

   tell

        ディレクトリストリームの現在の位置を返す．

Single Methods:

   chdir(path)

        カレントディレクトリをpathに変更する．

   chroot(path)

        プロセスのルートディレクトリを変更する，同名のシステムコールと
        同じ働きをする．この操作は実効uidがスーパユーザである時だけに
        制限されている．ルートディレクトリを元に戻す(ルートディレクト
        リを上方に変更する)方法は提供されていない．

   mkdir(path[, mode])

        modeで指定されたモードを持つディレクトリpathを作成する．モード
        はumaskによって修正される．modeのデフォルト値は0777．

   open(path)

        pathに対するディレクトリストリームをオープンする．

   rmdir(path)

        pathで指定されたディレクトリを削除する．ディレクトリは空である
        必要がある．

** Enumerable(モジュール)

要素に対する繰り返しを行なうクラスのためのMixin．このモジュールをイン
クルードするためには，メソッド`each'を定義する必要がある．

Methods:

   collect

        各要素に対してブロックを評価した結果を全て含む配列を返す

   find

        要素の対してブロックを評価した値が真になった最初の要素を返す．

   find_all

        各要素に対してブロックを評価した値が真であった要素を全て含む配
        列を返す．

   grep(pattern)

        「要素 =~ pattern」が成立する全ての要素を含む配列を返す．イテ
        レータとして用いられた時は上記の条件の成立した要素に対してブロッ
        クを実行する．

   includes(val)

	valと`=='の関係にある要素を持つ時，真を返す．

   index(val)

	valと`=='の関係にあるオブジェクトが何番目に現れたかを返す．一
	番最初の要素が0になる．要素が存在しない時にはnilを返す．順序の
	ないクラスに対してはあまり意味がない．

   length

	要素の数を返す．

   min

	最小の要素を返す．全ての要素がお互いに`<=>'メソッドで比較でき
	ることを仮定している．

   max

	最大の要素を返す．各要素が`<=>'メソッドで比較できることを仮定
	している．

   reverse

        全ての要素を逆順に並べた配列を返す．

   sort

        全ての要素をソートした配列を返す．

** Etc(モジュール)

/etcディレクトリ以下の情報を得るためのモジュール．クラスにインクルード
して使うこともできる．

Methods:
Single Methods:

   getlogin

	自分のlogin名を返す．これが失敗した場合はgetpwuid()を用いると
	良い．

   getpwnam(name)

	/etc/passwdファイル(あるいはDBMファイルやNISデータベース)を検
	索し，nameの名前を持つpasswdエントリを返す．戻り値はpasswd構造
	体で以下のメンバを持つ．

	  struct passwd
	    name 	# ユーザ名(文字列)
	    passwd	# パスワード(文字列)
	    uid		# ユーザID(整数)
	    gid		# グループID(整数)
	    gecos	# gecosフィールド(文字列)
	    dir		# ホームディレクトリ(文字列)
	    shell	# ログインシェル(文字列)
	    # 以降のメンバはシステムによっては提供されない．
	    change	# パスワード変更時間(整数)
	    quota	# クォータ(整数)
	    age		# エージ(整数)
	    class	# ユーザアクセスクラス(文字列)
	    comment	# コメント(文字列)
	    expire	# アカウント有効期限(整数)	    
	  end

	詳細はgetpwnam(3)を参照のこと．

   getpwuid([uid])

	uidをユーザIDとするpasswdエントリを返す．戻り値はgetpwnam()と
	同様である．引数を省略した場合にはgetuid()の値を用いる．詳細は
	getpwuid(3)を参照のこと．

   getgrgid(gid)

	/etc/groupファイル(あるいは…getpwnam参照)を検索し，gidをグルー
	プIDとするグループエントリを返す．戻り値はgroup構造体で以下の
	メンバを持つ．

	  struct group
	    name 	# グループ名(文字列)
	    passwd	# グループのパスワード(文字列)
	    gid		# グループID(整数)
	    mem		# グループメンバ名の配列
	  end

	詳細はgetgrgid(3)を参照のこと．

   getgrnam(name)

	nameという名前のグループエントリを返す．戻り値はgetgrgid()と同
	様である．詳細はgetgrnam(3)を参照．

   group

	全てのグループエントリを順にアクセスするためのイテレータ．

   passwd

	全てのpasswdエントリを順にアクセスするためのイテレータ．

** File(クラス)

ファイルアクセスのためのクラス．メソッドopen()で生成される．また，この
クラスの特異メソッドとしてtestのファイルテスト演算子相当のメソッドが定
義されている(FileTestモジュールのメソッド郡)．

SuperClass: IO

Methods:

   atime

        ファイルの最終アクセス時刻を返す．

   ctime

        ファイルの最終ステータス変更時刻を返す．

   chmod(mode)

        ファイルのパーミッションを変更する(cf chmod(2))．

   chown(owner, group)

        ファイルの所有者とグループを変更する(cf chown(2))．nilか-1を
        指定することによって所有者やグループを現在のまま変えないでおく
        ことができる．

   eof

        ファイルの終端に到達した時に真を返す．

   lstat

        ファイルに関するStat構造体を返す．lstatはファイルがシンボリッ
        クリンクであればリンクそのものに関するStat構造体を返す．構造体
        の内容についてはstatを参照のこと．

   mtime

        ファイルの最終修正時刻を返す．

   rewind

        ファイルのファイルポインタの位置を先頭に移動する．

   path

        ファイルのパス名を返す．

   seek(offset, ptrname)

        ファイルのファイルポインタの位置をoffsetに移動する．ptrnameは
        0，1，2のいずれかであって，それぞれファイルの先頭，現在位置，
        ファイルの終端のうちのいずれかからの相対を示す．

   stat

        ファイルに関するStat構造体を返す(Struct を参照)．

	  struct stat
	    dev	 	# ファイルの存在するデバイス
	    ino		# ファイルのi-node番号
	    mode	# モード
	    nlink	# ハードリンクの数
	    uid		# 所有者のユーザID
	    gid		# 所有者のグループID
	    rdev	# デバイスのID(スペシャルファイルのみ)
	    size	# ファイルサイズ(byte数)
	    blksize	# ファイルシステムにおいて適切なブロックサイズ
	    blocks	# ブロック数
	    atime	# 最終アクセス時間
	    mtime	# 最終更新時間
	    ctime	# 最終状態変更時間
	  end

	詳細な説明はfstat(2)を参照のこと．システム上で定義されている
	stat構造体に該当するメンバがない場合は0が設定されている．

   tell

        ファイルの現在のファイルポインタの位置を返す．

   truncate(length)

        ファイルを切り捨てて最大lengthバイトにする．ファイルはwriteモー
        ドでオープンされていなければならない．

Single Methods:

   atime(filename)

        filenameの最終アクセス時刻を返す．

   ctime(filename)

        filenameの最終ステータス変更時刻を返す．

   chmod(mode, path, file..)

        ファイルのパーミッションを変更する(cf chmod(2))．変更したファ
        イル数を返す．fileにはワイルドカードも許す．

   chown(owner, group, file..)

        ファイルの所有者とグループを変更する(cf chown(2))．nilか-1を指
        定することによって所有者やグループを現在のまま変えないでおくこ
        とができる．変更したファイル数を返す．fileにはワイルドカードも
        許す．

   link(old, new)

        oldへのハードリンクnewを生成する．link(2)と同じ制限がある．

   mtime(filename)

        filenameの最終修正時刻を返す．

   readlink(path)

        シンボリックリンクpathの内容を文字列として返す．

   rename(from, to)

        ファイル名fromをtoに変更する．rename(2)参照．既にtoという名前
        のファイルが存在する時にはまずそのファイルが削除される．

   stat(filename)

        filenameのファイルのStat構造体を返す．

   symlink(old, new)

        oldへのシンボリックリンクnewを生成する．

   truncate(path, length)

        pathで指定されたファイルを切り捨てて最大lengthバイトにする．

   type(filename)

	filenameのファイルのタイプを表す文字列を返す．文字列は"file"，
	"directory"，"characterSpecial"，"blockSpecial"，"fifo"，
	"link"，"socket"のうちのいずれか一つである．

   unlink(file..)

        ファイルを削除する．ディレクトリの削除にはDir.rmdirを使うこと．
        fileにはワイルドカードも許す．

   utime(atime, mtime, file..)

        ファイルのアクセス時刻をatimeに，修正時刻をmtimeに設定する．
        atime，mtimeは数またはTimeクラスのインスタンスでなければならな
        い．fileにはワイルドカードも許す．


 これ以外にFileTestモジュールのメソッドも特異メソッドとして持つ．

** FileTest(モジュール)

ファイルテスト用メソッドを集めたモジュール．インクルードして用いること
もできる．

Methods:
Single Methods:

   b(filename)

        filenameのファイルがブロックスペシャルファイルである時，真を返
        す．

   c(filename)

        filenameのファイルがキャラクタスペシャルファイルである時，真を
        返す．

   executable(filename)
   x(filename)

        filenameのファイルが実行可能の時，真を返す．

   exists(filename)
   e(filename)
   a(filename)

        filenameのファイルが存在する時，真を返す．

   G(filename)

        filenameのファイルのgidが実効グループのgidと同じ時，真を返す．

   isdirectory(filename)
   d(filename)

        filenameがディレクトリの時，真を返す．

   isfile(filename)
   f(filename)

        filenameのファイルが通常ファイルの時，真を返す．

   islink(filename)
   l(filename)

        filenameのファイルがシンボリックリンクである時，真を返す．

   ispipe(filename)
   p(filename)

        filenameのファイルが名前つきパイプ(FIFO)である時，真を返す．

   issocket(filename)
   S(filename)

        filenameのファイルがソケットである時，真を返す．

   owned(filename)
   O(filename)

        filenameのファイルを実効ユーザが所有している時，真を返す．

   readable(filename)
   r(filename)

        filenameのファイルを読みとり可能の時，真を返す．

   R(filename)

        filenameのファイルを実uid/gidで読みとり可能の時，真を返す．

   setuid(filename)
   u(filename)

        filenameのファイルのsetuidビットがセットされている時，真を返す．

   setuid(filename)
   g(filename)

        filenameのファイルのsetuidビットがセットされている時，真を返す．

   size(filename)
   s(filename)

        filenameのファイルが存在する時，ファイルの大きさを返す．存在し
        ない時はnilを返す．

   sticky(filename)
   g(filename)

        filenameのファイルのstickyビットがセットされている時，真を返す．

   writable(filename)
   w(filename)

        filenameのファイルが実uid/gidで書き込み可能の時，真を返す．

   W(filename)

        filenameのファイルが書き込み可能の時，真を返す．

   z(filename)

        filenameのファイルが存在し，大きさが0である時，真を返す．

** Fixnum(クラス)

31bit(マシンのlongの長さ-1 bit)整数のクラス．builtin classである．この
クラスはpointer内の即値であるためcall by valueで呼び出される点が特徴的
である(他のクラスはcall by reference)．演算の結果が31bitを越える場合に
は自動的にBignum(無限多倍長整数)に拡張される．

イテレータupto()，downto()，step()は繰り返しのために用いられ，一般に
Rangeクラスを用いるより高速である．

SuperClass: Integer

Methods:

   self + other
   self - other
   self * other
   self / other
   self % other
   self ** other

        算術演算．それぞれ和，差，積，商，剰余，冪乗を返す．

   ~ self
   self | other
   self & other
   self ^ other

        ビット演算．それぞれビット反転，論理和，論理積，排他的論理和を
        返す．

   self << bits
   self >> bits

        シフト演算．それぞれbitsビットだけ左右にビットシフトを行なう．

   self .. max

        範囲指定．self から maxまでの範囲オブジェクトを返す．

   downto(min)

        イテレータ．selfからminまで下向きに繰り返す．

   id2name

	整数値をIDだとみなして，相当する文字列を返す．相当する文字列が
	存在しない場合はnilを返す．

   step(max, step)

        イテレータ．selfからmaxまでstepずつ変化しながら，繰り返す．

   to_f

        selfをFloatに変換したものを返す．

   to_i

        selfをそのまま返す．

   upto(max)

        イテレータ．selfからmaxまで繰り返す．

** Float(クラス)

 浮動小数点数のクラス．

SuperClass: Numeric

Methods:

   self + other
   self - other
   self * other
   self / other
   self % other
   self ** other

        算術演算．それぞれ和，差，積，商，剰余，冪乗を返す．

   self == other
   self > other

        比較演算．

   coerce(num)

        numをfloatに変換する．ただし現時点でFloatが理解できる他の数は
        FixnumとBignumだけである．

   to_f

        selfをそのまま返す．

   to_i

        selfを整数に変換した結果を返す．

Single Methods:

   new(float)

	floatと同じ値を持つ新しいFloatオブジェクトを返す．

** GC(モジュール)

Ruby組み込みのgarbage collectorの制御を行なうためのモジュール．このモ
ジュールのメソッドをを用いることによって，一時的にGCを止めたり，GCの起
きるタイミングを制御したりできる．

Methods:

   garbage_collect

        GCを開始する．「GC.start」と同義．

Single Methods:

   disable

        GCを禁止する．

   enable

        GCを許可する．

   start

        GCを開始する．

** Glob(クラス)

ワイルドカードのクラス．ワイルドカードのリテラルは<..>という形式であ
る．正規表現とほぼ同じように使えるが，こちらは機能が少ない．ただし，ワ
イルドカードの展開機能がある．

SuperClass: Object

Included Modules: Enumerable

Methods: 

   self =~ string

        ワイルドカードが文字列にマッチした場合には真を，しない場合は
        nilを返す．

   each

	ワイルドカードにマッチするファイル名を与えるイテレータ．

Single Methods:

   new(string)

        文字列をワイルドカードに変換したオブジェクトを返す．

** Integer(クラス)

整数クラス．実際はその大きさによってFixnumとBignumいう二つのサブクラス
で実現されている．Integerはそれらのスーパークラスとなる抽象クラスであ
る．Rubyではほとんどの場合，FixnumとBignumの区別は必要なく，相互の変換
は自動的に行なわれる．整数をビット列だとみなす場合には，無限の長さをも
つビット列と考えて構わない．

SuperClass: Numeric

Methods:

   self[idx]

	整数のidxビット目がセットされていれば1，セットされていなければ
	0を返す．

   chr

	その数をコードとする文字だけを含む1文字の文字列を返す．一般に
	長さ1以上の文字列について，次の関係が常に成立する．

		str[0].chr == str[0,1]

	整数が文字の範囲内(0..255)になければ例外が発生する．

   is_integer

	いつも真を返す．

** IO(クラス)

入出力のための基本クラス．

SuperClass: Object

Included Modules: Enumerable

Methods:

   self << object

        objectを出力する．objectが文字列でない時にはメソッドto_sを用い
        て文字列に変換する．selfを戻り値とするので，C++のような`<<'の
        連鎖を使える．

        例:

            $stdout << 1 << " is a " << Fixnum << "\n"

   close

        入出力ポートをクローズする．以後のこのオブジェクトに対する入出
        力操作はエラーになる．

   each

        一行ずつ読み込んでくるためのイテレータ．行の区切りはシステム変
        数`$/'によって変更できる．読み込んだ文字列はシステム変数`$_'に
        もセットされる．

   each_byte()

        一文字ずつ読み込んでくるためのイテレータ．文字は文字コードを表
        すFixnumである．

   fileno
   to_i

        IOオブジェクトが使っているファイルディスクリプタ(Fixnum)を返す．

   flush

        バッファをフラッシュする．

   getc

        一行読み込んで，読み込みに成功した時にはその文字列を返す．ファ
        イルの終りに到達した時にはnilを返す．カーネルメソッドgetc()は 
        $stdin.getcと同じ意味である．

   gets

        一行読み込んで，読み込みに成功した時にはその文字列を返す．ファ
        イルの終りに到達した時にはnilを返す．

   isatty

        入出力ポートがttyである時，真を返す．

   puts(obj)

        objを出力する．「self << obj」と同じ意味である．

   read([length])

        lengthバイト読み込んで，その文字列を返す．lengthが省略された時
        には，全てのデータを読み込む．

   readlines

	ファイルを全て読み込んで各行を要素としてもつ配列を返す．

   sync

	現在の出力同期モードを真偽値で返す．同期モードが真の時は出力関
	数の呼出毎にバッファがフラッシュされる．

   sync=(newstate)

        出力同期モードを設定する．

   sysread(length)

        stdioを経由せずにread(2)を用いて入力を行なう．入力されたデータ
        を含む文字列を返す．ファイルの終りに到達した時にはnilを返す．
        read(2)の性質により必ずlengthバイトの文字列が読み込まれるわけ
        ではない．gets()やgetc()などstdioを経由するメソッドと混用する
        ことはバッファリングの不整合などで思わぬ動作をすることがある．

   syswrite(str)

        stdioを経由せずに，write(2)を用いて出力を行なう．このメソッド
        はバッファリングなどstdioがしてくれることは一切行なわない．
        syswriteは実際に書き込んだバイト数を返す．print()やprintf()と 
        syswrite()を混用するのは推奨できない．

   write(str)

        strを出力する．出力したバイト数を返す．

** Kernel(クラス)

全てのクラスの基底クラス．Ruby組み込みの全ての関数メソッドはこのクラス
で定義されている．関数メソッドについては「関数」の項目を参照のこと．

SuperClass: なし

Methods:

   ! self

        否定．Non-nilのオブジェクトの場合常に偽(nil)を返す．このメソッ
        ドはNilクラスでは再定義され真を返す．

   self == other
   equal(other)

        オブジェクトの一致判定．レシーバと引数の引数が一致する時，真を
        返す．Kernelクラスの定義では双方のオブジェクトが同一の時真を返
        す．"=="メソッドは各オブジェクトの性質に応じて再定義する必要が
        ある．"=="メソッドを再定義した時には，hashメソッドもそれに合わ
        せて再定義する必要がある．

        equal()メソッドは"=="メソッドの別名で，"=="を再定義した後でも
        オブジェクトの同一性判定を行なうために用いられる．よって
        equal()メソッドはサブクラスで再定義するべきではない．

   self != other

        "=="の否定．内部で"=="メソッドを呼び出しているので，こちらは再
        定義する必要はない．

   self =~ other

        マッチ．デフォルトの動作は"=="と同じである．"=~"はcaseの比較に
        も用いられる．

   !~

        "=~"の否定．内部で"=~"メソッドを呼び出しているので，こちらは再
        定義する必要はない．

   self :: other

        selfとotherを要素とするCONSペアを返す．この演算子は右結合であ
        るので，a::b::c は (a::(b::c)) と解釈される．

   is_nil

        オブジェクトがnilであるかどうか．Kernelクラスの定義では真を返
        す．Nilクラスで再定義されている．

   id

        各オブジェクトに対して一意のFixnumを返す．が，Fixnumは自分自身を返
        すので，idが一致しても同じオブジェクトであることは保証されない．
        つまり，

		obj1.id == obj2.id

	が成立しても，どちらかがFixnumであれば，obj1とobj2が同じである
	とは限らない．ただし，両方がFixnumでないことが保証できれば，2
	つのオブジェクトが同一であることは確実である．

   hash

        オブジェクトのハッシュ値(Fixnum)を返す．Dictクラスでキーとなる
        オブジェクトを格納するのに用いられている.「A == B」が成立する
        時は必ず「A.hash == B.hash」が成立する必要があるので，"=="を再
        定義した時には必ずこちらもそれに合わせて再定義すること．


** Math(モジュール)

浮動小数点演算をサポートするクラス．Mathモジュールは同じ定義のメソッド
と特異メソッドとの両方が定義されているので，特異メソッドを呼び出して使
う使い方と，クラスにインクルードして使う使い方との両方ができる．

  例:

        pi = Math.atan2(1, 1) * 4;
        include Math
        pi2 = atan2(1, 1)

Methods:
Single Methods:

   atan2(x, y)

        π〜-πの範囲でX/Yのアークタンジェントを返す．

   cos(x)
   sin(x)
   tan(x)

        ラジアンで表されたxの三角関数の値を返す．

   exp(x)

        xの指数関数の値を返す．

   log(x)

        xの自然対数を返す．

   log10(x)

        xの常用対数を返す．

   sqrt(x)

        xの平方根を返す．xの値が負である時には例外を発生させる．

   cbrt(x)

        xの立方根を返す．

** Module(クラス)

モジュールのクラス．

SuperClass: Object

Private Methods:

   attr(name[, public])

	そのモジュールをインクルードしたクラスのインスタンスに対して 
	nameで指定される属性を付加し，属性に対するアクセスメソッドを定
	義する．attr("attr")はクラス定義に以下に示すコードを追加するの
	とほぼ同義である．

	  def attr; @attr; end

	省略可能な第2引数publicが与えられて，かつその値がnilでない時に
	はその属性には属性設定メソッドも用意され，外部から代入可能にな
	る．attr("attr", %TRUE)はクラス定義に以下のコードを追加するの
	とほぼ同義である．

	  def attr; @attr; end
	  def attr=(val); @attr = val; end

	属性を構成するメソッドを再定義することによって，アクセス時の動
	作を変更できる．例えば

	  attr("test", %TRUE)
	  def test=(val)
	    print("test was ", @test, "\n")
	    print("and now is ", @test = val, "\n")
	  end

	のように設定時に属性の値を表示するようなことが可能である．attr
	はアクセスメソッドがすでに定義されている場合は，デフォルトのア
	クセスメソッドを定義しない．

Methods:

   export(name[, name..])

	nameで指定されたメソッドを通常形式で呼び出し可能にする．すでに
	通常メソッドである場合には何もしない．

   to_s

        モジュールの文字列表現を返す．モジュールの場合の文字列表現はモ
        ジュール名である．

   unexport(name[, name..])

	nameで指定されたメソッドを関数形式でだけ呼び出し可能にする．す
	でに関数メソッドである場合には何もしない．

** Nil(クラス)

偽を表すオブジェクトnilのクラス．偽変数(の値)nilはNilクラスの唯一のイ
ンスタンスである．

SuperClass: Kernel

Methods:

   self + other

	otherが整数，浮動小数点数，文字列，配列である時，otherを返す．

   ! self

        常に真を返す．

   is_nil

        常に真を返す．

** Numeric(クラス)

数一般の性質を表す抽象クラス．

SuperClass: Object

Included Modules: Comparable

Methods:

   + self

        オブジェクトselfそのものを返す

   - self

        「0 - self」の値を返す．サブクラスでより効率的に再定義されるこ
        とが期待される．

   abs

	絶対値を返す．

   divmod(other)

	商と剰余のペアを返す．

   next

	次の数を返す．次の数とはその数を越える最小の整数である．

** Object(クラス)

全ての通常クラスのスーパクラス．通常クラスのインスタンスの一般的な振舞
いを定義している．このクラスのサブクラスでないクラスはKernelとNilと，
組み込み関数を定義しているBuiltinだけである．

SuperClass: Builtin

Methods:

   init_object


   is_member_of(class)

        オブジェクトselfがクラスclassのインスタンスである時，真を返す．

   is_kind_of(class)

        オブジェクトselfがクラスclassかそのサブクラスのインスタンスで
        ある時，真を返す．

   clone

        オブジェクトの複製を作る．インスタンスが即値であるFixnumクラス
        以外のクラスの場合，「obj.equal(obj.clone)」は偽であるが，多く
        の場合「obj == obj.clone」は真である．

   to_s

        オブジェクトの文字列表現を返す．このメソッドは内部的にprint()
        やformat()メソッドで用いられている．

   to_a

	オブジェクトを配列に変換する．カーネルクラスで定義されているデ
	フォルトは，そのオブジェクト自身を含む1要素の配列を返す．

** Process(モジュール)

プロセスに関する操作を行なうためのモジュール．Mathモジュールと同様に全
てのメソッドは特異メソッドとしても通常のメソッドとしても使える．
Processはプロセスオブジェクトのクラスではなくて，プロセス操作のメソッ
ドをまとめたものであることに注意すること．

Methods:
Single Methods:

   egid

	プロセスの現在の実効GIDを返す．

   egid=(gid)

	プロセスの現在の実効GIDをgidにセットする．
	
   euid

	プロセスの現在の実効UIDを返す．

   euid=(uid)

	プロセスの現在の実効UIDをuidにセットする．
	
   getpgrp([pid])

	pidで指定されたプロセスが現在所属しているプロセスグループのid
	を返す．pidを省略した時とpidに0を与えた時は現在実行しているプ
	ロセスを対象にする．

   getpriority(which, who)

	whichとwhoで指定されるプロセス，プロセスグループ，ユーザの現在
	の優先順位を返す．詳細はgetpriority(2)を参照．Processモジュー
	ルではwhichとして指定できる定数%PRIO_PROCESS，%PRIO_PGRP，
	%PRIO_USERが定義されている．

   gid

	プロセスの現在の実GIDを返す．

   gid=

	プロセスの現在の実GIDをgidにセットする.

   pid

	プロセスのプロセスIDを返す．これはシステム変数`$$'の値と同じで
	ある．

   ppid

	親プロセスのプロセスのプロセスIDを返す．UNIXでは直接の親プロセ
	スが終了した場合，親プロセスのpidは1(initのpid)になる．

   setpgrp(pid, pgrp)

	pidで指定されたプロセスのプロセスグループをpgrpにする．pidに0
	を与えると現在実行中のプロセスを対象にする．

   setpriority(which, who, prio)

	whichとwhoで指定されるプロセス，プロセスグループ，ユーザの現在
	の優先順位をprioに設定する．詳細はsetpriority(2)を参照のこと．

   uid

	プロセスの現在の実UIDを返す．

   uid=

	プロセスの現在の実UIDをuidにセットする.

** Range(クラス)

範囲オブジェクトのクラス．範囲オブジェクトは`..'演算子によって生成され，
一般的には以下のような使い方をする

        for i in 1..5
          ...
        end

しかし，この場合は以下の方が速い.

        do 1.upto(5)
          ...
        end

範囲オブジェクトを生成する`..'演算子の両辺はComparableを含むクラスのイ
ンスタンスであれば何でも構わない．範囲は始点と終点を含むことに注意する
こと.

SuperClass: Object

Included Modules: Enumerable

Methods:

   self =~ other

        selfがotherと同じクラスに対する範囲オブジェクトで，その範囲内
        にotherがある時(start <= other <= end)，真を返す．これはcase式
        で範囲指定する時に便利である．例えば

            case i
              when 1, 3..5
                ...
            end case

        のようなコードを書くことができる．

   each

        範囲内に存在するオブジェクトを与えるイテレータ．主にfor式のた
        めに用いられる．

   end

        範囲の終点を返す

   start

        範囲の始点を返す．

** Socket(クラス)

SuperClass: BasicSocket

ソケットそのものに対するシステムコールレベルのアクセスを提供するクラス．
Perlのソケットに対するアクセスと同レベルの機能を提供している．このクラ
スではソケットアドレスはpackされた文字列で，指定する．UDPソケットはこ
のクラスを使って利用する．

Methods:

   accept

	新しい接続を受け付けて，新しい接続に対するソケットとアドレスの
	ペアを返す．accept(2)を参照．

   bind(addr)

	bind(2)と同じ働きをする．addrはpackされたソケットアドレス構造
	体である．

   connect(addr)

	connect(2)と同じ働きをする．addrはpackされたソケットアドレス構
	造体である．

   listen(backlog)

	listen(2)と同じ働きをする．

   recv(len[, flags])

	ソケットからデータを受け取り，文字列として返す．lenは受け取る
	最大の長さを指定する．flagsについてはrecv(2)を参照．flagsのデ
	フォルト値は0である．

   recvfrom(len[, flags])

	recvと同様にソケットからデータを受け取るが，戻り値は文字列と相
	手ソケットのアドレスのペアである．引数についてはrecvと同様．

   send(mesg, flags[, to])

	ソケットを介してデータを送る．flagsに関してはsend(2)を参照の事．
	connectしていないソケットに対しては送り先であるtoを指定する必
	要がある．実際に送ったデータの長さを返す．

Single Methods:

   open(domain, type, protocol)
   new(domain, type, protocol)

	新しいソケットを生成する．domain，type，protocolはインクルード
	ファイルで定義されている定数値で指定する．domainとtypeに関して
	は，文字列で指定できるが，すべてをカバーしている保証はない．

   socketpair(domain, type, protocol)

	ソケットのペアを返す．引数の指定は openと同じである．
   

** Regexp(クラス)

正規表現のクラス．正規表現のリテラルは/.../という形式で表すが，動的に
生成するためには

        Regexp.new(文字列)

とする．ただし，Stringクラスの`=~'を始めとして多くのメソッドは正規表現
の替わりに文字列が与えられた時には内部的に正規表現を生成するので，生成
コストを節約したいと思う時や，正規表現の大文字小文字の区別を明示的に指
定したい時など以外は明示的に生成したいと思うことは少ないはずだ．

SuperClass: Object

Methods:

   self =~ string

        正規表現が文字列にマッチした場合，マッチした位置を返す．マッチ
        しない場合はnilを返す．

   ~ self

        「$_ =~ self」と同義．

Single Methods:

   complie(string[, casefold])
   new(string[, casefold])

        文字列を正規表現に変換したオブジェクトを返す．省略可能な第2引
        数が与えられた時には，生成される正規表現オブジェクトはシステム
        変数`$='の値に関わらず，真の時は大文字小文字を無視し，偽の時は
        区別する．設定されない場合はマッチを行なった時点のシステム変数
        `$='の値によって区別するかしないかが決定される．

   quote(str)

	文字列の中の正規表現で意味を持つ文字をエスケープする．新しい文
	字列を返す．

** BasicSocket(クラス)

ソケットを表す抽象クラス．具体的なソケット操作はサブクラスで定義される．
例えばインターネットドメインの場合はTCPsocketを用いる．

SuperClass: IO

Methods:

   getopt(level, optname)

	ソケットのオプションを取得する．getsockopt(2)を参照のこと．取
	得したオプションの内容を含む文字列を返す．

   getpeername

	接続の相手先のソケットの情報を得る．パックされたsockaddr構造体
	をベタにダンプした文字列が返される．getpeername(2)を参照のこと．

   getsockname

	ソケットの情報を得る．パックされたsockaddr構造体をベタにダンプ
	した文字列が返される．getsockname(2)を参照のこと．

   setopt(level, optname, optval)

	ソケットのオプションを設定する．setsockopt(2)を参照のこと．

   shutdown(how)

	ソケットの以降の接続を終了させる．howが0である時，以降の受信が，
	howが1である時は，以降の送信が拒否される．howが2の時には，それ
	以降の送信，受信ともに拒否される．shutdown(2)を参照．

** String(クラス)

文字列クラス．Rubyの文字列はヌルターミネートではないので，バイナリデー
タも扱える．従ってどちらかというと単なる文字列というよりバイト列である．
その思想に基づいて，正規表現に関するメソッド以外は2byte系の文字を意識
していない．これは作者の手抜きではなく意図的にそうしているのである(信
じてくれ)．

SuperClass: Object

Included Modules: Comparable, Enumerable

Methods:

   self + other

        文字列の連結．連結された文字列を返す．

   self * times

        文字列の繰り返し．例えば

            "x" * 4 == "xxxx"

        である．

   self == other
   self > other

        文字列の比較．システム変数$=がnilでない時には大文字小文字を区
        別せずに比較を行なう．

   self =~ other

        文字列のマッチ．otherは正規表現か文字列．otherが文字列の場合に
        は動的に正規表現に変換される．マッチした場合はマッチした位置，
        しなかった場合はnilが返る．

   ~ self

        「$_ =~ self」と同義．

   self[nth]
   self[beg..end]
   self[beg,len]

        内容の取り出し．1番目の形式ではnthバイト目のデータをFixnumとし
        て返す．2番目の形式ではbegバイト目からendバイト目までの部分文
        字列を返す(両端を含む)．3番目の形式ではbegバイト目からlenバイ
        ト分の部分文字列を返す．

   self[nth] = val
   self[beg..end] = val
   self[beg,len] = val

        内容の更新．1番目の形式ではnthバイト目のデータをval (整数)に変
        更する．2番目の形式はbegバイト目からendバイト目までの部分文字
        列をvalとして与えられた文字列で置き換える．3番目の形式はbegバ
        イト目からlenバイト分の部分文字列をvalとして与えられた文字列で
        置き換える．

   capitalize

	文字列中の最初の文字を(それがアルファベットであれば)，大文字に
	変換し，残る文字列中のアルファベットを小文字に置き換える．

   chop

        文字列の最後のバイトを切り落とす．元の文字列を変更することに注
        意すること．

   crypt(salt)

        crypt(3)を用いて暗号化した文字列を返す．saltは2バイト以上の長
        さの任意の文字列である．

   delete(str)

	文字列のうち，strに含まれる文字を削除する．文字列の指定はtrと
	同様であり，a-bでaからbまでの範囲を，先頭の^で文字列の否定(含
	まれてないものを指定)を意味する．元の文字列を変更することに注
	意すること．

   downcase

        文字列中のアルファベットを全て小文字に置き換えた文字列を返す．

   each

        文字列から1行ずつ読み込んでくるイテレータ．

   each_byte

        文字列のそれぞれのバイトについて繰り返すイテレータ．

   gsub(pattern, replace)

        文字列中でpatternにマッチする部分を全てreplaceに置き換える．
        置換文字列replace中の&と\0はマッチした文字列に，\1..\9はn番目
        の括弧の内容に置き換えられる．

   hex

        文字列を16進数を表す文字列と解釈して，整数に変換する．

   index(substr[, pos])

        substrが最初に出現する位置を返す．posを与えるとその位置から検
        索を開始する．見つからない時にはnilを返す．

   intern

	文字列に一意に対応する整数を返す．文字列はナル文字を含んではな
	らない．

   length
   size

        文字列の長さ(バイト数)を返す．

   ljust(width)
   rjust(width)
   center(width)

	文字列をそれぞれ，右詰め，左詰め，真中寄せした幅widthの文字列
	を返す．文字列長がwidthより長い場合は元の文字列を返し，切り詰
	めない．

   next

        selfからendまで「次の」文字列を返す．次の文字列とは数字は数字
        として，英文字は英文字として増加し，桁上がりの処理が行なわれた
        ものである．

                "aa".next => "ab"
                "99".next => "100"
                "a9".next => "b0"

   oct

        文字列を8進数を表す文字列と解釈して，整数に変換する．8進数の
        定義は/[0-7]+/であり，文字列の先頭からこのパターンにマッチする
        部分を整数に変換する．この定義に全く当てはまらない文字列に対し
        ては0を返す．perlとは違って文字列が0xから始まっているからといっ
        て 16進数だと見なしてくれたりはしない．それらは先頭の0が8進数
        と認識され，0を返す．

   reverse

        文字列の各バイトを逆順に並べた文字列を返す．文字列が2バイトで
        構成される文字を含んでいてもお構いなしにバイト単位で反転する．
        splitは2バイト文字を理解するので，2バイト文字を含む文字列を文
        字単位に反転するには

                "全角文字列".split(//).reverse.join("")

        とすればよい．

   rindex(substr[, pos])

        文字列substrが最後に出現する位置を返す．posを与えるとその位置
        で検索を終了する．見つからない時にはnilを返す．indexとの相違点
        は1)文字列の末尾から検索する．2)substrとして正規表現を受け付け
        ない．の2点である．

   split([sep[, limit]])

        文字列をsepで指定されたパターンによって，フィールドに分割する．
        sepが省略された時のデフォルトはシステム変数`$;'の値が用いられ
        る．limitが指定された時には最大limit個のフィールドに分割する．
        split()は分割された文字列を含む配列を返す．sepで指定されたパター
        ンが空文字列とマッチする場合は文字列が1文字ずつに分割される．

   squeeze([str])

	文字列のうち，strに含まれる文字が連続していた場合，一文字に圧
	縮する．strが省略された場合，すべての文字を対象とする．文字列
	の指定はtrと同様であり，`a-b'でaからbまでの範囲を，先頭の`^'で
	文字列の否定(含まれてないものを指定)を意味する．元の文字列を変
	更することに注意すること．

   strip

	文字列の前後の空白を取り除く．

   sub(pattern, replace)

        文字列中でpatternにマッチする部分をreplaceに置き換える．置換文
        字列replace中の&と\0はマッチした文字列に，\1..\9は n番目の括弧
        の内容に置き換えられる．sub()はgsub()と異なり，最初のマッチだ
        けを置換する．

   sum([bits])

	文字列のbitsビットのチェックサムを得る．省略値は16である．ruby
	では以下のコードでSystem Vの`sum'プログラムと同じ値を得られる．

	  while gets()
	    sum += $_.sum
	  end
	  sum %= 65536

   swapcase

        文字列中のアルファベットのうち大文字を小文字に，小文字を大文字
        に置き換える．

   to_f

        文字列をFloatに変換する．

   to_i

        文字列を10進数を表す文字列と解釈して，整数に変換する．

   toupper

        文字列中のアルファベットを全て大文字に置き換えた文字列を返す．
        tr("a-z", "A-Z")より少し速い．

   tolower

        文字列中のアルファベットを全て小文字に置き換えた文字列を返す．
        tr("A-Z", "a-z")より少し速い．

   tr(search, replace)

        文字列の中にsearch文字列に含まれる文字が存在すれば，replace文
        字列の対応する文字で置き換える．replace文字列が省略された場合
        は空文字列が与えられたと見なす．replace文字列がsearch文字列よ
        りも短い時はreplace文字列の最後の文字が繰り返されていると見な
        す．search文字列の方が短い時には対応する文字のないreplace部は
        単に無視される(BSDのtrの動作)．

	search文字列，replace文字列中に`a-b'という形式が現れた場合，そ
	のaからbまでの範囲の文字をASCIIの昇順で指定したことになる．ま
	た，search文字列の最初の文字が`^'である場合，続く文字列に*含ま
	れない*文字列が置換の対象になる．

	tr(1)の機能のうち，文字を削除する機能，連続する文字を圧縮する
	機能は別のメソッドに分割されている．それらの機能については
	delete，squeezeを参照のこと．

	簡便のため，str.tr(src,repl).squeeze(repl)に相当するメソッド
	tr_s(src,repl) が提供されている．

   unpack(template)

        文字列をtemplate文字列にしたがってアンパックし，それらの要素を
        含む配列を返す．template文字列はArrayクラスのpackメソッドとほ
        ぼ同様である．

          a     ASCII文字列(後続するnull文字やスペースを残す)
          A     ASCII文字列(後続するnull文字やスペースを削除)
          b     ビットストリング(下位ビットから上位ビット)
          B     ビットストリング(上位ビットから下位ビット)
          h     16進文字列(下位ニブルが先)
          H     16進文字列(上位ニブルが先)
          c     char
          C     unsigned char
          s     sort
          S     unsigned sort
          i     int
          I     unsigned int
          l     long
          L     unsigned int
          n     ネットワークバイトオーダーのshort
          N     ネットワークバイトオーダーのlong
          f     単精度浮動小数点数(機種依存)
          d     倍精度浮動小数点数(機種依存)
          x     1バイト読み飛ばす
          X     1バイト後退
          @     絶対位置への移動

	rubyのunpackはperlと違ってチェックサムの計算機能がないことに注
	意すること．


   upcase

        文字列中のアルファベットを全て大文字に置き換えた文字列を返す．

   upto(end)

        selfから始まって，endまで「次の」文字列を順に与えるイテレータ．
        次の文字列とはstr.nextで与えられる文字列である．

        このメソッドはRange:eachで用いられているので，以下のような処理
        が可能である．

                for i in "a" .. "ba"
                  print(i, "\n");
                end

        これはa, b, c, ... aa, ... az, baまでを各行に出力する．
        

        気を付けなければいけないのは，この終了判定は大小関係ではなく 
        `=='で判定されているため，`..'演算子の左辺の値に続く文字列に右
        辺の文字列が含まれていない，以下の例のような場合は無限ループに
        陥ってしまう．

                for i in "0" .. "1a"
                  print(i, "\n");
                end

        作者はこう書くことによって責任を逃れてようとしていると考える人
        もいるかもしれない．その推測は正しい．

Single Methods:

   new(string)

	stringと同じ内容を持つ新しい文字列を返す．

** Struct(クラス)

構造体クラス．複数のデータをまとめる時に用いられる(例: Time::times)．
データをまとめる時には配列クラスが用いられることもあるが(例: select)，
構造体を使うべき時は以下のような場合である．

  (1) 要素の数が固定

      要素の数が変動するものは構造体を使うのには向かない．

  (2) 要素の数が多い

      人間が一度に容易に扱える概念の数は7つまでであるという仮説がある．
      この仮説に従えば，要素が4つ以上あるデータの場合は配列を用いた場
      合，要素数*2(つまりオフセットとその意味)が7を越える．よって，そ
      のような場合には構造体を使った方が理解しやすいと思われる．

  (3) 同時に大量に生成されない

      構造体は配列よりも若干生成コストが高いので，速度が問題になる場合 
      (例えば同時に大量に生成される場合など)は構造体の使用が適切でない
      可能性がある．

各構造体にはメンバ名と同名の引数のないメソッドが定義される．

本ドキュメント内で，構造体を表現するためには以下の形式を使う．

  struct 構造体名
    メンバ...
  end

しかし，プログラム中でこの形式で構造体を生成するわけではない．

SuperClass: Object

Included Modules: Enumerable

Methods:

   self[idx]

	idxが数の時はidx番目の要素を返す．idxが文字列の時はidxと同じ名
	前のメンバの要素を返す．

   values

	構造体のメンバの値を要素に持つ配列を返す．例えば以下のコードで
	自分のpasswdエントリを出力することができる．

	  print(Etc.getpwuid().values.join(":"), "\n")

	この出力は`grep "$USER" /etc/passwd'の出力と余分なフィールドい
	くつか(システムによって異なる)がある以外は同じである．

Single Methods:

   new(name, member::value..)

	nameという名前を持つ構造体を生成する．memberは構造体のメンバを
	表す文字列であり，valueはその値である．生成された構造体はメン
	バで指定された名前の特異メソッドが定義されていて，そのメソッド
	によってメンバの内容を得ることができる．

** TCPserver(クラス)

TCP/IPストリーム型接続のサーバ側のソケットのクラス．このクラスによって
簡単にソケットを利用したサーバのプログラミングができる．例えばechoサー
バは以下のようになる．

 gs = TCPserver.open(4444)
 socks = [gs]

 while %TRUE
   nsock = select(socks);
   if nsock == nil; continue end
   for s in nsock[0]
     if s == gs
       socks.push(s.accept)
     else
       if s.eof
 	 s.close
	 socks.delete(s)
       else
	 str = s.gets
	 s.write(str)
       end
     end
   end
 end

SuperClass: TCPsocket

Methods:

   accept

	クライアントからの接続要求を受け付け，接続したTCPsocketのイン
	スタンスを返す．

Single Methods:

   new([host, ]service)
   open([host, ]service)

	serviceは/etc/services(またはNIS)に登録されているサービス名か
	ポート番号で指定する．hostを指定した時は指定したホストからの接
	続だけを受け付ける．省略時は全てのホストからの接続要求を受け付
	ける．

** TCPsocket

インターネットドメインのストリーム型ソケットのクラス．通常のIOクラスの
サブクラスと同様の入出力ができる．このクラスによってソケットを用いたク
ライアントを簡単に記述できる．ユーザの入力をそのままサーバに転送するプ
ログラムは以下のようになる．

 s = TCPsocket("localhost", 4444)
 while gets()
   s.write($_)
   print(s.read)
 end

SuperClass: BasicSocket

Methods:

   addr

	ソケットの接続情報を表す配列を返す．その配列の各要素は第1要素
	が文字列 "AF_INET"，第2要素がport番号，第3要素がホストを表す文
	字列である．

   peeraddr

	接続相手先ソケットの情報を表す配列を返す．その配列の各要素は
	addrメソッドが返す配列と同じである．

Single Methods:

   open(host, service)
   new(host, service)

	hostで指定したホストのserviceで指定したポートと接続したソケッ
	トを返す．hostはホスト名，またはインターネットアドレスを示す文
	字列，serviceは/etc/services(またはNIS)に登録されているサービ
	ス名かポート番号である．

** Time(クラス)

時間を表すクラス．大小比較などができる．Time.nowで現在の時間を得ること
ができる．またファイルのタイムスタンプを得るメソッドの戻り値もこのクラ
スのインスタンスである．

SuperClass: Object

Included Modules: Comparable

Methods:

   self <=> other

        otherはTimeのインスタンスか整数．整数が与えられた場
        合には1970年 1月 1日 00:00:00 GMTからの秒数であると
        して時刻との比較を行なう．

   asctime
   ctime
   to_s

        時刻をdate(1)形式の文字列に変換する．

   gmtime

        タイムゾーンの修正を行なわないGMTでの時刻を得る．このメソッド
        を受けとったTimeクラスのインスタンスは，以後の時刻変換をGMTで
        行なう．gmtimeは自分自身を返す．

	ロンドンの時刻を表示するには

	  print(Time.now.gmtime, "\n")

	とすればよい．

   localtime

        タイムゾーンの修正を行なった時刻を得る(デフォルト)．localtime
        は自分自身を返す．

   to_i
   tv_sec

        1970年 1月 1日 00:00:00 GMTから時刻までの秒数を整数で返す．時
        刻のsecondの部分でもある．

   sec
   min
   hour
   mday
   year
   wday
   yday
   zone
   isdst

        内部的に保持しているtm構造体の内容を返す．zone以外は整数を返す．
        zoneはタイムゾーンを表す文字列を返す．(cf localtime(3))

   strftime(format)

        時刻をformat文字列に従って文字列に変換した結果を返す．format
        文字列として指定できるものは 以下の通りである．

                %A      曜日の名称(Sunday, Monday,..)
                %a      曜日の省略名(Sun, Mon,..)
                %B      月の名称(January, February,..)
                %b      月の省略名(Jan, Feb,..)
                %c      時刻表現(cf ctime(3))
                %d      十進数での日(01-31)
                %H      24時間制の時(00-23)
                %I      12時間制の時(01-12)
                %j      年中の通算日(001-366)
                %M      分(00-59)
                %m      月を表す数字(01-12)
                %p      午前または午後(AM,PM)
                %S      秒(00-61)
                %U      週を表す数字．最初の日曜日が第1週の
                        始まり(00-53)
                %W      週を表す数字．最初の月曜日が第1週の
                        始まり(00-53)
                %w      曜日を表す数字．日曜日が0(0-6)
                %X      時刻(例: 15:01:06)
                %x      日付(例: Fri Jan 14 1994)
                %Y      西暦を表す数字
                %y      西暦の下2桁(00-99)
                %Z      タイムゾーン
                %%      %自身 

   usec
   tv_usec

        時刻のmicro secondの部分を返す．

Single Methods:

   now

        現在の時刻を表すTimeクラスのインスタンスを生成する．

   at(time)

        timeと同じ時刻を表すTimeクラスのインスタンスを生成する．timeは
        Timeクラスのインスタンスかあるいは数(整数/浮動小数点数)であり，
        数の場合は1970年 1月 1日 00:00:00 GMTからの秒数であるとして時
        刻を計算する．

   times

        現在のプロセスとその子プロセスが消費したユーザ/システムCPUタイ
        ムの積算を構造体として返す(Structを参照)．

	  struct tms
	    utime	# プロセスのユーザ時間
	    stime	# プロセスのシステム時間
	    cutime	# 子プロセスのユーザ時間
	    cstime	# 子プロセスのシステム時間
	  end

	時間の単位は秒であり，浮動小数点数で与えられる．詳細は
        times(3)を参照のこと．

** UNIXserver

UNIXストリーム型接続のサーバ側のソケットのクラス．

SuperClass: UNIXsocket

Methods:

   accept

	クライアントからの接続要求を受け付け，接続したUNIXsocketのイン
	スタンスを返す．

** UNIXsocket

UNIXドメインのストリーム型ソケットのクラス．通常のIOクラスのサブクラス
と同様の入出力ができる．

SuperClass: BasicSocket

Methods:

   addr

	ソケットの接続情報を表す配列を返す．その配列の各要素は第1要素
	が文字列 "AF_UNIX"，第2要素がpathである．

   path

	UNIXソケットのパスを返す．

   peeraddr

	接続相手先ソケットの情報を表す配列を返す．その配列の各要素は
	addrメソッドが返す配列と同じである．

Single Methods:

   open(path)
   new(path)

	pathで指定したパス名を用いて接続したソケットを返す．

* C言語とのインタフェース

rubyはC言語とのインターフェースを提供し，C言語からのクラス，モジュール
の定義，C言語で記述したメソッドの定義，rubyのメソッドの呼び出し，イテ
レータの呼び出し，例外処理などを行なうことが出来る．また，OSが許せば実
行時にCで書かれたモジュールをロードすることも出来る．

具体的なインタフェースに関しては，別ドキュメント(添付ファイル C-IF)を
参照のこと．

* 文法

以下は疑似BNFで記述したrubyの文法である．より正確な記述はparse.yを参照
されたい．

PROGRAM		: COMPEXPR

COMPEXPR	: EXPR (TERM EXPR)* [TERM]

EXPR		: MLHS `=' ARGS
		| ASSOCS
		| return ARGS
		| fail ARGS
		| yield ARGS
		| identifier CALL_ARGS
		| PRIMARY `.' identifier CALL_ARGS
		| super CALL_ARGS
		| undef FNAME
		| alias FNAME FNAME
		| include identifier (`,' identifier)*
		| EXPR if EXPR
		| EXPR while EXPR
		| EXPR and EXPR
		| EXPR or EXPR
		| ARG

ARG		: LHS `=' ARG
		| LHS OP_ASGN ARG
		| ARG `..' ARG
		| ARG `...' ARG
		| ARG `+' ARG
		| ARG `-' ARG
		| ARG `*' ARG
		| ARG `/' ARG
		| ARG `%' ARG
		| ARG `**' ARG
		| `+' ARG
		| `-' ARG
		| ARG `|' ARG
		| ARG `^' ARG
		| ARG `&' ARG
		| ARG `<=>' ARG
		| ARG `>' ARG
		| ARG `>=' ARG
		| ARG `<' ARG
		| ARG `<=' ARG
		| ARG `==' ARG
		| ARG `!=' ARG
		| ARG `=~' ARG
		| ARG `!~' ARG
		| `!' ARG
		| `~' ARG
		| ARG `<<' ARG
		| ARG `>>' ARG
		| ARG `::' ARG
		| ARG `&&' ARG
		| ARG `||' ARG
		| PRIMARY

PRIMARY		: LITERAL
		| VARIABLE
		| super `(' [CALL_ARGS] `)'
		| super
		| PRIMARY `[' [ARGS] `]'
		| `[' [ARGS] `]'
		| `{' ARGS `}'
		| `{' ASSOCS `}'
		| redo
		| break
		| continue
		| retry
		| return
		| fail `(' ARGS `)'
		| fail `(' `)'
		| fail
		| yield `(' ARGS `)'
		| yield `(' `)'
		| yield
		| PRIMARY `{' [ITER_VAR] `|' COMPEXPR `}'
		| identifier `(' [CALL_ARGS] `)'
		| PRIMARY `.' identifier `(' [CALL_ARGS] `)'
		| PRIMARY `.' identifier
		| if EXPR THEN
		  COMPEXPR
		  (elsif EXPR THEN COMPEXPR)*
		  [else COMPEXPR]
		  end
		| while EXPR TERM COMPEXPR end
		| case COMPEXPR
		  (when ARGS THEN)+
		  [else COMPEXPR]
		  end
		| for ITER_VAR in EXPR TERM
		  COMPEXPR
		  end
		| begin
		  COMPEXPR
		  [resque COMPEXPR]
		  [ensure COMPEXPR]
		  end
		| `(' COMPEXPR `)'
		| class identifier `:' identifier
		  COMPEXPR
		  end
		| module identifier
		  COMPEXPR
		  end
		| def FNAME ARGLIST
		  COMPEXPR
		  end
		| def SINGLETON `.' FNAME ARGLIST
		  COMPEXPR
		  end

THEN		: TERM
		| then
		| TERM then

ITER_VAR	: LHS
		| MLHS

MLHS		: LHS `,' [LHS (`,' LHS)*] [`*' LHS]

LHS		: VARIABLE
		| PRIMARY `[' [ARGS] `]'
		| PRIMARY `.' identifier 

CALL_ARGS	: ARGS
		| ASSOCS
		| ARGS `,' ASSOCS
		| ARGS `,' `*' ARG

ARGS 		: ARG
		| ARGS `,' ARG

ARGLIST		: `('[identifier(`,'identifier)*][`*'identifier]`)'
		| TERM

SINGLETON	: VARIABLE
		| `(' COMPEXPR `)'

ASSOCS		: ASSOC (`,' ASSOC)*

ASSOC		: ARG `=>' ARG

VARIABLE	: identifier
		| VARNAME
		| nil
		| self
		| `__FILE__'
		| `__LINE__'

LITERAL		: numeric
		| SYMBOL
		| STRING
		| REGEXP
		| GLOB

TERM		: `;'
		| `\n'

ここより下は字句解析部で認識される．

SYMBOL		: `:'FNAME
		| `:'VARNAME

FNAME		: identifier | `::' | `..' | `|' | `^' | `&'
		| `<=>' | `==' | `=~' | `>' | `>=' | `<' | `<='
		| `<<' | `>>' | `+' | `-' | `*' | `/' | `%' | `**'
		| `~' | `+@' | `-@' | `[]' | `[]='

VARNAME		: GLOBAL
		| `@'identifier
		| `%'identifier

GLOBAL		: `$'identifier
		| `$'any_char

STRING		: `"' any_char* `"'
		| `'' any_char* `''
		| ``' any_char* ``'

REGEXP		: `/' any_char* `/'

GLOB		: `<' any_char* `>'

* 謝辞

Rubyの言語仕様はC, Perl, Eiffelの各言語にこの順に影響を受けている. そ
の他に影響を受けた言語としてはtcl, AWK, bourne shell, CLU, Sather,
Icon, Smalltalk, Emacs Lispなどがある. またrubyの言語仕様を決定するた
めに協力して下さった方々を以下にあげる(敬称略): 石塚圭樹，大庭康生，伊
藤純一郎，中村＠ＮＥＣ．関根＠日本DEC，たなか@赤坂.富士通．

-------------------------------------------------------
Local variables:
fill-column: 70
end:
