A {regular expression}[https://en.wikipedia.org/wiki/Regular_expression]
(also called a _regexp_) is a <i>match pattern</i> (also simply called a _pattern_).
The regexp is a rich, versatile, and powerful tool for manipulating strings.

== \Regexp Uses

A regexp may be used:

- To extract substrings based on a given pattern:

    re = /foo/              # => /foo/
    re.match('food')        # => #<MatchData "foo">
    re.match('food').string # => "food"
    re.match('good')        # => nil

  See sections {Method match}[rdoc-ref:regexp.rdoc@Method+match]
  and {Operator =~}[rdoc-ref:regexp.rdoc@Operator+-3D~].

- To determine whether a string matches a given pattern:

    re.match?('food') # => true
    re.match?('good') # => false

  See section {Method match?}[rdoc-ref:regexp.rdoc@Method+match-3F].

- As an argument for calls to certain methods in other classes and modules,
  including String, Enumerable, and Kernel:

    re = /[aeiouy]/ # Matches a any vowel or y.
    s = 'abstemiously'
    s.gsub(r, '')  # => "bstmsl"

== \Regexp Ingredients

A regexp has:

- A source string, in this case <tt>foo</tt>:

    /foo/ # => /foo/

- Zero or more trailing modifiers (see below):

    /foo/xim # => /foo/mix

- A timeout; see {Timeouts}[rdoc-ref:regexp.rdoc@Timeout].

Much more will be said about the source string:

- Metacharacters and escapes.
- Character classes.
- Unicode properties.
- Repetition.
- Captures.
- Groups.
- Alternation.
- Condition.
- Anchors.

Each of these modifiers sets a mode for the regexp:

- +i+: See {Case-Insensitive Mode}[rdoc-ref:regexp.rdoc@Case-Insensitive+Mode].
- +m+: See {Multiline Mode}[rdoc-ref:regexp.rdoc@Multiline+Mode].
- +x+: See {Extended Mode}[rdoc-ref:regexp.rdoc@Extended+Mode].
- +o+: See {Interpolation}[rdoc-ref:regexp.rdoc@Interpolation].

Each of the modifiers +u+, +e+, +s+, and +n+ sets the encoding for the regexp;
see {Encoding}[rdoc-ref:regexp.rdoc@Encoding].

== Creating a \Regexp

A regular expression may be created with:

- A regexp literal using slash characters
  (see {Regexp Literals}[https://docs.ruby-lang.org/en/master/syntax/literals_rdoc.html#label-Regexp+Literals]):

    # This is a very common usage.
    /foo/ # => /foo/

- A <tt>%r</tt> regexp literal
  (see {%r: Regexp Literals}[https://docs.ruby-lang.org/en/master/syntax/literals_rdoc.html#label-25r-3A+Regexp+Literals]):

    # Same delimiter character at beginning and end;
    # useful for avoiding escaping characters
    %r/name\/value pair/ # => /name\/value pair/
    %r:name/value pair:  # => /name\/value pair/
    %r|name/value pair|  # => /name\/value pair/

    # Certain "paired" characters can be delimiters.
    %r[foo] # => /foo/
    %r{foo} # => /foo/
    %r(foo) # => /foo/
    %r<foo> # => /foo/

- \Method Regexp.new.

== \Method <tt>match</tt>

Each of the methods Regexp#match, String#match, and Symbol#match
returns a MatchData object if a match was found, +nil+ otherwise;
each also sets {global variables}[rdoc-ref:regexp.rdoc@Global+Variables]:

  'food'.match(/foo/) # => #<MatchData "foo">
  'food'.match(/bar/) # => nil

== Operator <tt>=~</tt>

Each of the operators Regexp#=~, String#=~, and Symbol#=~
returns an integer offset if a match was found, +nil+ otherwise;
each also sets {global variables}[rdoc-ref:regexp.rdoc@Global+Variables]:

  'foo bar' =~ /bar/ # => 4
  'foo bar' =~ /baz/ # => nil

Operator NilClass#=~ returns +nil+ and does not set global variables.

== \Method <tt>match?</tt>

Each of the methods Regexp#match?, String#match?, and Symbol#match?
returns +true+ if a match was found, +false+ otherwise;
none sets {global variables}[rdoc-ref:regexp.rdoc@Global+Variables]:

  'food'.match?(/foo/) # => true
  'food'.match?(/bar/) # => false

== Global Variables

Certain regexp-oriented methods assign values to global variables:

- <tt>#match</tt>: see {Method match}[rdoc-ref:regexp.rdoc@Method+match].
- <tt>#=~</tt>: see {Operator =~}[rdoc-ref:regexp.rdoc@Operator+-3D~].

The affected global variables are:

- <tt>$~</tt>: Returns a MatchData object, or +nil+.
- <tt>$&</tt>: Returns the matched string, or +nil+.
- <tt>$`</tt>: Returns the string to the left of the matched string, or +nil+.
- <tt>$</tt>: Returns the string to the right of the matched string, or +nil+.
- <tt>$+</tt>: Returns the last group matched, or +nil+.
- <tt>$1</tt>, <tt>$2</tt>, etc.: Returns the first, second, etc.,
  matched group, or +nil+.
  Note that <tt>$0</tt> is quite different;
  it returns the name of the currently executing program.

Examples:

  # Matched string, but no matched groups.
  'foo bar bar baz'.match('bar')
  $~ # => #<MatchData "bar">
  $& # => "bar"
  $` # => "foo "
  $' # => " bar baz"
  $+ # => nil
  $1 # => nil

  # Matched groups.
  /s(\w{2}).*(c)/.match('haystack')
  $~ # => #<MatchData "stac" 1:"ta" 2:"c">
  $& # => "stac"
  $` # => "hay"
  $' # => "k"
  $+ # => "c"
  $1 # => "ta"
  $2 # => "c"
  $3 # => nil

  # No match.
  'foo'.match('bar')
  $~ # => nil
  $& # => nil
  $` # => nil
  $' # => nil
  $+ # => nil
  $1 # => nil

Note that Regexp#match?, String#match?, Symbol#match?, and NilClass#=~
do not set global variables.

== Metacharacters and Escapes

A _metacharacter_ has a special meaning in certain contexts;
depending on the context, these are sometimes metacharacters:

  ( ) [ ] { } . ? - + * ^ \ |

To match a metacharacter literally, backslash-escape it:

  # Metacharacter period matches any character except newline.
  /./.match('foo')  # => #<MatchData "f">
  # Literal character period matches only period.
  /\./.match('.')   # => #<MatchData ".">
  /\./.match('foo') # => nil

To match a backslash literally, backslash-escape it:

  /\./.match('\.')  # => #<MatchData ".">
  /\\./.match('\.') # => #<MatchData "\\.">

The source string mostly behaves like a double-quoted string, and can contain:

- Interpolated strings:

    place = "東京都"
    /#{place}/.match('Go to 東京都') # => #<MatchData "東京都">

- Many backslash-escaped characters;
  however, certain backslash-letter combinations function as _metasequences_
  (see below):

    /\s\u{6771 4eac 90fd}/.match("Go to 東京都") # => #<MatchData " 東京都">

== Character Classes

A <i>character class</i> is delimited by square brackets;
it specifies that certain characters match at a given point in the target string:

  # This character class will match any vowel.
  re = /B[aeiou]rd/
  re.match('Bird') # => #<MatchData "Bird">
  re.match('Bard') # => #<MatchData "Bard">
  re.match('Byrd') # => nil

A character class may contain hyphen characters to specify ranges of characters:

  # These regexps have the same effect.
  /[abcdef]/.match('foo') # => #<MatchData "f">
  /[a-f]/.match('foo')    # => #<MatchData "f">
  /[a-cd-f]/.match('foo') # => #<MatchData "f">

When the first character of a character class is a caret (<tt>^</tt>),
the sense of the class is inverted: it matches any character _except_ those specified.

  /[^a-eg-z]/.match('f') # => #<MatchData "f">

A character class may contain another character class.
By itself this isn't useful because <tt>[a-z[0-9]]</tt>
describes the same set as <tt>[a-z0-9]</tt>.

However, character classes also support the <tt>&&</tt> operator,
which performs set intersection on its arguments.
The two can be combined as follows:

  /[a-w&&[^c-g]z]/ # ([a-w] AND ([^c-g] OR z))

This is equivalent to:

    /[abh-w]/

== Metasequences

The following metacharacter and metasequences also behave like character classes:

- <tt>/./</tt>: Matches any character except a newline:

    /./.match('foo') # => #<MatchData "f">
    /./.match("\n")  # => nil

- <tt>/./m</tt>: Matches any character, including a newline;
  see {Multiline Mode}[rdoc-ref:regexp.rdoc@Multiline+Mode}:

    /./m.match("\n") # => #<MatchData "\n">

- <tt>/\w/</tt>: Matches a word character: equivalent to <tt>[a-zA-Z0-9_]</tt>:

    /\w/.match(' foo') # => #<MatchData "f">
    /\w/.match(' _')   # => #<MatchData "_">
    /\w/.match(' ')    # => nil

- <tt>/\W/</tt>: Matches a non-word character: equivalent to <tt>[^a-zA-Z0-9_]</tt>:

    /\W/.match(' ') # => #<MatchData " ">
    /\W/.match('_') # => nil

- <tt>/\d/</tt>: Matches a digit character: equivalent to <tt>[0-9]</tt>:

    /\d/.match('THX1138') # => #<MatchData "1">
    /\d/.match('foo')     # => nil

- <tt>/\D/</tt>: Matches a non-digit character: equivalent to <tt>[^0-9]</tt>:

    /\D/.match('123Jump!') # => #<MatchData "J">
    /\D/.match('123')      # => nil

- <tt>/\h/</tt>: Matches a hexdigit character: equivalent to <tt>[0-9a-fA-F]</tt>:

    /\h/.match('xyz fedcba9876543210') # => #<MatchData "f">
    /\h/.match('xyz')                  # => nil

- <tt>/\H/</tt>: Matches a non-hexdigit character: equivalent to <tt>[^0-9a-fA-F]</tt>:

    /\H/.match('fedcba9876543210xyz') # => #<MatchData "x">
    /\H/.match('fedcba9876543210')    # => nil

- <tt>/\s/</tt>: Matches a whitespace character: equivalent to <tt>/[ \t\r\n\f\v]/</tt>:

    /\s/.match('foo bar') # => #<MatchData " ">
    /\s/.match('foo')     # => nil

- <tt>/\S/</tt>: Matches a non-whitespace character: equivalent to <tt>/[^ \t\r\n\f\v]/</tt>:

    /\S/.match(" \t\r\n\f\v foo") # => #<MatchData "f">
    /\S/.match(" \t\r\n\f\v")     # => nil

- <tt>/\R/</tt>: Matches a linebreak:

    /\R/.match("\r")     # => #<MatchData "\r">     # Carriage return (CR)
    /\R/.match("\n")     # => #<MatchData "\n">     # Newline (LF)
    /\R/.match("\f")     # => #<MatchData "\f">     # Formfeed (FF)
    /\R/.match("\v")     # => #<MatchData "\v">     # Vertical tab (VT)
    /\R/.match("\r\n")   # => #<MatchData "\r\n">   # CRLF
    /\R/.match("\u0085") # => #<MatchData "\u0085"> # Next line (NEL)
    /\R/.match("\u2028") # => #<MatchData "\u2028"> # Line separator (LSEP)
    /\R/.match("\u2029") # => #<MatchData "\u2029"> # Paragraph separator (PSEP)

== POSIX Bracket Expressions

A POSIX <i>bracket expression</i> is also similar to a character class.
These expressions provide a portable alternative to the above,
with the added benefit of encompassing non-ASCII characters:

- <tt>/\d/</tt> matches only ASCII decimal digits +0+ through +9+.
- <tt>/[[:digit:]]/</tt> matches any character in the Unicode
  <tt>Decimal Number</tt> (+Nd+) category;
  see below.

The POSIX bracket expressions:

- <tt>/[[:digit:]]/</tt>: Matches a {Unicode digit}[https://www.compart.com/en/unicode/category/Nd]:

    /[[:digit:]]/.match('9')       # => #<MatchData "9">
    /[[:digit:]]/.match("\u1fbf9") # => #<MatchData "9">

- <tt>/[[:xdigit:]]/</tt>: Matches a digit allowed in a hexadecimal number;
  equivalent to <tt>[0-9a-fA-F]</tt>.

- <tt>/[[:upper:]]/</tt>: Matches a {Unicode uppercase letter}[https://www.compart.com/en/unicode/category/Lu]:

    /[[:upper:]]/.match('A')      # => #<MatchData "A">
    /[[:upper:]]/.match("\u00c6") # => #<MatchData "Æ">

- <tt>/[[:lower:]]/</tt>: Matches a {Unicode lowercase letter}[https://www.compart.com/en/unicode/category/Ll]:

    /[[:lower:]]/.match('a')      # => #<MatchData "a">
    /[[:lower:]]/.match("\u01fd") # => #<MatchData "ǽ">

- <tt>/[[:alpha:]]/</tt>: Matches <tt>/[[:upper:]]/</tt> or <tt>/[[:lower:]]/</tt>.

- <tt>/[[:alnum:]]/</tt>: Matches <tt>/[[:alpha:]]/</tt> or <tt>/[[:digit:]]/</tt>.

- <tt>/[[:space:]]/</tt>: Matches {Unicode space character}[https://www.compart.com/en/unicode/category/Zs]:

    /[[:space:]]/.match(' ')      # => #<MatchData " ">
    /[[:space:]]/.match("\u2005") # => #<MatchData " ">

- <tt>/[[:blank:]]/</tt>: Matches <tt>/[[:space:]]/</tt> or tab character:

    /[[:blank:]]/.match(' ')      # => #<MatchData " ">
    /[[:blank:]]/.match("\u2005") # => #<MatchData " ">
    /[[:blank:]]/.match("\t")     # => #<MatchData "\t">

- <tt>/[[:cntrl:]]/</tt>: Matches {Unicode control character}[https://www.compart.com/en/unicode/category/Cc]:

    /[[:cntrl:]]/.match("\u0000") # => #<MatchData "\u0000">
    /[[:cntrl:]]/.match("\u009f") # => #<MatchData "\u009F">

- <tt>/[[:graph:]]/</tt>: Matches any character
  except <tt>/[[:space:]]/</tt> or <tt>/[[:cntrl:]]/</tt>.

- <tt>/[[:print:]]/</tt>: Matches <tt>/[[:graph:]]/</tt> or space character.

- <tt>/[[:punct:]]/</tt>: Matches any (Unicode punctuation character}[https://www.compart.com/en/unicode/category/Po]:

Ruby also supports these (non-POSIX) bracket expressions:

- <tt>/[[:ascii:]]/</tt>: Matches a character in the ASCII character set.
- <tt>/[[:word:]]/</tt>: Matches a character in one of these Unicode character
  categories (see below):

  - +Mark+ (+M+).
  - +Letter+ (+L+).
  - +Number+ (+N+)
  - <tt>Connector Punctuation</tt> (+Pc+).

== Unicode Properties

The <tt>/\p{_property_name_}/</tt> construct (with lowercase +p+)
matches characters using a property name,
much like a character class;
property +Alpha+ specifies alphabetic characters:

  /\p{Alpha}/.match('a') # => #<MatchData "a">
  /\p{Alpha}/.match('1') # => nil

A property can be inverted
by prefixing the name with a caret character (<tt>^</tt>):

  /\p{^Alpha}/.match('1') # => #<MatchData "1">
  /\p{^Alpha}/.match('a') # => nil

Or by using <tt>\P</tt> (uppercase +P+):

  /\P{Alpha}/.match('1') # => #<MatchData "1">
  /\P{Alpha}/.match('a') # => nil

See {Unicode Properties}[./Regexp/unicode_properties_rdoc.html]
for regexps based on the numerous properties.

Some commonly-used properties correspond to POSIX bracket expressions:

- <tt>/\p{Alnum}/</tt>: Alphabetic and numeric character
- <tt>/\p{Alpha}/</tt>: Alphabetic character
- <tt>/\p{Blank}/</tt>: Space or tab
- <tt>/\p{Cntrl}/</tt>: Control character
- <tt>/\p{Digit}/</tt>: Digit
  characters, and similar)
- <tt>/\p{Lower}/</tt>: Lowercase alphabetical character
- <tt>/\p{Print}/</tt>: Like <tt>\p{Graph}</tt>, but includes the space character
- <tt>/\p{Punct}/</tt>: Punctuation character
- <tt>/\p{Space}/</tt>: Whitespace character (<tt>[:blank:]</tt>, newline,
  carriage return, etc.)
- <tt>/\p{Upper}/</tt>: Uppercase alphabetical
- <tt>/\p{XDigit}/</tt>: Digit allowed in a hexadecimal number (i.e., 0-9a-fA-F)

These are also commonly used:

- <tt>/\p{Emoji}/</tt>: Unicode emoji.
- <tt>/\p{Graph}/</tt>: Non-blank character
  (excludes spaces, control characters, and similar).
- <tt>/\p{Word}/</tt>: A member of one of the following Unicode character
  categories (see below):

  - +Mark+ (+M+).
  - +Letter+ (+L+).
  - +Number+ (+N+)
  - <tt>Connector Punctuation</tt> (+Pc+).

- <tt>/\p{ASCII}/</tt>: A character in the ASCII character set.
- <tt>/\p{Any}/</tt>: Any Unicode character (including unassigned characters).
- <tt>/\p{Assigned}/</tt>: An assigned character.

=== Unicode Character Categories

A Unicode character category name:

- May be either its full name or its abbreviated name.
- Is case-insensitive.
- Treats a space, a hyphen, and an underscore as equivalent.

Examples:

  /\p{lu}/                # => /\p{lu}/
  /\p{LU}/                # => /\p{LU}/
  /\p{Uppercase Letter}/  # => /\p{Uppercase Letter}/
  /\p{Uppercase_Letter}/  # => /\p{Uppercase_Letter}/
  /\p{UPPERCASE-LETTER}/  # => /\p{UPPERCASE-LETTER}/

Below are the Unicode character category abbreviations and names.
Enumerations of characters in each category are at the links.

Letters:

- +L+, +Letter+: +LC+, +Lm+, or +Lo+.
- +LC+, +Cased_Letter+: +Ll+, +Lt+, or +Lu+.
- {Lu, Lowercase_Letter}[https://www.compart.com/en/unicode/category/Ll].
- {Lu, Modifier_Letter}[https://www.compart.com/en/unicode/category/Lm].
- {Lu, Other_Letter}[https://www.compart.com/en/unicode/category/Lo].
- {Lu, Titlecase_Letter}[https://www.compart.com/en/unicode/category/Lt].
- {Lu, Uppercase_Letter}[https://www.compart.com/en/unicode/category/Lu].

Marks:

- +M+, +Mark+: +Mc+, +Me+, or +Mn+.
- {Mc, Spacing_Mark}[https://www.compart.com/en/unicode/category/Mc].
- {Me, Enclosing_Mark}[https://www.compart.com/en/unicode/category/Me].
- {Mn, Nonapacing_Mark}[https://www.compart.com/en/unicode/category/Mn].

Numbers:

- +N+, +Number+: +Nd+, +Nl+, or +No+.
- {Nd, Decimal_Number}[https://www.compart.com/en/unicode/category/Nd].
- {Nl, Letter_Number}[https://www.compart.com/en/unicode/category/Nl].
- {No, Other_Number}[https://www.compart.com/en/unicode/category/No].

Punctation:

- +P+, +Punctuation+: +Pc+, +Pd+, +Pe+, +Pf+, +Pi+, +Po+, or +Ps+.
- {Pc, Connector_Punctuation}[https://www.compart.com/en/unicode/category/Pc].
- {Pd, Dash_Punctuation}[https://www.compart.com/en/unicode/category/Pd].
- {Pe, Close_Punctuation}[https://www.compart.com/en/unicode/category/Pe].
- {Pf, Final_Punctuation}[https://www.compart.com/en/unicode/category/Pf].
- {Pi, Initial_Punctuation}[https://www.compart.com/en/unicode/category/Pi].
- {Po, Open_Punctuation}[https://www.compart.com/en/unicode/category/Po].
- {Ps, Open_Punctuation}[https://www.compart.com/en/unicode/category/Ps].

- +S+, +Symbol+: +Sc+, +Sk+, +Sm+, or +So+.
- {Sc, Currency_Symbol}[https://www.compart.com/en/unicode/category/Sc].
- {Sk, Modifier_Symbol}[https://www.compart.com/en/unicode/category/Sk].
- {Sm, Math_Symbol}[https://www.compart.com/en/unicode/category/Sm].
- {So, Other_Symbol}[https://www.compart.com/en/unicode/category/So].

- +Z+, +Separator+: +Zl+, +Zp+, or +Zs+.
- {Zl, Line_Separator}[https://www.compart.com/en/unicode/category/Zl].
- {Zp, Paragraph_Separator}[https://www.compart.com/en/unicode/category/Zp].
- {Zs, Space_Separator}[https://www.compart.com/en/unicode/category/Zs].

- +C+, +Other+: +Cc+, +Cf+, +Cn+, +Co+, or +Cs+.
- {Cc, Control}[https://www.compart.com/en/unicode/category/Cc].
- {Cf, Format}[https://www.compart.com/en/unicode/category/Cf].
- {Cn, Unassigned}[https://www.compart.com/en/unicode/category/Cn].
- {Co, Private_Use}[https://www.compart.com/en/unicode/category/Co].
- {Cs, Surrogate}[https://www.compart.com/en/unicode/category/Cs].

=== Unicode Scripts and Blocks

Among the Unicode properties are:

- {Unicode scripts}[https://en.wikipedia.org/wiki/Script_(Unicode)];
  see {supported scripts}[https://www.unicode.org/standard/supported.html].
- {Unicode blocks}[https://en.wikipedia.org/wiki/Unicode_block];
  see {supported blocks}[http://www.unicode.org/Public/UNIDATA/Blocks.txt].

== Quantifiers

A simple regexp matches one character:

  /\w/.match('Hello')  # => #<MatchData "H">

An added _quantifier_ specifies how many matches are required or allowed:

- <tt>*</tt> - Matches zero or more times:

    /\w*/.match('')
    # => #<MatchData "">
    /\w*/.match('x')
    # => #<MatchData "x">
    /\w*/.match('xyz')
    # => #<MatchData "yz">

- <tt>+</tt> - Matches one or more times:

    /\w+/.match('')    # => nil
    /\w+/.match('x')   # => #<MatchData "x">
    /\w+/.match('xyz') # => #<MatchData "xyz">

- <tt>?</tt> - Matches zero or one times:

    /\w?/.match('')    # => #<MatchData "">
    /\w?/.match('x')   # => #<MatchData "x">
    /\w?/.match('xyz') # => #<MatchData "x">

- <tt>{</tt><i>n</i><tt>}</tt> - Matches exactly <i>n</i> times:

    /\w{2}/.match('')    # => nil
    /\w{2}/.match('x')   # => nil
    /\w{2}/.match('xyz') # => #<MatchData "xy">

- <tt>{</tt><i>min</i><tt>,}</tt> - Matches <i>min</i> or more times:

    /\w{2,}/.match('')    # => nil
    /\w{2,}/.match('x')   # => nil
    /\w{2,}/.match('xy')  # => #<MatchData "xy">
    /\w{2,}/.match('xyz') # => #<MatchData "xyz">

- <tt>{,</tt><i>max</i><tt>}</tt> - Matches <i>max</i> or fewer times:

    /\w{,2}/.match('')    # => #<MatchData "">
    /\w{,2}/.match('x')   # => #<MatchData "x">
    /\w{,2}/.match('xyz') # => #<MatchData "xy">

- <tt>{</tt><i>min</i><tt>,</tt><i>max</i><tt>}</tt> -
  Matches at least <i>min</i> times and at most <i>max</i> times:

    /\w{1,2}/.match('')    # => nil
    /\w{1,2}/.match('x')   # => #<MatchData "x">
    /\w{1,2}/.match('xyz') # => #<MatchData "xy">

=== Greedy, Lazy, or Possessive Matching

Quantifier matching may be greedy, lazy, or possessive:

- In _greedy_ matching, as many occurrences as possible are matched.
  while still allowing the overall match to succeed.
  Greedy quantifiers: <tt>*</tt>, <tt>+</tt>, <tt>?</tt>,
  <tt>{min, max}</tt> and its variants.
- In _lazy_ matching, the minimum number of occurrences are matched.
  Lazy quantifiers: <tt>*?</tt>, <tt>+?</tt>, <tt>??</tt>,
  <tt>{min, max}?</tt> and its variants.
- In _possessive_ matching, once a match is found, there is no backtracking;
  that match is retained, even if it jeopardises the overall match.
  Possessive quantifiers: <tt>*+</tt>, <tt>++</tt>, <tt>?+</tt>,
  <tt>{min, max}+</tt> and its variants.

More:

- About greedy and lazy matching, see
  {Choosing Minimal or Maximal Repetition}[https://doc.lagout.org/programmation/Regular%20Expressions/Regular%20Expressions%20Cookbook_%20Detailed%20Solutions%20in%20Eight%20Programming%20Languages%20%282nd%20ed.%29%20%5BGoyvaerts%20%26%20Levithan%202012-09-06%5D.pdf#tutorial-backtrack].
- About possessive matching, see
  {Eliminate Needless Backtracking}[https://doc.lagout.org/programmation/Regular%20Expressions/Regular%20Expressions%20Cookbook_%20Detailed%20Solutions%20in%20Eight%20Programming%20Languages%20%282nd%20ed.%29%20%5BGoyvaerts%20%26%20Levithan%202012-09-06%5D.pdf#tutorial-backtrack].

== Groups and Captures

A simple regexp has (at most) one match:

  re = /\d\d\d\d-\d\d-\d\d/
  re.match('1943-02-04')      # => #<MatchData "1943-02-04">
  re.match('1943-02-04').size # => 1
  re.match('foo')             # => nil

Adding one or more pairs of parentheses, <tt>(_subexpression_)</tt>,
defines <i>groups</i>, which may result in multiple matched substrings,
called _captures_:

  re = /(\d\d\d\d)-(\d\d)-(\d\d)/
  re.match('1943-02-04')      # => #<MatchData "1943-02-04" 1:"1943" 2:"02" 3:"04">
  re.match('1943-02-04').size # => 4

The first capture is the entire matched string;
the other captures are the matched substrings from the groups.

A group may have a
{quantifier}[rdoc-ref:regexp.rdoc@Quantifiers]:

  re = /July 4(th)?/
  re.match('July 4')   # => #<MatchData "July 4" 1:nil>
  re.match('July 4th') # => #<MatchData "July 4th" 1:"th">

  re = /(foo)*/
  re.match('')       # => #<MatchData "" 1:nil>
  re.match('foo')    # => #<MatchData "foo" 1:"foo">
  re.match('foofoo') # => #<MatchData "foofoo" 1:"foo">

  re = /(foo)+/
  re.match('')       # => nil
  re.match('foo')    # => #<MatchData "foo" 1:"foo">
  re.match('foofoo') # => #<MatchData "foofoo" 1:"foo">

The returned \MatchData object give access to matched the substrings:

  re = /(\d\d\d\d)-(\d\d)-(\d\d)/
  md = re.match('1943-02-04')
  # => #<MatchData "1943-02-04" 1:"1943" 2:"02" 3:"04">
  md[0] # => "1943-02-04"
  md[1] # => "1943"
  md[2] # => "02"
  md[3] # => "04"

=== Non-Capturing Groups

A group may be made non-capturing;
it is still a group (and, for example, can have a quantifier),
but its matching substring is not included among the captures.

A non-capturing group begins with <tt>?:</tt> (inside the parentheses):

  # Don't capture the year.
  re = /(?:\d\d\d\d)-(\d\d)-(\d\d)/
  md = re.match('1943-02-04') # => #<MatchData "1943-02-04" 1:"02" 2:"04">

=== Backreferences

A group match may also be referenced within the regexp itself;
such a reference is called a +backreference+:

  /[csh](..) [csh]\1 in/.match('The cat sat in the hat')
  # => #<MatchData "cat sat in" 1:"at">

This table shows how each subexpression in the regexp above
matches a substring in the target string:

  | Subexpression in Regexp   | Matching Substring in Target String |
  |---------------------------|-------------------------------------|
  |       First '[csh]'       |            Character 'c'            |
  |          '(..)'           |        First substring 'at'         |
  |      First space ' '      |      First space character ' '      |
  |       Second '[csh]'      |            Character 'c'            |
  | '\1' (backreference 'at') |        Second substring 'at'        |
  |           ' in'           |            Substring ' in'          |

A regexp may contain any number of groups:

- For a large number of groups:

  - The ordinary <tt>\\_n_</tt> notation applies only for _n_ in range (1..9).
  - The <tt>MatchData[_n_]</tt> notation applies for any non-negative _n_.

- <tt>\0</tt> is a special backreference, referring to the entire matched string;
  it may not be used within the regexp itself,
  but may be used outside it (for example, in a substitution method call):

    'The cat sat in the hat'.gsub(/[csh]at/, '\0s')
    # => "The cats sats in the hats"

=== Named Captures

As seen above, a capture can be referred to by its number.
A capture can also have a name,
prefixed as <tt>?<_name_></tt> or <tt>?'_name_'></tt>,
and the name (symbolized) may be used as an index in <tt>MatchData[]</tt>:

  md = /\$(?<dollars>\d+)\.(?'cents'\d+)/.match("$3.67")
  # => #<MatchData "$3.67" dollars:"3" cents:"67">
  md[:dollars]  # => "3"
  md[:cents]    # => "67"
  # The capture numbers are still valid.
  md[2]         # => "67"

When a regexp contains a named capture, there are no unnamed captures:

  /\$(?<dollars>\d+)\.(\d+)/.match("$3.67")
  # => #<MatchData "$3.67" dollars:"3">

A named group may be backreferenced as <tt>\k<_name_></tt>:

  /(?<vowel>[aeiou]).\k<vowel>.\k<vowel>/.match('ototomy')
  # => #<MatchData "ototo" vowel:"o">

When (and only when) a regexp contains named capture groups
and appears before the <tt>=~</tt> operator,
the captured substrings are assigned to local variables with corresponding names:

  /\$(?<dollars>\d+)\.(?<cents>\d+)/ =~ "$3.67" # => 0
  dollars # => "3"

=== Atomic Grouping

A group may be made <i>atomic</i> with <tt>(?></tt><i>subexpression</i><tt>)</tt>.

This causes the subexpression to be matched
independently of the rest of the expression,
so that the matched substring becomes fixed for the remainder of the match,
unless the entire subexpression must be abandoned and subsequently revisited.

In this way pat is treated as a non-divisible whole.
Atomic grouping is typically used to optimise patterns
to prevent needless backtracking .

Example (without atomic grouping):

  /".*"/.match('"Quote"') # => #<MatchData "\"Quote\"">

Analysis:

1. The leading subexpression <tt>"</tt> in the pattern matches the first character
   <tt>"</tt> in the target string.
2. The next subexpression <tt>.*</tt> matches the next substring <tt>Quote“</tt>
   (including the trailing double-quote).
3. Now there is nothing left in the target string to match
   the trailing subexpression <tt>"</tt> in the pattern;
   this would cause the overall match to fail.
4. The matched substring is backtracked by one position: <tt>Quote</tt>.
5. The final subexpression <tt>"</tt> now matches the final substring <tt>"</tt>,
   and the overall match succeeds.

If subexpression <tt>.*</tt> is grouped atomically,
the backtracking is disabled, and the overall match fails:

  /"(?>.*)"/.match('"Quote"') # => nil

Atomic grouping can affect performance;
see {Atomic Group}[https://www.regular-expressions.info/atomic.html].

=== Subexpression Calls

As seen above, a backreference number (<tt>\\_n_</tt>) or name (<tt>\k<_name_></tt>)
gives access to a captured _substring_;
the corresponding regexp _subexpression_ may also be accessed,
via the number (<tt>\\g<i>n</i></tt>) or name (<tt>\g<_name_></tt>):

This pattern matches a <i>(</i> character and assigns it to the <tt>paren</tt>
group, tries to call that the <tt>paren</tt> sub-expression again but fails,
then matches a literal <i>)</i>:

    /\A(?<paren>\(\g<paren>*\))*\z/ =~ '()'
    /\A(?<paren>\(\g<paren>*\))*\z/ =~ '(())' # => 0
    # ^1
    #      ^2
    #           ^3
    #                 ^4
    #      ^5
    #           ^6
    #                      ^7
    #                       ^8
    #                       ^9
    #                           ^10

1.  Matches at the beginning of the string, i.e. before the first
    character.
2.  Enters a named capture group called <tt>paren</tt>
3.  Matches a literal <i>(</i>, the first character in the string
4.  Calls the <tt>paren</tt> group again, i.e. recurses back to the
    second step
5.  Re-enters the <tt>paren</tt> group
6.  Matches a literal <i>(</i>, the second character in the
    string
7.  Try to call <tt>paren</tt> a third time, but fail because
    doing so would prevent an overall successful match
8.  Match a literal <i>)</i>, the third character in the string.
    Marks the end of the second recursive call
9.  Match a literal <i>)</i>, the fourth character in the string
10. Match the end of the string

See {Subexpression calls}[https://learnbyexample.github.io/Ruby_Regexp/groupings-and-backreferences.html?highlight=subexpression#subexpression-calls].

=== Conditionals

The <tt>(?(</tt><i>cond</i><tt>)</tt><i>yes</i><tt>|</tt><i>no</i><tt>)</tt>
syntax matches _yes_ part if _cond_ is captured, otherwise matches _no_ part.
In the case _no_ part is empty, also <tt>|</tt> can be omitted.

The _cond_ may be a backreference number or a captured name.  A backreference
number is an absolute position, but can not be a relative position.

  re = /\A(foo)?(?(1)(T)|(F))\z/
  re.match('fooT') # => #<MatchData "fooT" 1:"foo" 2:"T" 3:nil>
  re.match('F')    # => #<MatchData "F" 1:nil 2:nil 3:"F">
  re.match('fooF') # => nil
  re.match('T')    # => nil

  re = /\A(?<xyzzy>foo)?(?(<xyzzy>)(T)|(F))\z/
  re.match('fooT') # => #<MatchData "fooT" xyzzy:"foo">
  re.match('F')    # => #<MatchData "F" xyzzy:nil>
  re.match('fooF') # => nil
  re.match('T')    # => nil

== Alternatives

The vertical bar metacharacter (<tt>|</tt>) may be used within parentheses
to express alternatives:
two or more subexpressions any of which may match the target string.

Two alternatives:

  re = /(a|b)/
  re.match('foo') # => nil
  re.match('bar') # => #<MatchData "b" 1:"b">

Four alternatives:

  re = /(a|b|c|d)/
  re.match('shazam') # => #<MatchData "a" 1:"a">
  re.match('cold')   # => #<MatchData "c" 1:"c">

Each alternative is a subexpression, and may be complex:

  re = /([a-c]|[x-z])/
  re.match('bar') # => #<MatchData "b" 1:"b">
  re.match('ooz') # => #<MatchData "z" 1:"z">

== Anchors

An anchor is a metasequence that matches a zero-width position between
characters in the target string.

For a subexpression with no anchor,
matching may begin anywhere in the target string:

  /real/.match('surrealist') # => #<MatchData "real">

For a subexpression with an anchor,
matching must begin at the matched anchor:

  /\Areal/.match('surrealist') # => nil

The match below fails because although <tt>'Demand'</tt> contains </tt>'and'</tt>,
the substring does not occur at a word boundary.

  /\band/.match('Demand')

In this example <tt>'and'</tt> has been anchored to a non-word
boundary so instead of matching the first <tt>'and'</tt>,
it matches from the fourth letter of <tt>'demand'</tt> instead:

  /\Band.+/.match("Supply and demand curve") # => #<MatchData "and curve">

=== Boundary Anchors

Each of these anchors matches a boundary:

- <tt>^</tt>: Matches the beginning of a line:

    /^bar/.match("foo\nbar") # => #<MatchData "bar">

- <tt>$</tt>: Matches the end of a line:

    /bar$/.match("foo\nbar") # => #<MatchData "bar">

- <tt>\A</tt>: Matches beginning of string.
- <tt>\Z</tt>: Matches end of string;
  if string ends with a newline,  it matches just before newline.
- <tt>\z</tt>: Matches end of string.
- <tt>\G</tt>: Matches first matching position:

  In methods like <tt>String#gsub</tt> and <tt>String#scan</tt>, it changes on each iteration.
  It initially matches the beginning of subject, and in each following iteration it matches where the last match finished.

    "    a b c".gsub(/ /, '_')    # => "____a_b_c"
    "    a b c".gsub(/\G /, '_')  # => "____a b c"

  In methods like <tt>Regexp#match</tt> and <tt>String#match</tt>
  that take an (optional) offset, it matches where the search begins.

    "hello, world".match(/,/, 3)    # => #<MatchData ",">
    "hello, world".match(/\G,/, 3)  # => nil

- <tt>\b</tt>: Matches word boundary when outside brackets;
  backspace (0x08) when inside brackets.
- <tt>\B</tt>: Matches non-word boundary.

=== Lookahead and Lookbehind Anchors

- <tt>(?=_pat_)</tt>: Positive lookahead assertion:
  ensures that the following characters match _pat_,
  but doesn't include those characters in the matched text.
- <tt>(?!_pat_)</tt>: Negative lookahead assertion:
  ensures that the following characters <i>do not</i> match _pat_,
  but doesn't include those characters in the matched text.
- <tt>(?<=_pat_)</tt>: Positive lookbehind assertion:
  ensures that the preceding characters match _pat_, but
  doesn't include those characters in the matched text
- <tt>(?<!_pat_)</tt>: Negative lookbehind assertion:
  ensures that the preceding characters do not match
  _pat_, but doesn't include those characters in the matched text.

=== Match Reset Anchor

- <tt>\K</tt>: Match reset:
  the matched content preceding <tt>\K</tt> in the regexp is excluded from the result.
  For example, the following two regexps are almost equivalent:

    /ab\Kc/ =~ "abc"     # => 0
    /(?<=ab)c/ =~ "abc"  # => 2

  These match same string and <tt>$&</tt> equals <tt>'c'</tt>, while the
  matched position is different.

  As are the following two regexps:

    /(a)\K(b)\Kc/
    /(?<=(?<=(a))(b))c/

The pattern below uses positive lookahead and positive lookbehind to match
text appearing in <tt><b></tt>...<tt></b></tt> tags
without including the tags in the match:

  /(?<=<b>)\w+(?=<\/b>)/.match("Fortune favors the <b>bold</b>.")
  # => #<MatchData "bold">

== Options

The end delimiter for a regexp can be followed by one or more single-letter
options which control how the pattern can match.

- <tt>/pat/i</tt>: Ignore case
- <tt>/pat/m</tt>: Treat a newline as a character matched by <tt>.</tt>
- <tt>/pat/x</tt>: Ignore whitespace and comments in the pattern
- <tt>/pat/o</tt>: Perform <tt>#{}</tt> interpolation only once

<tt>i</tt>, <tt>m</tt>, and <tt>x</tt> can also be applied on the
subexpression level with the
<tt>(?</tt><i>on</i><tt>-</tt><i>off</i><tt>)</tt> construct, which
enables options <i>on</i>, and disables options <i>off</i> for the
expression enclosed by the parentheses:

    /a(?i:b)c/.match('aBc')   # => #<MatchData "aBc">
    /a(?-i:b)c/i.match('ABC') # => nil

Additionally, these options can also be toggled for the remainder of the
pattern:

    /a(?i)bc/.match('abC') # => #<MatchData "abC">

Options may also be used with <tt>Regexp.new</tt>:

    Regexp.new("abc", Regexp::IGNORECASE)                     # => /abc/i
    Regexp.new("abc", Regexp::MULTILINE)                      # => /abc/m
    Regexp.new("abc # Comment", Regexp::EXTENDED)             # => /abc # Comment/x
    Regexp.new("abc", Regexp::IGNORECASE | Regexp::MULTILINE) # => /abc/mi

    Regexp.new("abc", "i")           # => /abc/i
    Regexp.new("abc", "m")           # => /abc/m
    Regexp.new("abc # Comment", "x") # => /abc # Comment/x
    Regexp.new("abc", "im")          # => /abc/mi

== Free-Spacing Mode and Comments

As mentioned above, the <tt>x</tt> option enables <i>free-spacing</i>
mode. Literal white space inside the pattern is ignored, and the
octothorpe (<tt>#</tt>) character introduces a comment until the end of
the line. This allows the components of the pattern to be organized in a
potentially more readable fashion.

A contrived pattern to match a number with optional decimal places:

    float_pat = /\A
        [[:digit:]]+ # 1 or more digits before the decimal point
        (\.          # Decimal point
            [[:digit:]]+ # 1 or more digits after the decimal point
        )? # The decimal point and following digits are optional
    \Z/x
    float_pat.match('3.14') # => #<MatchData "3.14" 1:".14">

There are a number of strategies for matching whitespace:

* Use a pattern such as <tt>\s</tt> or <tt>\p{Space}</tt>.
* Use escaped whitespace such as <tt>\ </tt>, i.e. a space preceded by a backslash.
* Use a character class such as <tt>[ ]</tt>.

Comments can be included in a non-<tt>x</tt> pattern with the
<tt>(?#</tt><i>comment</i><tt>)</tt> construct, where <i>comment</i> is
arbitrary text ignored by the regexp engine.

Comments in regexp literals cannot include unescaped terminator
characters.

== Encoding

Regular expressions are assumed to use the source encoding. This can be
overridden with one of the following modifiers.

- <tt>/_pat_/u</tt>: UTF-8
- <tt>/_pat_/e</tt>: EUC-JP
- <tt>/_pat_/s</tt>: Windows-31J
- <tt>/_pat_/n</tt>: ASCII-8BIT

A regexp can be matched against a string when they either share an
encoding, or the regexp's encoding is _US-ASCII_ and the string's encoding
is ASCII-compatible.

If a match between incompatible encodings is attempted an
<tt>Encoding::CompatibilityError</tt> exception is raised.

The <tt>Regexp#fixed_encoding?</tt> predicate indicates whether the regexp
has a <i>fixed</i> encoding, that is one incompatible with ASCII. A
regexp's encoding can be explicitly fixed by supplying
<tt>Regexp::FIXEDENCODING</tt> as the second argument of
<tt>Regexp.new</tt>:

    re = Regexp.new("a".force_encoding("iso-8859-1"),Regexp::FIXEDENCODING)
    re =~ "a\u3042"
       # raises Encoding::CompatibilityError: incompatible encoding regexp match
       #         (ISO-8859-1 regexp with UTF-8 string)

== Performance

Certain pathological combinations of constructs can lead to abysmally bad
performance.

Consider a string of 25 <i>a</i>s, a <i>d</i>, 4 <i>a</i>s, and a
<i>c</i>.

   s = 'a' * 25 + 'd' + 'a' * 4 + 'c'
   # => "aaaaaaaaaaaaaaaaaaaaaaaaadaaaac"

The following patterns match quickly, as one would expect:

   (start = Time.now) && /(b|a)/ =~ s && (Time.now - start)    # => 2.0e-06
   (start = Time.now) && /(b|a+)/ =~ s && (Time.now - start)   # => 2.2e-06
   (start = Time.now) && /(b|a+)*/ =~ s && (Time.now - start)  # => 2.3e-06

However, the following pattern takes appreciably longer:

   (start = Time.now) && /(b|a+)*c/ =~ s && (Time.now - start) # => 5.9e-06

This happens because an atom in the regexp is quantified by both an
immediate <tt>+</tt> and an enclosing <tt>*</tt> with nothing to
differentiate which is in control of any particular character.

The nondeterminism that results produces non-linear performance.
For an in-depth analysis, see
{"Crafting an Efficient Expression"}[https://ia902508.us.archive.org/10/items/allitebooks-02/Mastering%20Regular%20Expressions%2C%203rd%20Edition.pdf#page=245]
in <i>Mastering Regular Expressions</i> (3rd ed.) by Jeffrey Friedl.

This particular case
can be fixed by use of atomic grouping, which prevents the unnecessary
backtracking:

   (start = Time.now) && /(b|a+)*c/ =~ s && (Time.now - start)   # => 5.8e-06
   (start = Time.now) && /(?>b|a+)*c/ =~ s && (Time.now - start) # => 1.01e-05

== Timeout

There are two APIs to set timeout. One is Regexp.timeout=, which is
process-global configuration of timeout for Regexp matching.

    Regexp.timeout = 3
    s = 'a' * 25 + 'd' + 'a' * 4 + 'c'
    /(b|a+)*c/ =~ s  # => This raises an exception in three seconds

The other is timeout keyword of Regexp.new.

    re = Regexp.new("(b|a+)*c", timeout: 3)
    s = 'a' * 25 + 'd' + 'a' * 4 + 'c'
    /(b|a+)*c/ =~ s  # => This raises an exception in three seconds

When using Regexps to process untrusted input, you should use the timeout
feature to avoid excessive backtracking. Otherwise, a malicious user can
provide input to Regexp causing Denial-of-Service attack.
Note that the timeout is not set by default because an appropriate limit
highly depends on an application requirement and context.

== References

Read (online PDF books):

- {Mastering Regular Expressions}[https://ia902508.us.archive.org/10/items/allitebooks-02/Mastering%20Regular%20Expressions%2C%203rd%20Edition.pdf]
  by Jeffrey E.F. Friedl.
- {Regular Expressions Cookbook}[https://doc.lagout.org/programmation/Regular%20Expressions/Regular%20Expressions%20Cookbook_%20Detailed%20Solutions%20in%20Eight%20Programming%20Languages%20%282nd%20ed.%29%20%5BGoyvaerts%20%26%20Levithan%202012-09-06%5D.pdf]
  by Jan Goyvaerts & Steven Levithan.

Edit, test (interactive online editor):

- {Rubular}[https://rubular.com/].
