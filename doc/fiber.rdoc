= Fiber

Fiber is a flow-control primitive which enable cooperative scheduling. This is
in contrast to threads which can be preemptively scheduled at any time. While
having a similar memory profiles, the cost of context switching fibers can be
significantly less than threads as it does not involve a system call.

== Design

=== Thread Scheduler

The per-thread fiber scheduler interface is used to intercept blocking
operations. A typical implementation would be a wrapper for a gem like
EventMachine or Async. This design provides separation of concerns between the
event loop implementation and application code. It also allows for layered
schedulers which can perform instrumentation.

  class Scheduler
    # Wait for the given file descriptor to become readable.
    def wait_readable(fd)
    end

    # Wait for the given file descriptor to become writable.
    def wait_writable(fd)
    end

    # Wait for the given file descriptor to match the specified events within
    # the specified timeout.
    # @param event [Integer] a bit mask of +IO::WAIT_READABLE+,
    #   `IO::WAIT_WRITABLE` and `IO::WAIT_PRIORITY`.
    # @param timeout [#to_f] the amount of time to wait for the event.
    def wait_for_single_fd(fd, events, timeout)
    end

    # Sleep the current task for the specified duration, or forever if not
    # specified.
    # @param duration [#to_f] the amount of time to sleep.
    def wait_sleep(duration = nil)
    end

    # The Ruby virtual machine is going to enter a system level blocking
    # operation.
    def enter_blocking_region
    end

    # The Ruby virtual machine has completed the system level blocking
    # operation.
    def exit_blocking_region
    end

    # Intercept the creation of a non-blocking fiber.
    def fiber(&block)
      Fiber.new(blocking: false, &block)
    end

    # Invoked when the thread exits.
    def run
      # Implement event loop here.
    end
  end

=== Non-blocking Fibers

By default fibers are blocking. Non-blocking fibers may invoke specific
scheduler hooks when a blocking operation occurs, and these hooks may introduce
context switching points.

  Fiber.new(blocking: false) do
    puts Fiber.current.blocking? # false

    # May invoke `Thread.scheduler&.wait_readable`.
    io.read(...)

    # May invoke `Thread.scheduler&.wait_writable`.
    io.write(...)

    # Will invoke `Thread.scheduler&.wait_sleep`.
    sleep(n)
  end.resume

We also introduce a new method which simplifes the creation of these
non-blocking fibers:

  Fiber do
    puts Fiber.current.blocking? # false
  end

The purpose of this method is to allow the scheduler to internally decide the
policy for when to start the fiber, and whether to use symmetric or asymmetric
fibers.

=== Non-blocking Threads

By default, threads are blocking. When switching to a non-blocking fiber, we
track this state using a counter, and the thread may become non-blocking. When a
non-blocking thread invokes a blocking operation, it may defer the operation to
the thread scheduler.

  puts Thread.current.blocking? # 1 (true)

  Fiber.new(blocking: false) do
    puts Thread.current.blocking? # false
  end.resume

=== Mutex

In addition, locking a mutex causes the thread to become blocking. On
+Mutex#lock+, +Fiber+ switching via the scheduler is disabled and operations
become blocking for all fibers of the same +Thread+. On +Mutex#unlock+, the
scheduler is enabled again. A count is kept, so only once all held Mutex are
unlocked the scheduler is enabled again.

  mutex = Mutex.new

  puts Thread.current.blocking? # 1 (true)

  Fiber.new(blocking: false) do
    puts Thread.current.blocking? # false
    mutex.synchronize do
      puts Thread.current.blocking? # (1) true
    end

    puts Thread.current.blocking? # false
  end.resume

=== Non-blocking I/O

By default, I/O is non-blocking. Not all operating systems support non-blocking
I/O. Windows is a notable example where socket I/O can be non-blocking but pipe
I/O is blocking. Provided that there *is* a scheduler and the current thread *is
non-blocking*, the operation will invoke the scheduler.
