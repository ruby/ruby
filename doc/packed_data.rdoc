== Packed Data

Certain Ruby core methods deal with packing and unpacking data:

- \Method Array#pack:
  Formats each element in array +self+ into a binary string;
  returns that string.
- \Method String#unpack:
  Extracts data from string +self+,
  forming objects that become the elements of a new array;
  returns that array.
- \Method String#unpack1:
  Does the same, but the returned array
  contains only the first extracted object.

Each of these methods accepts a string +template+,
consisting of zero or more _directive_ characters,
each followed by zero or more _modifier_ characters.

Examples (directive <tt>'C'</tt> specifies 'unsigned character'):

  [65].pack('C')      # => "A"  # One element, one directive.
  [65, 66].pack('CC') # => "AB" # Two elements, two directives.
  [65, 66].pack('C')  # => "A"  # Extra element is ignored.
  [65].pack('')       # => ""   # No directives.
  [65].pack('CC')               # Extra directive raises ArgumentError.

  'A'.unpack('C')   # => [65]      # One character, one directive.
  'AB'.unpack('CC') # => [65, 66]  # Two characters, two directives.
  'AB'.unpack('C')  # => [65]      # Extra character is ignored.
  'A'.unpack('CC')  # => [65, nil] # Extra directive generates nil.
  'AB'.unpack('')   # => []        # No directives.

Directives may be mixed as desired
(directive <tt>'c'</tt> specifies 'signed character'):

  [65, -1].pack('cC')  # => "A\xFF"
  "A\xFF".unpack('cC') # => [65, 255]

Any directive may be followed by either of these modifiers:

- <tt>'*'</tt> - The directive is to be applied as many times as needed:

    [65, 66].pack('C*') # => "AB"
    'AB'.unpack('C*')   # => [65, 66]

- Integer +count+ - The directive is to be applied +count+ times:

    [65, 66].pack('C2') # => "AB"
    [65, 66].pack('C3') # Raises ArgumentError.
    'AB'.unpack('C2')   # => [65, 66]
    'AB'.unpack('C3')   # => [65, 66, nil]

  Note: Directives in <tt>%w[A a Z m]</tt> use +count+ differently;
  see {String Directives}[rdoc-ref:packed_data.md@String+Directives].

\Method Array#pack accepts optional keyword argument
+buffer+ that specifies the target string (instead of a new string):

  [65, 66].pack('C*', buffer: 'foo') # => "fooAB"

Methods String#unpack and String#unpack1 each accept
an optional keyword argument +offset+ that specifies an offset
into the string:

  'ABC'.unpack('C*', offset: 1)  # => [66, 67]
  'ABC'.unpack1('C*', offset: 1) # => 66

Any of the three methods may have a block:

  [65, 66].pack('C*') {|s| p s }    # => "AB"

  a = []
  'AB'.unpack('C*') {|e le| a << ele }
  a                                 # => [65, 66]

  'AB'.unpack1('C*') {|ele| p ele } # => 65

=== \Integer Directives

Each integer directive specifies the packing or unpacking
for one element in the input or output array.

==== 8-Bit \Integer Directives

- <tt>'c'</tt> - 8-bit signed integer
  (like C <tt>signed char</tt>):

    [0, 1, 255].pack('c*')  # => "\x00\x01\xFF"
    [0, 1, -1].pack('c*')   # => "\x00\x01\xFF"
    "\0\1\xFF".unpack('c*') # => [0, 1, -1]

- <tt>'C'</tt> - 8-bit signed integer
  (like C <tt>unsigned char</tt>):

    [0, 1, 255].pack('C*')    # => "\x00\x01\xFF"
    s = [0, 1, -1].pack('C*') # => "\x00\x01\xFF"
    s.unpack('C*')            # => [0, 1, 255]

==== 16-Bit \Integer Directives

- <tt>'s'</tt> - 16-bit signed integer, native-endian
  (like C <tt>int16_t</tt>):

    [513, -514].pack('s*')      # => "\x01\x02\xFE\xFD"
    s = [513, 65022].pack('s*') # => "\x01\x02\xFE\xFD"
    s.unpack('s*')              # => [513, -514]

- <tt>'S'</tt> - 16-bit unsigned integer, native-endian
  (like C <tt>uint16_t</tt>):

    [513, -514].pack('S*')      # => "\x01\x02\xFE\xFD"
    s = [513, 65022].pack('S*') # => "\x01\x02\xFE\xFD"
    s.unpack('S*')              # => [513, 65022]

- <tt>'n'</tt> - 16-bit network integer, big-endian:

    s = [0, 1, -1, 32767, -32768, 65535].pack('n*')
    # => "\x00\x00\x00\x01\xFF\xFF\x7F\xFF\x80\x00\xFF\xFF"
    s.unpack('n*')
    # => [0, 1, 65535, 32767, 32768, 65535]

- <tt>'v'</tt> - 16-bit VAX integer, little-endian:

    s = [0, 1, -1, 32767, -32768, 65535].pack('v*')
    # => "\x00\x00\x01\x00\xFF\xFF\xFF\x7F\x00\x80\xFF\xFF"
    s.unpack('v*')
    # => [0, 1, 65535, 32767, 32768, 65535]

==== 32-Bit \Integer Directives

- <tt>'l'</tt> - 32-bit signed integer, native-endian
  (like C <tt>int32_t</tt>):

    s = [67305985, -50462977].pack('l*')
    # => "\x01\x02\x03\x04\xFF\xFE\xFD\xFC"
    s.unpack('l*')
    # => [67305985, -50462977]

- <tt>'L'</tt> - 32-bit unsigned integer, native-endian
  (like C <tt>uint32_t</tt>):

    s = [67305985, 4244504319].pack('L*')
    # => "\x01\x02\x03\x04\xFF\xFE\xFD\xFC"
    s.unpack('L*')
    # => [67305985, 4244504319]

- <tt>'N'</tt> - 32-bit network integer, big-endian:

    s = [0,1,-1].pack('N*')
    # => "\x00\x00\x00\x00\x00\x00\x00\x01\xFF\xFF\xFF\xFF"
    s.unpack('N*')
    # => [0, 1, 4294967295]

- <tt>'V'</tt> - 32-bit VAX integer, little-endian:

    s = [0,1,-1].pack('V*')
    # => "\x00\x00\x00\x00\x01\x00\x00\x00\xFF\xFF\xFF\xFF"
    s.unpack('v*')
    # => [0, 0, 1, 0, 65535, 65535]

==== 64-Bit \Integer Directives

- <tt>'q'</tt> - 64-bit signed integer, native-endian
  (like C <tt>int64_t</tt>):

    s = [578437695752307201, -506097522914230529].pack('q*')
    # => "\x01\x02\x03\x04\x05\x06\a\b\xFF\xFE\xFD\xFC\xFB\xFA\xF9\xF8"
    s.unpack('q*')
    # => [578437695752307201, -506097522914230529]

- <tt>'Q'</tt> - 64-bit unsigned integer, native-endian
  (like C <tt>uint64_t</tt>):

    s = [578437695752307201, 17940646550795321087].pack('Q*')
    # => "\x01\x02\x03\x04\x05\x06\a\b\xFF\xFE\xFD\xFC\xFB\xFA\xF9\xF8"
    s.unpack('Q*')
    # => [578437695752307201, 17940646550795321087]

==== Platform-Dependent \Integer Directives

- <tt>'i'</tt> - Platform-dependent width signed integer,
  native-endian:

    s = [67305985, -50462977].pack('i*')
    # => "\x01\x02\x03\x04\xFF\xFE\xFD\xFC"
    s.unpack('i*')
    # => [67305985, -50462977]

- <tt>'I'</tt> - Platform-dependent width unsigned integer,
  native-endian:

    s = [67305985, -50462977].pack('I*')
    # => "\x01\x02\x03\x04\xFF\xFE\xFD\xFC"
    s.unpack('I*')
    # => [67305985, 4244504319]

==== Pointer Directives

- <tt>'j'</tt> - 64-bit pointer-width signed integer,
  native-endian (like C <tt>intptr_t</tt>):

    s = [67305985, -50462977].pack('j*')
    # => "\x01\x02\x03\x04\x00\x00\x00\x00\xFF\xFE\xFD\xFC\xFF\xFF\xFF\xFF"
    s.unpack('j*')
    # => [67305985, -50462977]

- <tt>'j'</tt> - 64-bit pointer-width unsigned integer,
  native-endian (like C <tt>uintptr_t</tt>):

    s = [67305985, 4244504319].pack('J*')
    # => "\x01\x02\x03\x04\x00\x00\x00\x00\xFF\xFE\xFD\xFC\x00\x00\x00\x00"
    s.unpack('J*')
    # => [67305985, 4244504319]

==== Other \Integer Directives
:
- <tt>'U'</tt> - UTF-8 character:

    s = [4194304].pack('U*')
    # => "\xF8\x90\x80\x80\x80"
    s.unpack('U*')
    # => [4194304]

- <tt>'w'</tt> - BER-encoded integer
  (see {BER enocding}[https://en.wikipedia.org/wiki/X.690#BER_encoding]):

    s = [1073741823].pack('w*')
    # => "\x83\xFF\xFF\xFF\x7F"
    s.unpack('w*')
    # => [1073741823]

==== Modifiers for \Integer Directives

For directives in <tt>%w[ i I s S l L q Q j J]</tt>,
these modifiers may be suffixed:

- <tt>'!'</tt> or <tt>'_'</tt> - Underlying platform’s native size.
- <tt>'>'</tt> - Big-endian.
- <tt>'<'</tt> - Little-endian.

=== \Float Directives

Each float directive specifies the packing or unpacking
for one element in the input or output array.

==== Single-Precision \Float Directives

- <tt>'F'</tt> or <tt>'f'</tt> - Native format:

    s = [3.0].pack('F') # => "\x00\x00@@"
    s.unpack('F')       # => [3.0]

- <tt>'e'</tt> - Little-endian:

    s = [3.0].pack('e') # => "\x00\x00@@"
    s.unpack('e')       # => [3.0]

- <tt>'g'</tt> - Big-endian:

    s = [3.0].pack('g') # => "@@\x00\x00"
    s.unpack('g')       # => [3.0]

==== Double-Precision \Float Directives

- <tt>'D'</tt> or <tt>'d'</tt> - Native format:

    s = [3.0].pack('D') # => "\x00\x00\x00\x00\x00\x00\b@"
    s.unpack('D')       # => [3.0]

- <tt>'E'</tt> - Little-endian:

    s = [3.0].pack('E') # => "\x00\x00\x00\x00\x00\x00\b@"
    s.unpack('E')       # => [3.0]

- <tt>'G'</tt> - Big-endian:

    s = [3.0].pack('G') # => "@\b\x00\x00\x00\x00\x00\x00"
    s.unpack('G')       # => [3.0]

=== \String Directives

Each string directive specifies the packing or unpacking
for one byte in the input or output string.

==== Binary \String Directives

- <tt>'A'</tt> - Arbitrary binary string (space padded; count is width):

    ['foo'].pack('A')    # => "f"
    ['foo'].pack('A*')   # => "foo"
    ['foo'].pack('A2')   # => "fo"
    ['foo'].pack('A4')   # => "foo "
    [nil].pack('A')      # => " "
    [nil].pack('A*')     # => ""
    [nil].pack('A2')     # => "  "
    [nil].pack('A4')     # => "    "

    "foo\0".unpack('A')  # => ["f"]
    "foo\0".unpack('A4') # => ["foo"]
    "foo ".unpack('A')   # => ["f"]
    "foo ".unpack('A4')  # => ["foo"]
    "foo".unpack('A4')   # => ["foo"]

    russian = "\u{442 435 441 442}" # => "тест"
    russian.unpack('A')             # => ["\xD1"]
    russian.unpack('A2')            # => ["\xD1\x82"]
    russian.unpack('A4')            # => ["\xD1\x82\xD0\xB5"]
    russian.unpack('A*')            # => ["\xD1\x82\xD0\xB5\xD1\x81\xD1\x82"]

- <tt>'a'</tt> - Arbitrary binary string (null padded; count is width):

    ["foo"].pack('a')    # => "f"
    ["foo"].pack('a*')   # => "foo"
    ["foo"].pack('a2')   # => "fo"
    ["foo\0"].pack('a4') # => "foo\x00"
    [nil].pack('a')      # => "\x00"
    [nil].pack('a*')     # => ""
    [nil].pack('a2')     # => "\x00\x00"
    [nil].pack('a4')     # => "\x00\x00\x00\x00"

    "foo\0".unpack('a')  # => ["f"]
    "foo\0".unpack('a4') # => ["foo\x00"]
    "foo ".unpack('a4')  # => ["foo "]
    "foo".unpack('a4')   # => ["foo"]

- <tt>'Z'</tt> - Same as <tt>'a'</tt>,
  except that null is added or ignored with <tt>'*'</tt>:

    ["foo"].pack('Z*')   # => "foo\x00"
    [nil].pack('Z*')     # => "\x00"

    "foo\0".unpack('Z*') # => ["foo"]
    "foo".unpack('Z*')   # => ["foo"]

==== Bit \String Directives

- <tt>'B'</tt> - Bit string (high byte first):

- <tt>'b'</tt> - Bit string (low byte first):

==== Hex \String Directives

- <tt>'H'</tt> - Hex string (high nibble first):

- <tt>'h'</tt> - Hex string (low nibble first):

==== Pointer \String Directives

- <tt>'P'</tt> - Pointer to a structure (fixed-length string):

- <tt>'p'</tt> - Pointer to a null-terminated string:

==== Other \String Directives

- <tt>'u'</tt> - UU-encoded string:

- <tt>'M'</tt> - Quoted printable, MIME encoding;
  text mode, but input must use LF and output LF (see RFC 2045):

- <tt>'m'</tt> - Base64 encoded string.
  Count specifies input bytes between each newline,
  rounded down to nearest multiple of 3;
  If count is zero, no newlines are added (see RFC 4648):

=== Offset Directives

- <tt>'@'</tt> - Moves to absolute position:

- <tt>'X'</tt> - Back up a byte:

=== Null Byte Direcive

- <tt>'x'</tt> - Null byte:
