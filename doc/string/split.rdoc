Returns an array of substrings of +self+
that are the result of splitting +self+
at each occurrence of the given field separator +field_sep+.

When +field_sep+ is <tt>$;</tt>:

- If <tt>$;</tt> is +nil+ (its default value),
  the split occurs just as if +field_sep+ were given as a space character
  (see below).

- If <tt>$;</tt> is a string,
  the split occurs just as if +field_sep+ were given as that string
  (see below).

When +field_sep+ is <tt>' '</tt> (a single space), the split occurs at each sequence of whitespace.
Any leading sequences of whitespace are removed from the string before splitting:

  'abc def ghi'.split(' ')          # => ["abc", "def", "ghi"]
  "abc \n\tdef\t\n  ghi".split(' ') # => ["abc", "def", "ghi"]
  'abc  def   ghi'.split(' ')       # => ["abc", "def", "ghi"]
  ''.split(' ')                     # => []
  '  abc  def'.split(' ')           # => ["abc", "def"]

When +field_sep+ is <tt>''</tt> (an empty string), the string is split into individual characters.

  'abc'.split('')  # => ["a", "b", "c"]

When +field_sep+ is a string other than <tt>' '</tt> or <tt>''</tt>,
the split occurs at each occurrence of +field_sep+:

  'abracadabra'.split('ab')   # => ["", "racad", "ra"]
  ''.split('a')               # => []
  '3.14159'.split('1')        # => ["3.", "4", "59"]
  '!@#$%^$&*($)_+'.split('$') # => ["!@#", "%^", "&*(", ")_+"]
  'こんにちは'.split('に')    # => ["こん", "ちは"]

When +field_sep+ is a Regexp,
the split occurs at each occurrence of a match:

  'abracadabra'.split(/ab/)   # => ["", "racad", "ra"]
  'aaabcdaaa'.split(/[bcd]+/) # => ["aaa", "aaa"]
  '1 + 1 == 2'.split(/\W+/)   # => ["1", "1", "2"]

Note that to split by a single space, you need to pass `/ /` instead of `' '`.

  '  a   b   c'.split(' ')  # => ["a", "b", "c"]
  '  a   b   c'.split(/ /)  # => ["", "", "a", "", "", "b", "", "", "c"]

If the match result of the \Regexp has a length of 0, the string is
split into individual characters.

  'abc'.split(/x*/)      # => ["a", "b", "c"]
  'aaabcdaaa'.split(//)  # => ["a", "a", "a", "b", "c", "d", "a", "a", "a"]

If the \Regexp contains groups, their matches are also included
in the returned array:

  'ab:cd:ef'.split(/:./)     # => ["ab", "d", "f"]
  'ab:cd:ef'.split(/:(.)/)   # => ["ab", "c", "d", "e", "f"]
  'ab:cd:ef'.split(/(:(.))/) # => ["ab", ":c", "c", "d", ":e", "e", "f"]
  'ab:cd:ef'.split(/:()/)    # => ["ab", "", "cd", "", "ef"]

If +limit+ is +0+ (its default value), it means there is no limit on
the number of splits. The returned array excludes trailing empty
substrings:

  'aaabcdaaa'.split('a')     # => ["", "", "", "bcd"]
  '  abc  def  '.split(' ')  # => ["abc", "def"]
  'тест'.split('т')     # => ["", "ес"]

If +limit+ is a positive integer +n+, no more than <tt>n - 1</tt>
splits occur, so that at most +n+ substrings are returned,
and trailing empty substrings are included:

  'aaabcdaaa'.split('a', 1) # => ["aaabcdaaa"]
  'aaabcdaaa'.split('a', 2) # => ["", "aabcdaaa"]
  'aaabcdaaa'.split('a', 5) # => ["", "", "", "bcd", "aa"]
  'aaabcdaaa'.split('a', 7) # => ["", "", "", "bcd", "", "", ""]
  'aaabcdaaa'.split('a', 8) # => ["", "", "", "bcd", "", "", ""]

Note that if +field_sep+ is a \Regexp containing groups,
their matches are in the returned array, but do not count toward the limit.

  '1:2:3'.split(/(:)()()/, 2) # => ["1", ":", "", "", "2:3"]

If +limit+ is negative, it behaves the same as if +limit+ is zero,
except that trailing empty substrings are included:

  'aaabcdaaa'.split('a', -1)    # => ["", "", "", "bcd", "", "", ""]
  '  abc  def  '.split(' ', -1) # => ["abc", "def", ""]
  'abcde'.split(//, -1)         # => ["a", "b", "c", "d", "e", ""]

If a block is given, it is called with each substring:

  'abc def ghi'.split(' ') {|substring| p substring }

Output:

  "abc"
  "def"
  "ghi"

Related: String#partition, String#rpartition.
