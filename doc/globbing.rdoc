= Globbing

_Globbing_ is a form or wildcarding, based on {Unix-style command-line
wildcard characters}[https://en.wikipedia.org/wiki/Glob_(programming)].

Ruby supports two forms of globbing:

- Filename globbing, which performs matching on directory entry names.
- \String globbing, which performs matching on a given string.

Both forms use _patterns_ consisting of ordinary characters
and metacharacters (sometimes called <i>wildcard characters</i>).

== Filename Globbing

These Ruby methods implement <i>filename globbing</i>:

- Dir.glob.
- Pathname.glob.
- Pathname#glob.

Note that for Pathname to be available, you must:

  require 'pathname'

A call to any of the filename globbing methods:

- Specifies (implicitly or explicitly) string _path_, which is the path to a directory.
- Attempts to match the entry names in that directory according to a string _pattern_.
- Depending on the specific method:

  - File.glob: Forms an array of the matching entry names;
    returns the array if no block given,
    otherwise calls the block with each array element.
  - Pathname.glob or Pathname#glob:
    Forms an array of Pathname objects, one for each matching entry name;
    returns the array if no block given,
    otherwise calls the block with each array element.

Each of these methods also accepts an optional argument _flags_,
whose value may extend, restrict, or otherwise modify the matching.

=== Paths

Each of the globbing methods uses one or more _paths_,
each of which is the path to a directory
whose entry names are to be considered for matching.

Notes for the following examples:

- <tt>'*'</tt> is the pattern that matches any entry name
  except those that begin with <tt>'.'</tt>:

    pattern = '*' # For use in examples below.

- The current working directory, +ruby+, is the Ruby project's source directory:

    File.basename(Dir.pwd) # => "ruby"

- We use method Array#take to shorten returned arrays that otherwise would be very large.

==== Implicit Paths

- Implicit path for Dir.glob is <tt>'.'</tt>:

    Dir.glob(pattern).take(5)
    # => ["aclocal.m4", "addr2line.c", "addr2line.h", "array.c", "array.rb"]

- Implicit path for Pathname.glob is <tt>'.'</tt>:

    Pathname.glob(pattern).take(3)
    # => [#<Pathname:aclocal.m4>, #<Pathname:addr2line.c>, #<Pathname:addr2line.h>]

- Implicit path for Pathname#glob is the pathname's +to_s+ return value:

    pathname = Pathname.new('.')
    pathname.to_s # => "."
    pathname.glob(pattern).take(3)
    # => [#<Pathname:aclocal.m4>, #<Pathname:addr2line.c>, #<Pathname:addr2line.h>]

==== Explicit Paths

- Explicit path for Dir.glob or Pathname.glob
  is given by optional keyword argument +base+:

    Dir.glob(pattern, base: 'lib').take(5)
    # => ["abbrev.gemspec", "abbrev.rb", "base64.gemspec", "base64.rb", "benchmark.gemspec"]
    Dir.glob(pattern, base: 'lib/irb').take(5)
    # => ["cmd", "color.rb", "color_printer.rb", "completion.rb", "context.rb"]

    Pathname.glob(pattern, base: 'lib').take(3)
    # => [#<Pathname:abbrev.gemspec>, #<Pathname:abbrev.rb>, #<Pathname:base64.gemspec>]
    Pathname.glob(pattern, base: 'lib/irb').take(3)
    # => [#<Pathname:cmd>, #<Pathname:color.rb>, #<Pathname:color_printer.rb>]

- Instance method Pathname#glob does not accept keyword +base+;
  its path is always implicit (i.e., the pathname's +to_s+ return value).

=== Patterns

Each of the filename globbing methods accepts a _pattern_
(Dir.glob accepts multiple patterns)
that are used to match against the given path.

A pattern may contain the following metacharacters,
whose behaviors may be restricted, expanded, or otherwise modified
by _flags_:

- <tt>'*'</tt>: matches any entry name;
  equivalent to regexp <tt>/.*/x</tt>:

    pattern = '*'
    Dir.glob(pattern).take(5)
    # => ["aclocal.m4", "addr2line.c", "addr2line.h", "array.c", "array.rb"]
    Pathname.glob(pattern).take(3)
    # => [#<Pathname:aclocal.m4>, #<Pathname:addr2line.c>, #<Pathname:addr2line.h>]
    pathname.glob(pattern).take(3)
    # => [#<Pathname:aclocal.m4>, #<Pathname:addr2line.c>, #<Pathname:addr2line.h>]

- <tt>'c*'</tt>: matches any entry name beginning with <tt>'c'</tt>:

    pattern = 'c*'
    Dir.glob(pattern).take(5)
    # => ["ccan", "class.c", "common.mk", "compar.c", "compile.c"]
    Pathname.glob(pattern).take(3)
    # => [#<Pathname:ccan>, #<Pathname:class.c>, #<Pathname:common.mk>]
    pathname.glob(pattern).take(3)
    # => [#<Pathname:ccan>, #<Pathname:class.c>, #<Pathname:common.mk>]

- <tt>'*c'</tt>: matches any entry name ending with <tt>'c'</tt>:

    pattern = '*c'
    Dir.glob(pattern).take(5)
    # => ["addr2line.c", "array.c", "ast.c", "bignum.c", "builtin.c"]
    Pathname.glob(pattern).take(3)
    # => [#<Pathname:addr2line.c>, #<Pathname:array.c>, #<Pathname:ast.c>]
    pathname.glob(pattern).take(3)
    # => [#<Pathname:addr2line.c>, #<Pathname:array.c>, #<Pathname:ast.c>]

- <tt>'*c*'</tt>: matches any entry name containing <tt>'c'</tt>,
  including at the beginning or end:

    pattern = '*c*'
    Dir.glob(pattern).take(5)
    # => ["aclocal.m4", "addr2line.c", "array.c", "ast.c", "basictest"]
    Pathname.glob(pattern).take(3)
    # => [#<Pathname:aclocal.m4>, #<Pathname:addr2line.c>, #<Pathname:array.c>]
    pathname.glob(pattern).take(3)
    # => [#<Pathname:aclocal.m4>, #<Pathname:addr2line.c>, #<Pathname:array.c>]

- <tt>'**'</tt>: searches directories recursively, if followed by character <tt>'/'</tt>:

    pattern = '**/'
    Dir.glob(pattern).take(5)
    # => ["basictest/", "benchmark/", "benchmark/gc/", "benchmark/lib/", "benchmark/lib/benchmark_driver/"]
    Pathname.glob(pattern).take(3)
    # => [#<Pathname:basictest/>, #<Pathname:benchmark/>, #<Pathname:benchmark/gc/>]
    pathname.glob(pattern).take(3)
    # => [#<Pathname:/>, #<Pathname:basictest/>, #<Pathname:benchmark/>]

    Dir.glob(pattern).reverse.take(5)
    # => ["yjit/src/backend/x86_64/", "yjit/src/backend/arm64/", "yjit/src/backend/", "yjit/src/asm/x86_64/", "yjit/src/asm/arm64/inst/"]
    Pathname.glob(pattern).reverse.take(3)
    # => [#<Pathname:yjit/src/backend/x86_64/>, #<Pathname:yjit/src/backend/arm64/>, #<Pathname:yjit/src/backend/>]
    pathname.glob(pattern).reverse.take(2)
    # => [#<Pathname:yjit/src/backend/x86_64/>, #<Pathname:yjit/src/backend/arm64/>]

  If the string pattern contains other characters
  or is not followed by a slash character, it is equivalent to <tt>'*'</tt>.

- <tt>'?'</tt>: matches any single character.
  Equivalent to regexp <tt>/./</tt>:

    pattern = 'io.?'
    Dir.glob(pattern)      # => ["io.c"]
    Pathname.glob(pattern) # => [#<Pathname:io.c>]
    pathname.glob(pattern) # => [#<Pathname:io.c>]

- <tt>'[_characters_]'</tt>: matches any single character in _characters_;
  behaves like a \Regexp {character class}[rdoc-ref:Regexp#Character+Classes],
  including set negation (e.g., <tt>'[^a-z]'</tt>):

    pattern = '*.[a-z][a-z]'
    Dir.glob(pattern).take(5)
    # => ["array.rb", "ast.rb", "autogen.sh", "common.mk", "configure.ac"]
    Pathname.glob(pattern).take(3)    # => [#<Pathname:array.rb>, #<Pathname:ast.rb>, #<Pathname:autogen.sh>]
    pathname.glob(pattern).take(3)
    # => [#<Pathname:array.rb>, #<Pathname:ast.rb>, #<Pathname:autogen.sh>]

- <tt>'\'</tt>: escapes the next metacharacter:

  Note that on Windows, the backslash character may not be used in a string pattern:
  <tt>Dir['c:\foo*']</tt> will not work, use <tt>Dir['c:/foo*']</tt> instead.

See also flag File::FNM_EXTGLOB below.

=== Flags

\Integer _flags_ may be used to restrict, expand, or otherwise modify
the behavior of the filename globbing methods:

- Dir.glob and Pathname.glob accept optional keyword argument +flags+
  with an integer value:

    Dir.glob('*', flags: File::FNM_DOTMATCH).take(5)
    # => [".", ".appveyor.yml", ".cirrus.yml", ".dir-locals.el", ".document"]
    Pathname.glob('*', flags: File::FNM_DOTMATCH).take(3)
    # => [#<Pathname:.>, #<Pathname:.appveyor.yml>, #<Pathname:.cirrus.yml>]

- Pathname#glob accepts an optional second argument as a flags value:

    pathname.glob('*', File::FNM_DOTMATCH).take(3)
    # => [#<Pathname:.>, #<Pathname:.appveyor.yml>, #<Pathname:.cirrus.yml>]

The flags value may be the bitwise OR of any combination of individual
flag constants;  example:

  flags = File::FNM_CASEFOLD | File::FNM_DOTMATCH

==== Flag File::FNM_CASEFOLD

The FNM_CASEFOLD flag specifies that the matching is to be case-insensitive:

  Dir.glob('c*').take(5)
  # => ["CONTRIBUTING.md", "COPYING", "COPYING.ja", "ccan", "class.c"]
  Dir.glob('c*', flags: File::FNM_CASEFOLD).take(5)
  # => ["CONTRIBUTING.md", "COPYING", "COPYING.ja", "ccan", "class.c"]

==== Flag File::FNM_DOTMATCH

The FNM_DOTMATCH flag specifies that entry names beginning with <tt>'.'</tt>
should be considered for matching:

  Dir.glob('*').take(5)
  # => ["BSDL", "CONTRIBUTING.md", "COPYING", "COPYING.ja", "GPL"]
  Dir.glob('*', flags: File::FNM_DOTMATCH).take(5)
  # => [".", ".appveyor.yml", ".cirrus.yml", ".dir-locals.el", ".document"]

==== Flag File::FNM_EXTGLOB

Flag File::FNM_EXTGLOB flag enables the pattern extension
<tt>'{_a_,_b_}'</tt>, which matches pattern _a_ and pattern _b_;
  behaves like
  a {regexp union}[https://docs.ruby-lang.org/en/master/Regexp.html#method-c-union]
  (e.g., <tt>'(?:_a_|_b_)'</tt>):

    pattern = '{LEGAL,BSDL}'
    Dir.glob(pattern)      # => ["LEGAL", "BSDL"]
    Pathname.glob(pattern) # => [#<Pathname:LEGAL>, #<Pathname:BSDL>]
    pathname.glob(pattern) # => [#<Pathname:LEGAL>, #<Pathname:BSDL>]

==== Flag File::FNM_NOESCAPE

Flag File::FNM_NOESCAPE specifies that escaping with the backslash character <tt>'\'</tt>
is disabled; the character is not an escape character.

==== Flag File::FNM_PATHNAME

Metacharacters <tt>'*'</tt> and <tt>'?'</tt> do not match directory separators.

==== Flag File::FNM_SHORTNAME

Patterns may match short names if they exist; Windows only.

==== Flag File::FNM_SYSCASE

Case sensitivity (sensitive or insensitive) is the same as the system.

=== Sorting

By default, the array returned by a globbing method is sorted.

Methods Dir.glob and Pathname.glob accept optional keyword argument +sort+;
passing value +false+ with that keyword disables sorting
(though the underlying file system may already have sorted the array).

  Dir.glob('*', sort: false).take(5)
  # => ["aclocal.m4", "addr2line.c", "addr2line.h", "array.c", "array.rb"]
  Pathname.glob('*', sort: false).take(3)
  # => [#<Pathname:aclocal.m4>, #<Pathname:addr2line.c>, #<Pathname:addr2line.h>]

== \String Globbing

Methods File.fnmatch and Pathname#fnmatch perform matching using a pattern
and an ordinary string;
each returns +true+ if the match succeeds, +false+ otherwise:

- File.fnmatch accepts string arguments +pattern+ and +path+,
  and optional argument +flags+.
- Pathname#fnmatch accepts string argument +pattern+ and optional argument +flags+;
  its 'path' is the pathname's +to_s+ value.

For the two methods:

- The patterns are the same as in filename globbing,
  except that <tt>'**/'</tt> is the same as <tt>'*'</tt>.
- The flags are the same as in filename globbing.

Examples:

  File.fnmatch('cat', 'cat')      # => true  # Matches entire string.
  File.fnmatch('cat', 'category') # => false # Only matches part of string.

  pathname = Pathname.new('cat')
  pathname.fnmatch('cat') # => true # Same as above.
  pathname = Pathname.new('category')
  pathname.fnmatch('cat') # => false # Same as above.

  flags = File::FNM_EXTGLOB
  File.fnmatch('c{at,ub}s', 'cats')        # => false # Extension off by default.
  File.fnmatch('c{at,ub}s', 'cats', flags) # => true  # Extension on.

  File.fnmatch('c?t',     'cat')     # => true  # 'a' matches '?'.
  File.fnmatch('c??t',    'cat')     # => false # 'a' does not match '??'.
  File.fnmatch('c*',      'cats')    # => true  # 'ats' matches '*'.
  File.fnmatch('c*t',     'c/a/b/t') # => true  # '/a/b/' matches '*'.
  File.fnmatch('ca[a-z]', 'cat')     # => true  # 't' matches '[a-z]'.
  File.fnmatch('ca[^t]',  'cat')     # => false # 't' does not match '[^t]'.

  File.fnmatch('cat', 'CAT')        # => false # Case-sensitive.
  flags = File::FNM_CASEFOLD
  File.fnmatch('cat', 'CAT', flags) # => true  # Case-insensitive.
  flags = File::FNM_SYSCASE
  File.fnmatch('cat', 'CAT', flags) # => true  # System-dependent.

  flags = File::FNM_PATHNAME
  File.fnmatch('?',   '/', flags) # => false # '/' does not match '?'.
  File.fnmatch('*',   '/', flags) # => false # '/' does not match '*'.
  File.fnmatch('[/]', '/', flags) # => false # '/' does not match '[/]'.

  File.fnmatch('\?',   '?')         # => true # Escaped '?' becomes ordinary.
  File.fnmatch('\a',   'a')         # => true # Escaped ordinary remains ordinary.
  flags = File::FNM_NOESCAPE
  File.fnmatch('\a',   '\a', flags) # => true # No-escaped '\' becomes ordinary.
  File.fnmatch('[\?]', '?')         # => true # Can escape inside brackets.

  File.fnmatch('*',   '.profile')        # => false # Leading '.' does not match '*'.
  flags = File::FNM_DOTMATCH
  File.fnmatch('*',   '.profile', flags) # => true  # Leading '.' matches '*'.
  File.fnmatch('.*',  '.profile')        # => true  # Leading '.' matches '.'.

  File.fnmatch('**/*.rb', 'main.rb')     # => false
  File.fnmatch('**/*.rb', './main.rb')   # => false
  File.fnmatch('**/*.rb', 'lib/song.rb') # => true
  File.fnmatch('**.rb', 'main.rb')       # => true
  File.fnmatch('**.rb', './main.rb')     # => false
  File.fnmatch('**.rb', 'lib/song.rb')   # => true
  File.fnmatch('*',     'dave/.profile') # => true

  flags = File::FNM_PATHNAME
  File.fnmatch('**/foo', 'a/b/c/foo', flags)    # => true
  File.fnmatch('**/foo', '/a/b/c/foo', flags)   # => true
  File.fnmatch('**/foo', 'c:/a/b/c/foo', flags) # => true
  File.fnmatch('**/foo', 'a/.b/c/foo', flags)   # => false
  flags = File::FNM_PATHNAME | File::FNM_DOTMATCH
  File.fnmatch('**/foo', 'a/.b/c/foo', flags)   # => true
