== \IO Streams

Ruby supports processing data as \IO streams;
that is, as data that may be read, re-read, written, re-written,
and traversed via iteration.

Core classes with such support include:

- IO, and its derived class File.
- {StringIO}[rdoc-ref:StringIO]: for processing a string.
- {ARGF}[rdoc-ref:ARGF]: for processing files cited on the command line.

Pre-existing stream objects that are referenced by constants include:

- $stdin: read-only instance of \IO.
- $stdout: write-only instance of \IO.
- $stderr: read-only instance of \IO.
- \ARGF: read-only instance of \ARGF.

You can create stream objects:

- \File:

  - File.new: returns a new \File object.
  - File.open: passes a new \File object to given the block.

- \IO:

  - IO.new: returns a new \IO object for the given integer file descriptor.
  - IO.open: passes a new \IO object to the given block.
  - IO.popen: returns a new \IO object that is connected to the $stdin
    and $stdout of a newly-launched subprocess.
  - Kernel#open: returns a new \IO object connected to a given source:
    stream, file, or subprocess.

- \StringIO:

  - StringIO.new: returns a new \StringIO object.
  - StringIO.open: passes a new \StringIO object to the given block.

(You cannot create an \ARGF object, but one already exists.)

=== About the Examples

Many examples here use these variables:

  # English text with newlines.
  text = <<~EOT
  First line
  Second line

  Fourth line
  Fifth line
  EOT

  # Russian text.
  russian = "\u{442 435 441 442}" # => "тест"

  # Binary data.
  data = "\u9990\u9991\u9992\u9993\u9994"

  # Text file.
  File.write('t.txt', text)

  # File with Russian text.
  File.write('t.rus', russian)

  # File with binary data.
  f = File.new('t.dat', 'wb:UTF-16')
  f.write(data)
  f.close

The examples also assume that \StringIO has been required:

  require 'stringio'

=== Stream Modes

Some stream-creating method calls specify a mode for the stream;
the mode determines how stream may be accessed, including:

- Whether the stream is to be read-only, write-only, or read-write.
- Whether the stream treats data as text-only or binary.
- The external and internal encodings for the stream.
- The initial settings for stream position and line number.

An \IO stream has:

- A <i>read/write mode</i>, which may be read-only, write-only, or read/write;
  see {Read/Write Mode}[rdoc-ref:io_streams.rdoc@Read-2FWrite+Mode+Specified+As+a+String].
- A <i>data mode</i>, which may be text-only or binary;
  see {Data Mode}[rdoc-ref:io_streams.rdoc@Data+Mode+Specified+as+a+String].
- <i>Encodings</i>, both external and internal;
  see {Encodings}[rdoc-ref:io_streams.rdoc@Encodings].
- A <i>position</i>, which determines where in the stream
  the next read or write is to occur;
  see {Position}[rdoc-ref:io_streams.rdoc@Position].
- A <i>line number</i>, which is a special line-oriented “position”
  (different from the position mentioned above);
  see {Line Number}[rdoc-ref:io_streams.rdoc@Line+Number].

==== Access Mode

Stream access mode may be specified as either a string or an integer.

===== Read/Write Mode Specified As a \String

When the mode is given as a string,
it must begin with one of the following:

- <tt>'r'</tt>: Read-only stream, positioned at the beginning:

    f = File.new('t.txt', 'r')        # => #<File:t.txt>
    io = IO.new(f.fileno, 'r')        # => #<IO:fd 4>
    sio = StringIO.new(text.dup, 'r') # => #<StringIO>

  The stream is initially positioned at the beginning.
  Each read begins at the current stream position;
  after each read, the stream is positioned at the end of the read data:

    f.readline # => "First line\n"
    f.pos      # => 11
    f.readline # => "Second line\n"
    f.pos      # => 23

  You can use methods IO#rewind, IO#pos=, and IO#seek
  to change to and read from any position (even past the stream's end):

    f.pos = 0
    f.readline # => "First line\n"
    f.pos = 3
    f.readline # => "st line\n"
    f.pos = 800
    f.read     # => ""

  Raises an exception if:

  - Writing is attempted.
  - The stream is to be a \File object,
    but the given path does not point to a readable file.
  - The stream is to be an \IO object,
    but the given file descriptor does not point to a readable file.

- <tt>'w'</tt>: Write-only stream, positioned at the beginning:

    # Non-existent file.
    FileUtils.rm_f('t.tmp')
    f = File.new('t.tmp', 'w') # => #<File:t.tmp>
    io = IO.new(f.fileno, 'w') # => #<IO:fd 4>

    # Existing file; truncated to size zero.
    File.write('t.tmp', text)
    f = File.new('t.tmp', 'w') # => #<File:t.tmp>
    f.size                     # => 0
    io = IO.new(f.fileno, 'w') # => #<IO:fd 5>

    # StringIO (not file).
    sio = StringIO.new(text.dup, 'w') # => #<StringIO>

  The stream is initially positioned at the beginning (which is also the end).
  After each write, the stream is positioned at the end of the written data:

    f.puts('First line')
    f.flush
    File.new('t.tmp').read # => "First line\n"
    f.pos    # => 11
    f.puts('Second line')
    f.pos    # => 23
    f.flush
    File.new('t.tmp').read # => "First line\nSecond line\n"

  You can use methods IO#rewind, IO#pos=, and IO#seek
  to change to and read from any position (even past the stream's end):

    f.pos = 0
    f.write('FOO')
    f.flush
    File.new('t.tmp').read # => "FOOst line\nSecond line\n"

    f.pos = 10
    f.write('BAR')
    f.flush
    File.new('t.tmp').read # => "FOOst lineBARecond line\n"

    f.pos = 24
    f.write('BAZ')
    f.flush
    File.new('t.tmp').read # => "FOOst lineBARecond line\n\u0000\u0000BAZ"

  Raises an exception if:

  - Reading is attempted.
  - The stream is to be a \File object,
    but the given path exists and does not point to a writable file.
  - The stream is to be an \IO object,
    but the given file descriptor does not point to a writable file.

- <tt>'a'</tt>: Write-only stream, positioned at the end:

    # Non-existent file.
    FileUtils.rm_f('t.tmp')
    f = File.new('t.tmp', 'a')  # => #<File:t.tmp>
    io = IO.new(f.fileno, 'a')  # => #<IO:fd 4>

    # Existing file (not truncated).
    File.write('t.tmp', text)
    f = File.new('t.tmp', 'a')    # => #<File:t.tmp>
    f.size                        # => 47
    io = IO.new(f.fileno, 'a')    # => #<IO:fd 5>

    # StringIO.
    sio = StringIO.new(text,dup, 'a') # => #<StringIO>

  Written data is always appended, regardless of the position
  set by methods IO#rewind, IO#pos=, and IO#seek.

    f.pos = 0
    f.write('FOO')
    f.flush
    File.new('t.tmp').read
    # => "First line\nSecond line\n\nFourth line\nFifth line\nFOO"

    f.pos = 10
    f.write('BAR')
    f.flush
    File.new('t.tmp').read
    # => "First line\nSecond line\n\nFourth line\nFifth line\nFOOBAR"

    f.pos = 800
    f.write('BAZ')
    f.flush
    File.new('t.tmp').read
    # => "First line\nSecond line\n\nFourth line\nFifth line\nFOOBARBAZ"

  Raises an exception if:

  - Reading is attempted.
  - The stream is to be a \File object,
    but the given path exists and does not point to a writable file.
  - The stream is to be an \IO object,
    but the given file descriptor does not point to a writable file.

- <tt>'r+'</tt>: Read-write stream, positioned at the beginning:

    File.write('t.tmp', text)
    f = File.new('t.tmp', 'r+')
    f.size # => 47
    io = IO.new(f.fileno, 'r+')

    sio = StringIO.new(text.dup, 'r+')
    sio.size # => 47

  The stream is initially positioned at the beginning:

    f.read
    # => "First line\nSecond line\n\nFourth line\nFifth line\n"

  You can use methods IO#rewind, IO#pos=, and IO#seek
  to change to, read from, and write to any position
  (even past the stream's end):

    f.pos = 0
    f.write('FOO')
    f.rewind
    f.read
    # => "FOOst line\nSecond line\n\nFourth line\nFifth line\n"

    f.pos = 3
    f.write('BAR')
    f.rewind
    f.read
    # => "FOOBARline\nSecond line\n\nFourth line\nFifth line\n"

    f.pos = 47
    f.write('BAZ')
    f.rewind
    f.read
    # => "FOOBARline\nSecond line\n\nFourth line\nFifth line\n\u0000\u0000BAZ"

  Raises an exception if:

  - The stream is to be a \File object,
    but the given path does not point to a readable/writable file.
  - The stream is to be an \IO object,
    but the given file descriptor does not point to a readable/writable file.

- <tt>'w+'</tt>: Read-write stream, positioned at the beginning:

    # File does not exist.
    FileUtils.rm_f('t.tmp')
    f = File.new('t.tmp', 'w+') # => #<File:t.tmp>
    f.size                      # => 0
    io = IO.new(f.fileno, 'w+') # => #<IO:fd 4>

    # File exists.
    File.write('t.tmp', text)
    f = File.new('t.tmp', 'w+') # => #<File:t.tmp>
    f.size                      # => 0 # Truncated to size zero.
    io = IO.new(f.fileno, 'w+') # => #<IO:fd 5>

    # StringIO.
    sio = StringIO.new(text.dup, 'w+') # => #<StringIO>

  The stream is initially positioned at the beginning (which is also the end):

    f.read # => ""

  You can use methods IO#rewind, IO#pos=, and IO#seek
  to change to, read from, and write to any position
  (even past the stream's end):

    f,pos = 0
    f.puts('First line')
    f.puts('Second line')
    f.rewind
    f.read
    # => "First line\nSecond line\n"

    f.pos = 3
    f.write('FOO')
    f.rewind
    f.read
    # => "FirFOOline\nSecond line\n"

    f.pos = 23
    f.write('BAR')
    f.rewind
    f.read
    # => "First line\nSecond line\n\u0000\u0000BAR"

  Raises an exception if:

  - The stream is to be a \File object,
    but the given path exists and does not point to a readable/writable file.
  - The stream is to be an \IO object,
    but the given file descriptor does not point to a readable/writable file.

- <tt>'a+'</tt>: Read-write stream, positioned at the end:

    # File does not exist.
    FileUtils.rm_f('t.tmp')
    f = File.new('t.tmp')
    io = IO.new(f.fileno)

    # File exists.
    File.write('t.tmp', text)
    f = File.new('t.tmp', 'a+')
    io = IO.new(f.fileno, 'a+')
    f.size # => 47 # Not truncated.
    f.read
    # => "First line\nSecond line\n\nFourth line\nFifth line\n"

    # StringIO.
    sio = StringIO.new(text.dup, 'a+')

  The stream is initially positioned at the end:

    f.write('FOO')
    f.rewind
    f.read
    # => "First line\nSecond line\n\nFourth line\nFifth line\nFOO"

  Written data is always appended, regardless of the use
  of methods IO#rewind, IO#pos=, and IO#seek:

    f.pos = 10
    f.write('BAR')
    f.rewind
    f.read
    # => "First line\nSecond line\n\nFourth line\nFifth line\nFOOBAR"

    f.pos = 800
    f.write('BAZ')
    f.rewind
    f.read
    # => "First line\nSecond line\n\nFourth line\nFifth line\nFOOBARBAZ"

  Raises an exception if:

  - The stream is to be a \File object,
    but the given path exists but does not point to a readable/writable file.
  - The stream is to be an \IO object,
    but the given file descriptor does not point to a readable/writable file.

===== Data Mode Specified as a \String

To specify whether data is to be treated as text or as binary data,
either of the following may be suffixed to any of the string read/write modes
above:

- <tt>'t'</tt>: Text data; sets the default external encoding
  to <tt>Encoding::UTF_8</tt>;
  on Windows, enables conversion between EOL and CRLF
  and enables interpreting <tt>0x1A</tt> as an end-of-file marker.
- <tt>'b'</tt>: Binary data; sets the default external encoding
  to <tt>Encoding::ASCII_8BIT</tt>;
  on Windows, suppresses conversion between EOL and CRLF
  and disables interpreting <tt>0x1A</tt> as an end-of-file marker.

If neither is given, the stream defaults to text data.

Examples:

  File.new('t.txt', 'rt')
  File.new('t.dat', 'rb')

When the data mode is specified, the read/write mode may not be omitted,
and the data mode must precede the file-create mode, if given:

  File.new('t.dat', 'b')   # Raises an exception.
  File.new('t.dat', 'rxb') # Raises an exception.

===== File-Create Mode Specified as a \String

The following may be suffixed to any writable string mode above:

- <tt>'x'</tt>: Creates the file if it does not exist;
  raises an exception if the file exists.

Example:

  File.new('t.tmp', 'wx')

When the file-create mode is specified, the read/write mode may not be omitted,
and the file-create mode must follow the data mode:

  File.new('t.dat', 'x')   # Raises an exception.
  File.new('t.dat', 'rxb') # Raises an exception.

===== Read/Write Mode Specified as an \Integer

When mode is an integer it must be one or more of the following constants,
which may be combined by the bitwise OR operator <tt>|</tt>:

- File::RDONLY: Open for reading only.
- File::WRONLY: Open for writing only.
- File::RDWR: Open for reading and writing.
- File::APPEND: Open for appending only.

Examples:

  File.new('t.txt', File::RDONLY)
  File.new('t.tmp', File::RDWR | File::CREAT | File::EXCL)

Note: Method IO#set_encoding does not allow the mode to be specified as an integer.

===== File-Create Mode Specified as an \Integer

These constants may also be ORed into the integer mode:

- +File::CREAT+: Create file if it does not exist.
- +File::EXCL+: Raise an exception if +File::CREAT+ is given and the file exists.

===== Data Mode Specified as an \Integer

Data mode cannot be specified as an integer.
When the stream access mode is given as an integer,
the data mode is always text, never binary.

Although there is a constant +File::BINARY+,
setting its value in an integer stream mode has no effect;
this is because, as documented in File::Constants, the +File::BINARY+ value
disables line code conversion, but does not change the external encoding.

=== Encodings

Any of the string modes above may specify encodings
– either external encoding only or both external and internal encodings –
by appending one or both encoding names, separated by colons:

  f = File.new('t.dat', 'rb')
  f.external_encoding # => #<Encoding:ASCII-8BIT>
  f.internal_encoding # => nil
  f = File.new('t.dat', 'rb:UTF-16')
  f.external_encoding # => #<Encoding:UTF-16 (dummy)>
  f.internal_encoding # => nil
  f = File.new('t.dat', 'rb:UTF-16:UTF-16')
  f.external_encoding # => #<Encoding:UTF-16 (dummy)>
  f.internal_encoding # => #<Encoding:UTF-16>
  f.close

The numerous encoding names are available in array Encoding.name_list:

  Encoding.name_list.size    # => 175
  Encoding.name_list.take(3) # => ["ASCII-8BIT", "UTF-8", "US-ASCII"]

When the external encoding is set, strings read are tagged by that encoding
when reading, and strings written are converted to that encoding when writing.

When both external and internal encodings are set,
strings read are converted from external to internal encoding,
and strings written are converted from internal to external encoding.
For further details about transcoding input and output,
see {Encodings}[rdoc-ref:io_streams.rdoc@Encodings].

If the external encoding is <tt>'BOM|UTF-8'</tt>, <tt>'BOM|UTF-16LE'</tt>
or <tt>'BOM|UTF16-BE'</tt>,
Ruby checks for a Unicode BOM in the input document
to help determine the encoding.
For UTF-16 encodings the file open mode must be binary.
If the BOM is found,
it is stripped and the external encoding from the BOM is used.

Note that the BOM-style encoding option is case insensitive,
so <tt>‘bom|utf-8’</tt> is also valid.

=== Position

An \IO stream has a nonnegative integer _position_,
which is the byte offset at which the next read or write is to occur;
the relevant methods:

- +#tell+ (aliased as #pos): Returns the current position (in bytes) in the stream:

    f = File.new('t.txt')
    f.tell # => 0
    f.gets # => "First line\n"
    f.tell # => 12
    f.close

- +#pos=+:  Sets the position of the stream (in bytes):

    f = File.new('t.txt')
    f.tell     # => 0
    f.pos = 20 # => 20
    f.tell     # => 20
    f.close

- +#seek+: Sets the position of the stream to a given integer +offset+
  (in bytes), with respect to a given constant +whence+, which is one of:

  - +:CUR+ or <tt>IO::SEEK_CUR</tt>:
    Repositions the stream to its current position plus the given +offset+:

      f = File.new('t.txt')
      f.tell            # => 0
      f.seek(20, :CUR)  # => 0
      f.tell            # => 20
      f.seek(-10, :CUR) # => 0
      f.tell            # => 10
      f.close

  - +:END+ or <tt>IO::SEEK_END</tt>:
    Repositions the stream to its end plus the given +offset+:

      f = File.new('t.txt')
      f.tell            # => 0
      f.seek(0, :END)   # => 0  # Repositions to stream end.
      f.tell            # => 52
      f.seek(-20, :END) # => 0
      f.tell            # => 32
      f.seek(-40, :END) # => 0
      f.tell            # => 12
      f.close

  - +:SET+ or <tt>IO:SEEK_SET</tt>:
    Repositions the stream to the given +offset+:

      f = File.new('t.txt')
      f.tell            # => 0
      f.seek(20, :SET) # => 0
      f.tell           # => 20
      f.seek(40, :SET) # => 0
      f.tell           # => 40
      f.close

- +#rewind+: Positions the stream to the beginning:

    f = File.new('t.txt')
    f.tell     # => 0
    f.gets     # => "First line\n"
    f.tell     # => 12
    f.rewind   # => 0
    f.tell     # => 0
    f.close

=== Lines

Some reader methods in \IO streams are line-oriented;
such a method reads one or more lines,
which are separated by an implicit or explicit line separator.

These methods are included (except as noted) in classes Kernel, IO, File,
and {ARGF}[rdoc-ref:ARGF]:

- +#each_line+ - passes each line to the block; not in Kernel:

    f = File.new('t.txt')
    f.each_line {|line| p line }

  Output:

    "First line\n"
    "Second line\n"
    "\n"
    "Fourth line\n"
    "Fifth line\n"

  The reading may begin mid-line:

    f = File.new('t.txt')
    f.pos = 27
    f.each_line {|line| p line }

  Output:

    "rth line\n"
    "Fifth line\n"

- +#gets+ - returns the next line (which may begin mid-line):

    f = File.new('t.txt')
    f.gets      # => "First line\n"
    f.gets      # => "Second line\n"
    f.pos = 27
    f.gets      # => "rth line\n"
    f.readlines # => ["Fifth line\n"]
    f.gets      # => nil

- +#readline+ - like #gets, but raises an exception at end-of-file;
  not in StringIO.

- +#readlines+ - returns all remaining lines in an array;
  may begin mid-line:

    f = File.new('t.txt')
    f.pos = 19
    f.readlines # => ["ine\n", "\n", "Fourth line\n", "Fifth line\n"]
    f.readlines # => []

Each of these methods may be called with:

- An optional line separator, +sep+.
- An optional line-size limit, +limit+.
- Both +sep+ and +limit+.

==== Line Separator

The default line separator is the given by the global variable <tt>$/</tt>,
whose value is often <tt>"\n"</tt>.
The line to be read next is all data from the current position
to the next line separator:

  f = File.new('t.txt')
  f.gets # => "First line\n"
  f.gets # => "Second line\n"
  f.gets # => "\n"
  f.gets # => "Fourth line\n"
  f.gets # => "Fifth line\n"
  f.close

You can specify a different line separator:

  f = File.new('t.txt')
  f.gets('l')   # => "First l"
  f.gets('li')  # => "ine\nSecond li"
  f.gets('lin') # => "ne\n\nFourth lin"
  f.gets        # => "e\n"
  f.close

There are two special line separators:

- +nil+: The entire stream is read into a single string:

    f = File.new('t.txt')
    f.gets(nil) # => "First line\nSecond line\n\nFourth line\nFifth line\n"
    f.close

- <tt>''</tt> (the empty string): The next "paragraph" is read
  (paragraphs being separated by two consecutive line separators):

    f = File.new('t.txt')
    f.gets('') # => "First line\nSecond line\n\n"
    f.gets('') # => "Fourth line\nFifth line\n"
    f.close

==== Line Limit

The line to be read may be further defined by an optional argument +limit+,
which specifies that the line may not be (much) longer than the given limit;
a multi-byte character will not be split, and so a line may be slightly longer
than the given limit.

If +limit+ is not given, the line is determined only by +sep+.

  # Text with 1-byte characters.
  File.new('t.txt') {|f| f.gets(1) }  # => "F"
  File.new('t.txt') {|f| f.gets(2) }  # => "Fi"
  File.new('t.txt') {|f| f.gets(3) }  # => "Fir"
  File.new('t.txt') {|f| f.gets(4) }  # => "Firs"
  # No more than one line.
  File.new('t.txt') {|f| f.gets(10) } # => "First line"
  File.new('t.txt') {|f| f.gets(11) } # => "First line\n"
  File.new('t.txt') {|f| f.gets(12) } # => "First line\n"

  # Text with 2-byte characters, which will not be split.
  File.new('r.rus') {|f| f.gets(1).size } # => 1
  File.new('r.rus') {|f| f.gets(2).size } # => 1
  File.new('r.rus') {|f| f.gets(3).size } # => 2
  File.new('r.rus') {|f| f.gets(4).size } # => 2

==== Line Separator and Line Limit

With arguments +sep+ and +limit+ given,
combines the two behaviors:

- Returns the next line as determined by line separator +sep+.
- But returns no more bytes than are allowed by the limit.

Example:

  File.new('t.txt') {|f| f.gets('li', 20) } # => "First li"
  File.new('t.txt') {|f| f.gets('li', 2) }  # => "Fi"

==== Line Number

A readable \IO stream has a _line_ _number_,
which is the non-negative integer line number
in the stream where the next read will occur.

A new stream is initially has line number +0+.

\Method IO#lineno returns the line number.

Reading lines from a stream usually changes its line number:

  f = File.new('t.txt', 'r')
  f.lineno   # => 0
  f.readline # => "This is line one.\n"
  f.lineno   # => 1
  f.readline # => "This is the second line.\n"
  f.lineno   # => 2
  f.readline # => "Here's the third line.\n"
  f.lineno   # => 3
  f.eof?     # => true
  f.close

Iterating over lines in a stream usually changes its line number:

     f = File.new('t.txt')
     f.each_line do |line|
       p "position=#{f.pos} eof?=#{f.eof?} line=#{line}"
     end
     f.close

Output:

 "position=19 eof?=false line=This is line one.\n"
 "position=45 eof?=false line=This is the second line.\n"
 "position=70 eof?=true line=This is the third line.\n"

==== Line Options

A number of \IO methods accept optional keyword arguments
that determine how lines in a stream are to be treated:

- +:chomp+: If +true+, line separators are omitted; default is +false+.

=== Open and Closed \IO Streams

A new \IO stream may be open for reading, open for writing, or both.

You can close a stream using these methods:

- +#close+ - closes the stream for both reading and writing.

- +#close_read+ (not available in \ARGF) - closes the stream for reading.

- +#close_write+ (not available in \ARGF) - closes the stream for writing.

You can query whether a stream is closed using these methods:

- +#closed?+ - returns whether the stream is closed.

- +#closed_read?+ (\StringIO only) - returns whether the stream
  is closed for reading.

- +#closed_write?+ (\StringIO only) - returns whether the stream
  is closed for writing.

=== Stream End-of-File

You can query whether a stream is at end-of-file using this method:

- +#eof?+ (also aliased as +#eof+) -
  returns whether the stream is at end-of-file.

