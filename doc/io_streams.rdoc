== \IO Streams

This page describes:

- {Stream classes}[rdoc-ref:io_streams.rdoc@Stream+Classes].
- {Pre-existing streams}[rdoc-ref:io_streams.rdoc@Pre-Existing+Streams].
- {User-created streams}[rdoc-ref:io_streams.rdoc@User-Created+Streams].
- {Basic \IO}[rdoc-ref:io_streams.rdoc@Basic+IO], including:

  - {Position}[rdoc-ref:io_streams.rdoc@Position].
  - {Open and closed streams}[rdoc-ref:io_streams.rdoc@Open+and+Closed+Streams].
  - {End-of-stream}[rdoc-ref:io_streams.rdoc@End-of-Stream].

- {Line \IO}[rdoc-ref:io_streams.rdoc@Line+IO], including:

  - {Line separator}[rdoc-ref:io_streams.rdoc@Line+Separator].
  - {Line limit}[rdoc-ref:io_streams.rdoc@Line+Limit].
  - {Line number}[rdoc-ref:io_streams.rdoc@Line+Number].
  - {Line options}[rdoc-ref:io_streams.rdoc@Line+Options].

- {Character \IO}[rdoc-ref:io_streams.rdoc@Character+IO].
- {Byte \IO}[rdoc-ref:io_streams.rdoc@Byte+IO].
- {Codepoint \IO}[rdoc-ref:io_streams.rdoc@Codepoint+IO].

=== Stream Classes

Ruby supports processing data as \IO streams;
that is, as data that may be read, re-read, written, re-written,
and traversed via iteration.

Core classes with such support include:

- IO, and its derived class File.
- {StringIO}[rdoc-ref:StringIO]: for processing a string.
- {ARGF}[rdoc-ref:ARGF]: for processing files cited on the command line.

Except as noted, the instance methods described on this page
are available in classes \ARGF, \File, \IO, and \StringIO.
A few, also noted, are available in class \Kernel.

=== Pre-Existing Streams

Pre-existing streams that are referenced by constants include:

- $stdin: read-only instance of \IO.
- $stdout: write-only instance of \IO.
- $stderr: read-only instance of \IO.
- \ARGF: read-only instance of \ARGF.

=== User-Created Streams

You can create streams:

- \File:

  - File.new: returns a new \File object;
    the file should be closed when no longer needed.
  - File.open: passes a new \File object to given the block;
    the file is automatically closed on block exit.

- \IO:

  - IO.new: returns a new \IO object for the given integer file descriptor;
    the \IO object should be closed when no longer needed.
  - IO.open: passes a new \IO object to the given block;
    the \IO object is automatically closed on block exit.
  - IO.popen: returns a new \IO object that is connected to the $stdin
    and $stdout of a newly-launched subprocess.
  - Kernel#open: returns a new \IO object connected to a given source:
    stream, file, or subprocess;
    the \IO object should be closed when no longer needed.

- \StringIO:

  - StringIO.new: returns a new \StringIO object;
    the \StringIO object should be closed when no longer needed.
  - StringIO.open: passes a new \StringIO object to the given block;
    the \StringIO object is automatically closed on block exit.

(You cannot create an \ARGF object, but one already exists.)

=== About the Examples

Many examples here use these variables:

  :include: doc/examples/files.rdoc

=== Basic \IO

You can perform basic stream \IO with these methods,
which typically operate on multi-byte strings:

- IO#read: Reads and returns some or all of the remaining bytes from the stream.
- IO#write: Writes zero or more strings to the stream;
  each given object that is not already a string is converted via +to_s+.

==== Position

An \IO stream has a nonnegative integer _position_,
which is the byte offset at which the next read or write is to occur.
A new stream has position zero (and line number zero);
method +rewind+ resets the position (and line number) to zero.

The relevant methods:

- IO#tell (aliased as +#pos+): Returns the current position (in bytes) in the stream.
- IO#pos=: Sets the position of the stream to a given integer +new_position_ (in bytes).
- IO#seek: Sets the position of the stream to a given integer +offset+ (in bytes),
  relative to a given position +whence+
  (indicating the beginning, end, or current position).
- IO#rewind: Positions the stream at the beginning (also resetting the line number).

==== Open and Closed Streams

A new \IO stream may be open for reading, open for writing, or both.

A stream is automatically closed when claimed by the garbage collector.

Attempted reading or writing on a closed stream raises an exception.

The relevant methods:

- IO#close: Closes the stream for both reading and writing.
- IO#close_read: Closes the stream for reading; not in ARGF.
- IO#close_write: Closes the stream for writing; not in ARGF.
- IO#closed?: Returns whether the stream is closed.

==== End-of-Stream

You can query whether a stream is positioned at its end:

- IO#eof? (also aliased as +#eof+): Returns whether the stream is at end-of-stream.

You can reposition to end-of-stream by using method IO#seek:

  f = File.new('t.txt')
  f.eof? # => false
  f.seek(0, :END)
  f.eof? # => true
  f.close

Or by reading all stream content (which is slower than using IO#seek):

  f.rewind
  f.eof? # => false
  f.read # => "First line\nSecond line\n\nFourth line\nFifth line\n"
  f.eof? # => true

=== Line \IO

You can read an \IO stream line-by-line using these methods:

- IO#each_line: Reads each remaining line, passing it to the given block.
- IO#gets (also in Kernel): Returns the next line.
- IO#readline (also in Kernel; not in StringIO):
  Like #gets, but raises an exception at end-of-stream.
- IO#readlines (also in Kernel): Returns all remaining lines in an array.

Each of these reader methods accepts:

- An optional line separator, +sep+.
- An optional line-size limit, +limit+.
- Both +sep+ and +limit+.

For each of these reader methods, reading may begin mid-line,
depending on the stream's position;
see {Position}[rdoc-ref:io_streams.rdoc@Position]:

  f = File.new('t.txt')
  f.pos = 27
  f.each_line {|line| p line }
  f.close

Output:

  "rth line\n"
  "Fifth line\n"

You can write to an \IO stream line-by-line using this method:

- IO#puts (also in Kernel; not in \StringIO): Writes objects to the stream.

==== Line Separator

Each of these methods uses a <i>line separator</i>,
which is the string that delimits lines:

- ARGF#to_a.
- IO.foreach.
- IO.readlines.
- IO#each_line.
- IO#gets.
- IO#readline.
- IO#readlines.

The default line separator is the given by the global variable <tt>$/</tt>,
whose value is by default <tt>"\n"</tt>.
The line to be read next is all data from the current position
to the next line separator:

  f = File.new('t.txt')
  f.gets # => "First line\n"
  f.gets # => "Second line\n"
  f.gets # => "\n"
  f.gets # => "Fourth line\n"
  f.gets # => "Fifth line\n"
  f.close

You can specify a different line separator:

  f = File.new('t.txt')
  f.gets('l')   # => "First l"
  f.gets('li')  # => "ine\nSecond li"
  f.gets('lin') # => "ne\n\nFourth lin"
  f.gets        # => "e\n"
  f.close

There are two special line separators:

- +nil+: The entire stream is read into a single string:

    f = File.new('t.txt')
    f.gets(nil) # => "First line\nSecond line\n\nFourth line\nFifth line\n"
    f.close

- <tt>''</tt> (the empty string): The next "paragraph" is read
  (paragraphs being separated by two consecutive line separators):

    f = File.new('t.txt')
    f.gets('') # => "First line\nSecond line\n\n"
    f.gets('') # => "Fourth line\nFifth line\n"
    f.close

==== Line Limit

Each of these methods uses a <i>line limit</i>,
which specifies that the number of bytes returned may not be (much) longer
than the given +limit+;

- ARGF#to_a.
- IO.foreach.
- IO.readlines.
- IO#each_line.
- IO#gets.
- IO#readline.
- IO#readlines.

A multi-byte character will not be split, and so a line may be slightly longer
than the given limit.

If +limit+ is not given, the line is determined only by +sep+.

  # Text with 1-byte characters.
  File.open('t.txt') {|f| f.gets(1) }  # => "F"
  File.open('t.txt') {|f| f.gets(2) }  # => "Fi"
  File.open('t.txt') {|f| f.gets(3) }  # => "Fir"
  File.open('t.txt') {|f| f.gets(4) }  # => "Firs"
  # No more than one line.
  File.open('t.txt') {|f| f.gets(10) } # => "First line"
  File.open('t.txt') {|f| f.gets(11) } # => "First line\n"
  File.open('t.txt') {|f| f.gets(12) } # => "First line\n"

  # Text with 2-byte characters, which will not be split.
  File.open('t.rus') {|f| f.gets(1).size } # => 1
  File.open('t.rus') {|f| f.gets(2).size } # => 1
  File.open('t.rus') {|f| f.gets(3).size } # => 2
  File.open('t.rus') {|f| f.gets(4).size } # => 2

==== Line Separator and Line Limit

With arguments +sep+ and +limit+ given,
combines the two behaviors:

- Returns the next line as determined by line separator +sep+.
- But returns no more bytes than are allowed by the limit.

Example:

  File.open('t.txt') {|f| f.gets('li', 20) } # => "First li"
  File.open('t.txt') {|f| f.gets('li', 2) }  # => "Fi"

==== Line Number

A readable \IO stream has a non-negative integer <i>line number</i>.

The relevant methods:

- IO#lineno: Returns the line number.
- IO#lineno=: Resets and returns the line number.

Unless modified by a call to method IO#lineno=,
the line number is the number of lines read
by certain line-oriented methods,
according to the given line separator +sep+:

- IO.foreach: Increments the line number on each call to the block.
- IO#each_line: Increments the line number on each call to the block.
- IO#gets: Increments the line number.
- IO#readline: Increments the line number.
- IO#readlines: Increments the line number for each line read.

A new stream is initially has line number zero (and position zero);
method +rewind+ resets the line number (and position) to zero:

  f = File.new('t.txt')
  f.lineno # => 0
  f.gets   # => "First line\n"
  f.lineno # => 1
  f.rewind
  f.lineno # => 0
  f.close

Reading lines from a stream usually changes its line number:

  f = File.new('t.txt', 'r')
  f.lineno   # => 0
  f.readline # => "This is line one.\n"
  f.lineno   # => 1
  f.readline # => "This is the second line.\n"
  f.lineno   # => 2
  f.readline # => "Here's the third line.\n"
  f.lineno   # => 3
  f.eof?     # => true
  f.close

Iterating over lines in a stream usually changes its line number:

  File.open('t.txt') do |f|
    f.each_line do |line|
      p "position=#{f.pos} eof?=#{f.eof?} lineno=#{f.lineno}"
    end
  end

Output:

  "position=11 eof?=false lineno=1"
  "position=23 eof?=false lineno=2"
  "position=24 eof?=false lineno=3"
  "position=36 eof?=false lineno=4"
  "position=47 eof?=true lineno=5"

Unlike the stream's {position}[rdoc-ref:io_streams.rdoc@Position],
the line number does not affect where the next read or write will occur:

  f = File.new('t.txt')
  f.lineno = 1000
  f.lineno # => 1000
  f.gets   # => "First line\n"
  f.lineno # => 1001
  f.close

Associated with the line number is the global variable <tt>$.</tt>:

- When a stream is opened, <tt>$.</tt> is not set;
  its value is left over from previous activity in the process:

    $. = 41
    f = File.new('t.txt')
    $. = 41
    # => 41
    f.close

- When a stream is read, <tt>#.</tt> is set to the line number for that stream:

    f0 = File.new('t.txt')
    f1 = File.new('t.dat')
    f0.readlines # => ["First line\n", "Second line\n", "\n", "Fourth line\n", "Fifth line\n"]
    $.           # => 5
    f1.readlines # => ["\xFE\xFF\x99\x90\x99\x91\x99\x92\x99\x93\x99\x94"]
    $.           # => 1
    f0.close
    f1.close

- Methods IO#rewind and IO#seek do not affect <tt>$.</tt>:

    f = File.new('t.txt')
    f.readlines # => ["First line\n", "Second line\n", "\n", "Fourth line\n", "Fifth line\n"]
    $.          # => 5
    f.rewind
    f.seek(0, :SET)
    $.          # => 5
    f.close

=== Character \IO

You can process an \IO stream character-by-character using these methods:

- IO#getc: Reads and returns the next character from the stream.
- IO#readchar (not in \StringIO):
  Like #getc, but raises an exception at end-of-stream.
- IO#ungetc (not in \ARGF):
  Pushes back ("unshifts") a character or integer onto the stream.
- IO#putc (also in Kernel): Writes a character to the stream.
- IO#each_char: Reads each remaining character in the stream,
  passing the character to the given block.
=== Byte \IO

You can process an \IO stream byte-by-byte using these methods:

- IO#getbyte: Returns the next 8-bit byte as an integer in range 0..255.
- IO#readbyte (not in \StringIO):
  Like #getbyte, but raises an exception if at end-of-stream.
- IO#ungetbyte (not in \ARGF):
  Pushes back ("unshifts") a byte back onto the stream.
- IO#each_byte: Reads each remaining byte in the stream,
  passing the byte to the given block.

=== Codepoint \IO

You can process an \IO stream codepoint-by-codepoint:

- IO#each_codepoint: Reads each remaining codepoint, passing it to the given block.

