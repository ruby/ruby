/******************************************************************************/
/* This file is generated by the bin/template script and should not be        */
/* modified manually.                                                         */
/******************************************************************************/

#ifndef YARP_AST_H
#define YARP_AST_H

#include <stddef.h>
#include <stdint.h>
#include "util/yp_string.h"

// This enum represents every type of token in the Ruby source.
typedef enum yp_token_type {
  YP_TOKEN_EOF = 0, // final token in the file
  YP_TOKEN_MISSING, // a token that was expected but not found
  YP_TOKEN_NOT_PROVIDED, // a token that was not present but it is okay
  YP_TOKEN_AMPERSAND, // &
  YP_TOKEN_AMPERSAND_AMPERSAND, // &&
  YP_TOKEN_AMPERSAND_AMPERSAND_EQUAL, // &&=
  YP_TOKEN_AMPERSAND_DOT, // &.
  YP_TOKEN_AMPERSAND_EQUAL, // &=
  YP_TOKEN_BACKTICK, // `
  YP_TOKEN_BACK_REFERENCE, // a back reference
  YP_TOKEN_BANG, // ! or !@
  YP_TOKEN_BANG_EQUAL, // !=
  YP_TOKEN_BANG_TILDE, // !~
  YP_TOKEN_BRACE_LEFT, // {
  YP_TOKEN_BRACE_RIGHT, // }
  YP_TOKEN_BRACKET_LEFT, // [
  YP_TOKEN_BRACKET_LEFT_ARRAY, // [ for the beginning of an array
  YP_TOKEN_BRACKET_LEFT_RIGHT, // []
  YP_TOKEN_BRACKET_LEFT_RIGHT_EQUAL, // []=
  YP_TOKEN_BRACKET_RIGHT, // ]
  YP_TOKEN_CARET, // ^
  YP_TOKEN_CARET_EQUAL, // ^=
  YP_TOKEN_CHARACTER_LITERAL, // a character literal
  YP_TOKEN_CLASS_VARIABLE, // a class variable
  YP_TOKEN_COLON, // :
  YP_TOKEN_COLON_COLON, // ::
  YP_TOKEN_COMMA, // ,
  YP_TOKEN_COMMENT, // a comment
  YP_TOKEN_CONSTANT, // a constant
  YP_TOKEN_DOT, // .
  YP_TOKEN_DOT_DOT, // ..
  YP_TOKEN_DOT_DOT_DOT, // ...
  YP_TOKEN_EMBDOC_BEGIN, // =begin
  YP_TOKEN_EMBDOC_END, // =end
  YP_TOKEN_EMBDOC_LINE, // a line inside of embedded documentation
  YP_TOKEN_EMBEXPR_BEGIN, // #{
  YP_TOKEN_EMBEXPR_END, // }
  YP_TOKEN_EMBVAR, // #
  YP_TOKEN_EQUAL, // =
  YP_TOKEN_EQUAL_EQUAL, // ==
  YP_TOKEN_EQUAL_EQUAL_EQUAL, // ===
  YP_TOKEN_EQUAL_GREATER, // =>
  YP_TOKEN_EQUAL_TILDE, // =~
  YP_TOKEN_FLOAT, // a floating point number
  YP_TOKEN_GLOBAL_VARIABLE, // a global variable
  YP_TOKEN_GREATER, // >
  YP_TOKEN_GREATER_EQUAL, // >=
  YP_TOKEN_GREATER_GREATER, // >>
  YP_TOKEN_GREATER_GREATER_EQUAL, // >>=
  YP_TOKEN_HEREDOC_END, // the end of a heredoc
  YP_TOKEN_HEREDOC_START, // the start of a heredoc
  YP_TOKEN_IDENTIFIER, // an identifier
  YP_TOKEN_IGNORED_NEWLINE, // an ignored newline
  YP_TOKEN_IMAGINARY_NUMBER, // an imaginary number literal
  YP_TOKEN_INSTANCE_VARIABLE, // an instance variable
  YP_TOKEN_INTEGER, // an integer (any base)
  YP_TOKEN_KEYWORD_ALIAS, // alias
  YP_TOKEN_KEYWORD_AND, // and
  YP_TOKEN_KEYWORD_BEGIN, // begin
  YP_TOKEN_KEYWORD_BEGIN_UPCASE, // BEGIN
  YP_TOKEN_KEYWORD_BREAK, // break
  YP_TOKEN_KEYWORD_CASE, // case
  YP_TOKEN_KEYWORD_CLASS, // class
  YP_TOKEN_KEYWORD_DEF, // def
  YP_TOKEN_KEYWORD_DEFINED, // defined?
  YP_TOKEN_KEYWORD_DO, // do
  YP_TOKEN_KEYWORD_DO_LOOP, // do keyword for a predicate in a while, until, or for loop
  YP_TOKEN_KEYWORD_ELSE, // else
  YP_TOKEN_KEYWORD_ELSIF, // elsif
  YP_TOKEN_KEYWORD_END, // end
  YP_TOKEN_KEYWORD_END_UPCASE, // END
  YP_TOKEN_KEYWORD_ENSURE, // ensure
  YP_TOKEN_KEYWORD_FALSE, // false
  YP_TOKEN_KEYWORD_FOR, // for
  YP_TOKEN_KEYWORD_IF, // if
  YP_TOKEN_KEYWORD_IF_MODIFIER, // if in the modifier form
  YP_TOKEN_KEYWORD_IN, // in
  YP_TOKEN_KEYWORD_MODULE, // module
  YP_TOKEN_KEYWORD_NEXT, // next
  YP_TOKEN_KEYWORD_NIL, // nil
  YP_TOKEN_KEYWORD_NOT, // not
  YP_TOKEN_KEYWORD_OR, // or
  YP_TOKEN_KEYWORD_REDO, // redo
  YP_TOKEN_KEYWORD_RESCUE, // rescue
  YP_TOKEN_KEYWORD_RESCUE_MODIFIER, // rescue in the modifier form
  YP_TOKEN_KEYWORD_RETRY, // retry
  YP_TOKEN_KEYWORD_RETURN, // return
  YP_TOKEN_KEYWORD_SELF, // self
  YP_TOKEN_KEYWORD_SUPER, // super
  YP_TOKEN_KEYWORD_THEN, // then
  YP_TOKEN_KEYWORD_TRUE, // true
  YP_TOKEN_KEYWORD_UNDEF, // undef
  YP_TOKEN_KEYWORD_UNLESS, // unless
  YP_TOKEN_KEYWORD_UNLESS_MODIFIER, // unless in the modifier form
  YP_TOKEN_KEYWORD_UNTIL, // until
  YP_TOKEN_KEYWORD_UNTIL_MODIFIER, // until in the modifier form
  YP_TOKEN_KEYWORD_WHEN, // when
  YP_TOKEN_KEYWORD_WHILE, // while
  YP_TOKEN_KEYWORD_WHILE_MODIFIER, // while in the modifier form
  YP_TOKEN_KEYWORD_YIELD, // yield
  YP_TOKEN_KEYWORD___ENCODING__, // __ENCODING__
  YP_TOKEN_KEYWORD___FILE__, // __FILE__
  YP_TOKEN_KEYWORD___LINE__, // __LINE__
  YP_TOKEN_LABEL, // a label
  YP_TOKEN_LABEL_END, // the end of a label
  YP_TOKEN_LAMBDA_BEGIN, // {
  YP_TOKEN_LESS, // <
  YP_TOKEN_LESS_EQUAL, // <=
  YP_TOKEN_LESS_EQUAL_GREATER, // <=>
  YP_TOKEN_LESS_LESS, // <<
  YP_TOKEN_LESS_LESS_EQUAL, // <<=
  YP_TOKEN_MINUS, // -
  YP_TOKEN_MINUS_EQUAL, // -=
  YP_TOKEN_MINUS_GREATER, // ->
  YP_TOKEN_NEWLINE, // a newline character outside of other tokens
  YP_TOKEN_NTH_REFERENCE, // an nth global variable reference
  YP_TOKEN_PARENTHESIS_LEFT, // (
  YP_TOKEN_PARENTHESIS_LEFT_PARENTHESES, // ( for a parentheses node
  YP_TOKEN_PARENTHESIS_RIGHT, // )
  YP_TOKEN_PERCENT, // %
  YP_TOKEN_PERCENT_EQUAL, // %=
  YP_TOKEN_PERCENT_LOWER_I, // %i
  YP_TOKEN_PERCENT_LOWER_W, // %w
  YP_TOKEN_PERCENT_LOWER_X, // %x
  YP_TOKEN_PERCENT_UPPER_I, // %I
  YP_TOKEN_PERCENT_UPPER_W, // %W
  YP_TOKEN_PIPE, // |
  YP_TOKEN_PIPE_EQUAL, // |=
  YP_TOKEN_PIPE_PIPE, // ||
  YP_TOKEN_PIPE_PIPE_EQUAL, // ||=
  YP_TOKEN_PLUS, // +
  YP_TOKEN_PLUS_EQUAL, // +=
  YP_TOKEN_QUESTION_MARK, // ?
  YP_TOKEN_RATIONAL_NUMBER, // a rational number literal
  YP_TOKEN_REGEXP_BEGIN, // the beginning of a regular expression
  YP_TOKEN_REGEXP_END, // the end of a regular expression
  YP_TOKEN_SEMICOLON, // ;
  YP_TOKEN_SLASH, // /
  YP_TOKEN_SLASH_EQUAL, // /=
  YP_TOKEN_STAR, // *
  YP_TOKEN_STAR_EQUAL, // *=
  YP_TOKEN_STAR_STAR, // **
  YP_TOKEN_STAR_STAR_EQUAL, // **=
  YP_TOKEN_STRING_BEGIN, // the beginning of a string
  YP_TOKEN_STRING_CONTENT, // the contents of a string
  YP_TOKEN_STRING_END, // the end of a string
  YP_TOKEN_SYMBOL_BEGIN, // the beginning of a symbol
  YP_TOKEN_TILDE, // ~ or ~@
  YP_TOKEN_UCOLON_COLON, // unary ::
  YP_TOKEN_UDOT_DOT, // unary ..
  YP_TOKEN_UDOT_DOT_DOT, // unary ...
  YP_TOKEN_UMINUS, // -@
  YP_TOKEN_UPLUS, // +@
  YP_TOKEN_USTAR, // unary *
  YP_TOKEN_WORDS_SEP, // a separator between words in a list
  YP_TOKEN___END__, // marker for the point in the file at which the parser should stop
  YP_TOKEN_MAXIMUM, // the maximum token value
} yp_token_type_t;

// This struct represents a token in the Ruby source. We use it to track both
// type and location information.
typedef struct {
  yp_token_type_t type;
  const char *start;
  const char *end;
} yp_token_t;

typedef struct {
  yp_token_t *tokens;
  size_t size;
  size_t capacity;
} yp_token_list_t;

struct yp_node;

typedef struct yp_node_list {
  struct yp_node **nodes;
  size_t size;
  size_t capacity;
} yp_node_list_t;

typedef enum {
  YP_NODE_ALIAS_NODE = 0,
  YP_NODE_AND_NODE = 1,
  YP_NODE_ARGUMENTS_NODE = 2,
  YP_NODE_ARRAY_NODE = 3,
  YP_NODE_ASSOC_NODE = 4,
  YP_NODE_ASSOC_SPLAT_NODE = 5,
  YP_NODE_BEGIN_NODE = 6,
  YP_NODE_BLOCK_ARGUMENT_NODE = 7,
  YP_NODE_BLOCK_NODE = 8,
  YP_NODE_BLOCK_PARAMETER_NODE = 9,
  YP_NODE_BLOCK_PARAMETERS_NODE = 10,
  YP_NODE_BREAK_NODE = 11,
  YP_NODE_CALL_NODE = 12,
  YP_NODE_CASE_NODE = 13,
  YP_NODE_CLASS_NODE = 14,
  YP_NODE_CLASS_VARIABLE_READ_NODE = 15,
  YP_NODE_CLASS_VARIABLE_WRITE_NODE = 16,
  YP_NODE_CONSTANT_PATH_NODE = 17,
  YP_NODE_CONSTANT_PATH_WRITE_NODE = 18,
  YP_NODE_CONSTANT_READ_NODE = 19,
  YP_NODE_DEF_NODE = 20,
  YP_NODE_DEFINED_NODE = 21,
  YP_NODE_ELSE_NODE = 22,
  YP_NODE_ENSURE_NODE = 23,
  YP_NODE_FALSE_NODE = 24,
  YP_NODE_FLOAT_NODE = 25,
  YP_NODE_FOR_NODE = 26,
  YP_NODE_FORWARDING_ARGUMENTS_NODE = 27,
  YP_NODE_FORWARDING_PARAMETER_NODE = 28,
  YP_NODE_FORWARDING_SUPER_NODE = 29,
  YP_NODE_GLOBAL_VARIABLE_READ_NODE = 30,
  YP_NODE_GLOBAL_VARIABLE_WRITE_NODE = 31,
  YP_NODE_HASH_NODE = 32,
  YP_NODE_HEREDOC_NODE = 33,
  YP_NODE_IF_NODE = 34,
  YP_NODE_IMAGINARY_NODE = 35,
  YP_NODE_INSTANCE_VARIABLE_READ_NODE = 36,
  YP_NODE_INSTANCE_VARIABLE_WRITE_NODE = 37,
  YP_NODE_INTEGER_NODE = 38,
  YP_NODE_INTERPOLATED_REGULAR_EXPRESSION_NODE = 39,
  YP_NODE_INTERPOLATED_STRING_NODE = 40,
  YP_NODE_INTERPOLATED_SYMBOL_NODE = 41,
  YP_NODE_INTERPOLATED_X_STRING_NODE = 42,
  YP_NODE_KEYWORD_PARAMETER_NODE = 43,
  YP_NODE_KEYWORD_REST_PARAMETER_NODE = 44,
  YP_NODE_KEYWORD_STAR_NODE = 45,
  YP_NODE_LAMBDA_NODE = 46,
  YP_NODE_LOCAL_VARIABLE_READ_NODE = 47,
  YP_NODE_LOCAL_VARIABLE_WRITE_NODE = 48,
  YP_NODE_MISSING_NODE = 49,
  YP_NODE_MODULE_NODE = 50,
  YP_NODE_MULTI_WRITE_NODE = 51,
  YP_NODE_NEXT_NODE = 52,
  YP_NODE_NIL_NODE = 53,
  YP_NODE_NO_KEYWORDS_PARAMETER_NODE = 54,
  YP_NODE_OPERATOR_AND_ASSIGNMENT_NODE = 55,
  YP_NODE_OPERATOR_ASSIGNMENT_NODE = 56,
  YP_NODE_OPERATOR_OR_ASSIGNMENT_NODE = 57,
  YP_NODE_OPTIONAL_PARAMETER_NODE = 58,
  YP_NODE_OR_NODE = 59,
  YP_NODE_PARAMETERS_NODE = 60,
  YP_NODE_PARENTHESES_NODE = 61,
  YP_NODE_POST_EXECUTION_NODE = 62,
  YP_NODE_PRE_EXECUTION_NODE = 63,
  YP_NODE_PROGRAM_NODE = 64,
  YP_NODE_RANGE_NODE = 65,
  YP_NODE_RATIONAL_NODE = 66,
  YP_NODE_REDO_NODE = 67,
  YP_NODE_REGULAR_EXPRESSION_NODE = 68,
  YP_NODE_REQUIRED_DESTRUCTURED_PARAMETER_NODE = 69,
  YP_NODE_REQUIRED_PARAMETER_NODE = 70,
  YP_NODE_RESCUE_MODIFIER_NODE = 71,
  YP_NODE_RESCUE_NODE = 72,
  YP_NODE_REST_PARAMETER_NODE = 73,
  YP_NODE_RETRY_NODE = 74,
  YP_NODE_RETURN_NODE = 75,
  YP_NODE_SCOPE = 76,
  YP_NODE_SELF_NODE = 77,
  YP_NODE_SINGLETON_CLASS_NODE = 78,
  YP_NODE_SOURCE_ENCODING_NODE = 79,
  YP_NODE_SOURCE_FILE_NODE = 80,
  YP_NODE_SOURCE_LINE_NODE = 81,
  YP_NODE_SPLAT_NODE = 82,
  YP_NODE_STATEMENTS_NODE = 83,
  YP_NODE_STRING_CONCAT_NODE = 84,
  YP_NODE_STRING_INTERPOLATED_NODE = 85,
  YP_NODE_STRING_NODE = 86,
  YP_NODE_SUPER_NODE = 87,
  YP_NODE_SYMBOL_NODE = 88,
  YP_NODE_TERNARY_NODE = 89,
  YP_NODE_TRUE_NODE = 90,
  YP_NODE_UNDEF_NODE = 91,
  YP_NODE_UNLESS_NODE = 92,
  YP_NODE_UNTIL_NODE = 93,
  YP_NODE_WHEN_NODE = 94,
  YP_NODE_WHILE_NODE = 95,
  YP_NODE_X_STRING_NODE = 96,
  YP_NODE_YIELD_NODE = 97,
} yp_node_type_t;

// This represents a range of bytes in the source string to which a node or
// token corresponds.
typedef struct {
  const char *start;
  const char *end;
} yp_location_t;

// This is the overall tagged union representing a node in the syntax tree.
typedef struct yp_node {
  // This represents the type of the node. It somewhat maps to the nodes that
  // existed in the original grammar and ripper, but it's not a 1:1 mapping.
  yp_node_type_t type;

  // This is the location of the node in the source. It's a range of bytes
  // containing a start and an end.
  yp_location_t location;

  // Every entry in this union is a different kind of node in the tree. For
  // the most part they only contain one or two child nodes, except for the
  // more complicated nodes like params. There may be an opportunity for
  // optimization here by combining node types that share the same shape, but
  // it might not end up mattering in the final compiled code.
  union {
    // AliasNode
    struct {
      struct yp_node *new_name;
      struct yp_node *old_name;
      yp_location_t keyword_loc;
    } alias_node;

    // AndNode
    struct {
      struct yp_node *left;
      struct yp_node *right;
      yp_token_t operator;
    } and_node;

    // ArgumentsNode
    struct {
      struct yp_node_list arguments;
    } arguments_node;

    // ArrayNode
    struct {
      struct yp_node_list elements;
      yp_token_t opening;
      yp_token_t closing;
    } array_node;

    // AssocNode
    struct {
      struct yp_node *key;
      struct yp_node *value;
      yp_token_t operator;
    } assoc_node;

    // AssocSplatNode
    struct {
      struct yp_node *value;
      yp_location_t operator_loc;
    } assoc_splat_node;

    // BeginNode
    struct {
      yp_token_t begin_keyword;
      struct yp_node *statements;
      struct yp_node *rescue_clause;
      struct yp_node *else_clause;
      struct yp_node *ensure_clause;
      yp_token_t end_keyword;
    } begin_node;

    // BlockArgumentNode
    struct {
      struct yp_node *expression;
      yp_location_t operator_loc;
    } block_argument_node;

    // BlockNode
    struct {
      struct yp_node *scope;
      struct yp_node *parameters;
      struct yp_node *statements;
      yp_location_t opening_loc;
      yp_location_t closing_loc;
    } block_node;

    // BlockParameterNode
    struct {
      yp_token_t name;
      yp_location_t operator_loc;
    } block_parameter_node;

    // BlockParametersNode
    struct {
      struct yp_node *parameters;
      yp_token_list_t locals;
    } block_parameters_node;

    // BreakNode
    struct {
      struct yp_node *arguments;
      yp_location_t keyword_loc;
    } break_node;

    // CallNode
    struct {
      struct yp_node *receiver;
      yp_token_t call_operator;
      yp_token_t message;
      yp_token_t opening;
      struct yp_node *arguments;
      yp_token_t closing;
      struct yp_node *block;
      yp_string_t name;
    } call_node;

    // CaseNode
    struct {
      struct yp_node *predicate;
      struct yp_node_list conditions;
      struct yp_node *consequent;
      yp_location_t case_keyword_loc;
      yp_location_t end_keyword_loc;
    } case_node;

    // ClassNode
    struct {
      struct yp_node *scope;
      yp_token_t class_keyword;
      struct yp_node *constant_path;
      yp_token_t inheritance_operator;
      struct yp_node *superclass;
      struct yp_node *statements;
      yp_token_t end_keyword;
    } class_node;

    // ClassVariableReadNode
    struct {
    } class_variable_read_node;

    // ClassVariableWriteNode
    struct {
      yp_location_t name_loc;
      struct yp_node *value;
      yp_location_t operator_loc;
    } class_variable_write_node;

    // ConstantPathNode
    struct {
      struct yp_node *parent;
      yp_token_t delimiter;
      struct yp_node *child;
    } constant_path_node;

    // ConstantPathWriteNode
    struct {
      struct yp_node *target;
      yp_token_t operator;
      struct yp_node *value;
    } constant_path_write_node;

    // ConstantReadNode
    struct {
    } constant_read_node;

    // DefNode
    struct {
      yp_token_t name;
      struct yp_node *receiver;
      struct yp_node *parameters;
      struct yp_node *statements;
      struct yp_node *scope;
      yp_location_t def_keyword_loc;
      yp_location_t operator_loc;
      yp_location_t lparen_loc;
      yp_location_t rparen_loc;
      yp_location_t equal_loc;
      yp_location_t end_keyword_loc;
    } def_node;

    // DefinedNode
    struct {
      yp_token_t lparen;
      struct yp_node *value;
      yp_token_t rparen;
      yp_location_t keyword_loc;
    } defined_node;

    // ElseNode
    struct {
      yp_token_t else_keyword;
      struct yp_node *statements;
      yp_token_t end_keyword;
    } else_node;

    // EnsureNode
    struct {
      yp_token_t ensure_keyword;
      struct yp_node *statements;
      yp_token_t end_keyword;
    } ensure_node;

    // FalseNode
    struct {
    } false_node;

    // FloatNode
    struct {
    } float_node;

    // ForNode
    struct {
      struct yp_node *index;
      struct yp_node *collection;
      struct yp_node *statements;
      yp_location_t for_keyword_loc;
      yp_location_t in_keyword_loc;
      yp_location_t do_keyword_loc;
      yp_location_t end_keyword_loc;
    } for_node;

    // ForwardingArgumentsNode
    struct {
    } forwarding_arguments_node;

    // ForwardingParameterNode
    struct {
    } forwarding_parameter_node;

    // ForwardingSuperNode
    struct {
      struct yp_node *block;
    } forwarding_super_node;

    // GlobalVariableReadNode
    struct {
      yp_token_t name;
    } global_variable_read_node;

    // GlobalVariableWriteNode
    struct {
      yp_token_t name;
      yp_token_t operator;
      struct yp_node *value;
    } global_variable_write_node;

    // HashNode
    struct {
      yp_token_t opening;
      struct yp_node_list elements;
      yp_token_t closing;
    } hash_node;

    // HeredocNode
    struct {
      yp_token_t opening;
      struct yp_node_list parts;
      yp_token_t closing;
      int dedent;
    } heredoc_node;

    // IfNode
    struct {
      yp_token_t if_keyword;
      struct yp_node *predicate;
      struct yp_node *statements;
      struct yp_node *consequent;
      yp_token_t end_keyword;
    } if_node;

    // ImaginaryNode
    struct {
    } imaginary_node;

    // InstanceVariableReadNode
    struct {
    } instance_variable_read_node;

    // InstanceVariableWriteNode
    struct {
      yp_location_t name_loc;
      struct yp_node *value;
      yp_location_t operator_loc;
    } instance_variable_write_node;

    // IntegerNode
    struct {
    } integer_node;

    // InterpolatedRegularExpressionNode
    struct {
      yp_token_t opening;
      struct yp_node_list parts;
      yp_token_t closing;
    } interpolated_regular_expression_node;

    // InterpolatedStringNode
    struct {
      yp_token_t opening;
      struct yp_node_list parts;
      yp_token_t closing;
    } interpolated_string_node;

    // InterpolatedSymbolNode
    struct {
      yp_token_t opening;
      struct yp_node_list parts;
      yp_token_t closing;
    } interpolated_symbol_node;

    // InterpolatedXStringNode
    struct {
      yp_token_t opening;
      struct yp_node_list parts;
      yp_token_t closing;
    } interpolated_x_string_node;

    // KeywordParameterNode
    struct {
      yp_token_t name;
      struct yp_node *value;
    } keyword_parameter_node;

    // KeywordRestParameterNode
    struct {
      yp_token_t operator;
      yp_token_t name;
    } keyword_rest_parameter_node;

    // KeywordStarNode
    struct {
      yp_token_t operator;
      struct yp_node *expression;
    } keyword_star_node;

    // LambdaNode
    struct {
      struct yp_node *scope;
      yp_token_t lparen;
      struct yp_node *parameters;
      yp_token_t rparen;
      struct yp_node *statements;
    } lambda_node;

    // LocalVariableReadNode
    struct {
      yp_token_t name;
      int depth;
    } local_variable_read_node;

    // LocalVariableWriteNode
    struct {
      yp_token_t name;
      yp_token_t operator;
      struct yp_node *value;
      int depth;
    } local_variable_write_node;

    // MissingNode
    struct {
    } missing_node;

    // ModuleNode
    struct {
      struct yp_node *scope;
      yp_token_t module_keyword;
      struct yp_node *constant_path;
      struct yp_node *statements;
      yp_token_t end_keyword;
    } module_node;

    // MultiWriteNode
    struct {
      struct yp_node_list targets;
      yp_token_t operator;
      struct yp_node *value;
      yp_location_t lparen_loc;
      yp_location_t rparen_loc;
    } multi_write_node;

    // NextNode
    struct {
      struct yp_node *arguments;
      yp_location_t keyword_loc;
    } next_node;

    // NilNode
    struct {
    } nil_node;

    // NoKeywordsParameterNode
    struct {
      yp_location_t operator_loc;
      yp_location_t keyword_loc;
    } no_keywords_parameter_node;

    // OperatorAndAssignmentNode
    struct {
      struct yp_node *target;
      struct yp_node *value;
      yp_location_t operator_loc;
    } operator_and_assignment_node;

    // OperatorAssignmentNode
    struct {
      struct yp_node *target;
      yp_token_t operator;
      struct yp_node *value;
    } operator_assignment_node;

    // OperatorOrAssignmentNode
    struct {
      struct yp_node *target;
      struct yp_node *value;
      yp_location_t operator_loc;
    } operator_or_assignment_node;

    // OptionalParameterNode
    struct {
      yp_token_t name;
      yp_token_t equal_operator;
      struct yp_node *value;
    } optional_parameter_node;

    // OrNode
    struct {
      struct yp_node *left;
      struct yp_node *right;
      yp_location_t operator_loc;
    } or_node;

    // ParametersNode
    struct {
      struct yp_node_list requireds;
      struct yp_node_list optionals;
      struct yp_node *rest;
      struct yp_node_list keywords;
      struct yp_node *keyword_rest;
      struct yp_node *block;
    } parameters_node;

    // ParenthesesNode
    struct {
      struct yp_node *statements;
      yp_location_t opening_loc;
      yp_location_t closing_loc;
    } parentheses_node;

    // PostExecutionNode
    struct {
      struct yp_node *statements;
      yp_location_t keyword_loc;
      yp_location_t opening_loc;
      yp_location_t closing_loc;
    } post_execution_node;

    // PreExecutionNode
    struct {
      struct yp_node *statements;
      yp_location_t keyword_loc;
      yp_location_t opening_loc;
      yp_location_t closing_loc;
    } pre_execution_node;

    // ProgramNode
    struct {
      struct yp_node *scope;
      struct yp_node *statements;
    } program_node;

    // RangeNode
    struct {
      struct yp_node *left;
      struct yp_node *right;
      yp_location_t operator_loc;
    } range_node;

    // RationalNode
    struct {
    } rational_node;

    // RedoNode
    struct {
    } redo_node;

    // RegularExpressionNode
    struct {
      yp_token_t opening;
      yp_token_t content;
      yp_token_t closing;
      yp_string_t unescaped;
    } regular_expression_node;

    // RequiredDestructuredParameterNode
    struct {
      struct yp_node_list parameters;
      yp_token_t opening;
      yp_token_t closing;
    } required_destructured_parameter_node;

    // RequiredParameterNode
    struct {
      yp_token_t name;
    } required_parameter_node;

    // RescueModifierNode
    struct {
      struct yp_node *expression;
      yp_token_t rescue_keyword;
      struct yp_node *rescue_expression;
    } rescue_modifier_node;

    // RescueNode
    struct {
      yp_token_t rescue_keyword;
      struct yp_node_list exceptions;
      yp_token_t equal_greater;
      struct yp_node *exception;
      struct yp_node *statements;
      struct yp_node *consequent;
    } rescue_node;

    // RestParameterNode
    struct {
      yp_token_t operator;
      yp_token_t name;
    } rest_parameter_node;

    // RetryNode
    struct {
    } retry_node;

    // ReturnNode
    struct {
      yp_token_t keyword;
      struct yp_node *arguments;
    } return_node;

    // Scope
    struct {
      yp_token_list_t locals;
    } scope;

    // SelfNode
    struct {
    } self_node;

    // SingletonClassNode
    struct {
      struct yp_node *scope;
      yp_token_t class_keyword;
      yp_token_t operator;
      struct yp_node *expression;
      struct yp_node *statements;
      yp_token_t end_keyword;
    } singleton_class_node;

    // SourceEncodingNode
    struct {
    } source_encoding_node;

    // SourceFileNode
    struct {
    } source_file_node;

    // SourceLineNode
    struct {
    } source_line_node;

    // SplatNode
    struct {
      yp_token_t operator;
      struct yp_node *expression;
    } splat_node;

    // StatementsNode
    struct {
      struct yp_node_list body;
    } statements_node;

    // StringConcatNode
    struct {
      struct yp_node *left;
      struct yp_node *right;
    } string_concat_node;

    // StringInterpolatedNode
    struct {
      yp_token_t opening;
      struct yp_node *statements;
      yp_token_t closing;
    } string_interpolated_node;

    // StringNode
    struct {
      yp_token_t opening;
      yp_token_t content;
      yp_token_t closing;
      yp_string_t unescaped;
    } string_node;

    // SuperNode
    struct {
      yp_token_t keyword;
      yp_token_t lparen;
      struct yp_node *arguments;
      yp_token_t rparen;
      struct yp_node *block;
    } super_node;

    // SymbolNode
    struct {
      yp_token_t opening;
      yp_token_t value;
      yp_token_t closing;
      yp_string_t unescaped;
    } symbol_node;

    // TernaryNode
    struct {
      struct yp_node *predicate;
      yp_token_t question_mark;
      struct yp_node *true_expression;
      yp_token_t colon;
      struct yp_node *false_expression;
    } ternary_node;

    // TrueNode
    struct {
    } true_node;

    // UndefNode
    struct {
      struct yp_node_list names;
      yp_location_t keyword_loc;
    } undef_node;

    // UnlessNode
    struct {
      yp_token_t keyword;
      struct yp_node *predicate;
      struct yp_node *statements;
      struct yp_node *consequent;
      yp_token_t end_keyword;
    } unless_node;

    // UntilNode
    struct {
      yp_token_t keyword;
      struct yp_node *predicate;
      struct yp_node *statements;
    } until_node;

    // WhenNode
    struct {
      yp_token_t when_keyword;
      struct yp_node_list conditions;
      struct yp_node *statements;
    } when_node;

    // WhileNode
    struct {
      yp_token_t keyword;
      struct yp_node *predicate;
      struct yp_node *statements;
    } while_node;

    // XStringNode
    struct {
      yp_token_t opening;
      yp_token_t content;
      yp_token_t closing;
      yp_string_t unescaped;
    } x_string_node;

    // YieldNode
    struct {
      yp_token_t keyword;
      yp_token_t lparen;
      struct yp_node *arguments;
      yp_token_t rparen;
    } yield_node;
  } as;
} yp_node_t;

#endif // YARP_AST_H
