/******************************************************************************/
/* This file is generated by the bin/template script and should not be        */
/* modified manually.                                                         */
/******************************************************************************/

#include "node.h"

// Allocate the space for a new yp_node_t. Currently we're not using the
// parser argument, but it's there to allow for the future possibility of
// pre-allocating larger memory pools and then pulling from those here.
static inline yp_node_t *
yp_node_alloc(yp_parser_t *parser) {
  return (yp_node_t *) malloc(sizeof(yp_node_t));
}

// Initialize a yp_token_list_t with its default values.
void
yp_token_list_init(yp_token_list_t *token_list) {
  *token_list = (yp_token_list_t) { .tokens = NULL, .size = 0, .capacity = 0 };
}

// Calculate the size of the token list in bytes.
static size_t
yp_token_list_memsize(yp_token_list_t *token_list) {
  return sizeof(yp_token_list_t) + (token_list->capacity * sizeof(yp_token_t));
}

// Append a token to the given list.
void
yp_token_list_append(yp_token_list_t *token_list, const yp_token_t *token) {
  if (token_list->size == token_list->capacity) {
    token_list->capacity = token_list->capacity == 0 ? 1 : token_list->capacity * 2;
    token_list->tokens = realloc(token_list->tokens, sizeof(yp_token_t) * token_list->capacity);
  }
  token_list->tokens[token_list->size++] = *token;
}

// Checks if the current token list includes the given token.
bool
yp_token_list_includes(yp_token_list_t *token_list, const yp_token_t *token) {
  size_t length = token->end - token->start;

  for (size_t index = 0; index < token_list->size; index++) {
    yp_token_t current_token = token_list->tokens[index];

    if (
      ((current_token.end - current_token.start) == length) &&
      (memcmp(current_token.start, token->start, length) == 0)
    ) {
      return true;
    }
  }
  return false;
}

// Free the memory associated with the token list.
static void
yp_token_list_free(yp_token_list_t *token_list) {
  if (token_list->tokens != NULL) {
    free(token_list->tokens);
  }
}

static void
yp_node_memsize_node(yp_node_t *node, yp_memsize_t *memsize);

// Initiailize a list of nodes.
void
yp_node_list_init(yp_node_list_t *node_list) {
  *node_list = (yp_node_list_t) { .nodes = NULL, .size = 0, .capacity = 0 };
}

// Calculate the size of the node list in bytes.
static size_t
yp_node_list_memsize(yp_node_list_t *node_list, yp_memsize_t *memsize) {
  size_t size = sizeof(yp_node_list_t) + (node_list->capacity * sizeof(yp_node_t *));
  for (size_t index = 0; index < node_list->size; index++) {
    yp_node_memsize_node(node_list->nodes[index], memsize);
  }
  return size;
}

// Append a new node onto the end of the node list.
void
yp_node_list_append(yp_parser_t *parser, yp_node_t *parent, yp_node_list_t *list, yp_node_t *node) {
  if (list->size == list->capacity) {
    list->capacity = list->capacity == 0 ? 4 : list->capacity * 2;
    list->nodes = realloc(list->nodes, list->capacity * sizeof(yp_node_t *));
  }

  list->nodes[list->size++] = node;

  if (list->size == 1) parent->location.start = node->location.start;
  parent->location.end = node->location.end;
}

__attribute__((__visibility__("default"))) void
yp_node_destroy(yp_parser_t *parser, yp_node_t *node);

// Deallocate the inner memory of a list of nodes. The parser argument is not
// used, but is here for the future possibility of pre-allocating memory pools.
static void
yp_node_list_free(yp_parser_t *parser, yp_node_list_t *list) {
  if (list->capacity > 0) {
    for (size_t index = 0; index < list->size; index++) {
      yp_node_destroy(parser, list->nodes[index]);
    }
    free(list->nodes);
  }
}

// Allocate a new AliasNode node.
yp_node_t *
yp_node_alias_node_create(yp_parser_t *parser, yp_node_t *new_name, yp_node_t *old_name, const yp_location_t *keyword_loc, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_ALIAS_NODE, .location = *location, .as.alias_node = { .new_name = new_name, .old_name = old_name, .keyword_loc = *keyword_loc } };
  return node;
}

// Allocate a new AndNode node.
yp_node_t *
yp_node_and_node_create(yp_parser_t *parser, yp_node_t *left, yp_node_t *right, const yp_token_t *operator, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_AND_NODE, .location = *location, .as.and_node = { .left = left, .right = right, .operator = *operator } };
  return node;
}

// Allocate a new ArgumentsNode node.
yp_node_t *
yp_node_arguments_node_create(yp_parser_t *parser, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_ARGUMENTS_NODE, .location = *location };
  yp_node_list_init(&node->as.arguments_node.arguments);
  return node;
}

// Allocate a new ArrayNode node.
yp_node_t *
yp_node_array_node_create(yp_parser_t *parser, const yp_token_t *opening, const yp_token_t *closing, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_ARRAY_NODE, .location = *location, .as.array_node = { .opening = *opening, .closing = *closing } };
  yp_node_list_init(&node->as.array_node.elements);
  return node;
}

// Allocate a new AssocNode node.
yp_node_t *
yp_node_assoc_node_create(yp_parser_t *parser, yp_node_t *key, yp_node_t *value, const yp_token_t *operator, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_ASSOC_NODE, .location = *location, .as.assoc_node = { .key = key, .value = value, .operator = *operator } };
  return node;
}

// Allocate a new AssocSplatNode node.
yp_node_t *
yp_node_assoc_splat_node_create(yp_parser_t *parser, yp_node_t *value, const yp_location_t *operator_loc, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_ASSOC_SPLAT_NODE, .location = *location, .as.assoc_splat_node = { .value = value, .operator_loc = *operator_loc } };
  return node;
}

// Allocate a new BeginNode node.
yp_node_t *
yp_node_begin_node_create(yp_parser_t *parser, const yp_token_t *begin_keyword, yp_node_t *statements, yp_node_t *rescue_clause, yp_node_t *else_clause, yp_node_t *ensure_clause, const yp_token_t *end_keyword, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_BEGIN_NODE, .location = *location, .as.begin_node = { .begin_keyword = *begin_keyword, .statements = statements, .rescue_clause = rescue_clause, .else_clause = else_clause, .ensure_clause = ensure_clause, .end_keyword = *end_keyword } };
  return node;
}

// Allocate a new BlockArgumentNode node.
yp_node_t *
yp_node_block_argument_node_create(yp_parser_t *parser, yp_node_t *expression, const yp_location_t *operator_loc, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_BLOCK_ARGUMENT_NODE, .location = *location, .as.block_argument_node = { .expression = expression, .operator_loc = *operator_loc } };
  return node;
}

// Allocate a new BlockNode node.
yp_node_t *
yp_node_block_node_create(yp_parser_t *parser, yp_node_t *scope, yp_node_t *parameters, yp_node_t *statements, const yp_location_t *opening_loc, const yp_location_t *closing_loc, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_BLOCK_NODE, .location = *location, .as.block_node = { .scope = scope, .parameters = parameters, .statements = statements, .opening_loc = *opening_loc, .closing_loc = *closing_loc } };
  return node;
}

// Allocate a new BlockParameterNode node.
yp_node_t *
yp_node_block_parameter_node_create(yp_parser_t *parser, const yp_token_t *name, const yp_location_t *operator_loc, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_BLOCK_PARAMETER_NODE, .location = *location, .as.block_parameter_node = { .name = *name, .operator_loc = *operator_loc } };
  return node;
}

// Allocate a new BlockParametersNode node.
yp_node_t *
yp_node_block_parameters_node_create(yp_parser_t *parser, yp_node_t *parameters, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_BLOCK_PARAMETERS_NODE, .location = *location, .as.block_parameters_node = { .parameters = parameters } };
  yp_token_list_init(&node->as.block_parameters_node.locals);
  return node;
}

// Allocate a new BreakNode node.
yp_node_t *
yp_node_break_node_create(yp_parser_t *parser, yp_node_t *arguments, const yp_location_t *keyword_loc, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_BREAK_NODE, .location = *location, .as.break_node = { .arguments = arguments, .keyword_loc = *keyword_loc } };
  return node;
}

// Allocate a new CallNode node.
yp_node_t *
yp_node_call_node_create(yp_parser_t *parser, yp_node_t *receiver, const yp_token_t *call_operator, const yp_token_t *message, const yp_token_t *opening, yp_node_t *arguments, const yp_token_t *closing, yp_node_t *block, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_CALL_NODE, .location = *location, .as.call_node = { .receiver = receiver, .call_operator = *call_operator, .message = *message, .opening = *opening, .arguments = arguments, .closing = *closing, .block = block } };
  return node;
}

// Allocate a new CaseNode node.
yp_node_t *
yp_node_case_node_create(yp_parser_t *parser, yp_node_t *predicate, yp_node_t *consequent, const yp_location_t *case_keyword_loc, const yp_location_t *end_keyword_loc, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_CASE_NODE, .location = *location, .as.case_node = { .predicate = predicate, .consequent = consequent, .case_keyword_loc = *case_keyword_loc, .end_keyword_loc = *end_keyword_loc } };
  yp_node_list_init(&node->as.case_node.conditions);
  return node;
}

// Allocate a new ClassNode node.
yp_node_t *
yp_node_class_node_create(yp_parser_t *parser, yp_node_t *scope, const yp_token_t *class_keyword, yp_node_t *constant_path, const yp_token_t *inheritance_operator, yp_node_t *superclass, yp_node_t *statements, const yp_token_t *end_keyword) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_CLASS_NODE, .location = { .start = class_keyword->start, .end = end_keyword->end }, .as.class_node = { .scope = scope, .class_keyword = *class_keyword, .constant_path = constant_path, .inheritance_operator = *inheritance_operator, .superclass = superclass, .statements = statements, .end_keyword = *end_keyword } };
  return node;
}

// Allocate a new ClassVariableReadNode node.
yp_node_t *
yp_node_class_variable_read_node_create(yp_parser_t *parser, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_CLASS_VARIABLE_READ_NODE, .location = *location };
  return node;
}

// Allocate a new ClassVariableWriteNode node.
yp_node_t *
yp_node_class_variable_write_node_create(yp_parser_t *parser, const yp_location_t *name_loc, yp_node_t *value, const yp_location_t *operator_loc, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_CLASS_VARIABLE_WRITE_NODE, .location = *location, .as.class_variable_write_node = { .name_loc = *name_loc, .value = value, .operator_loc = *operator_loc } };
  return node;
}

// Allocate a new ConstantPathNode node.
yp_node_t *
yp_node_constant_path_node_create(yp_parser_t *parser, yp_node_t *parent, const yp_token_t *delimiter, yp_node_t *child) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_CONSTANT_PATH_NODE, .location = { .start = (parent == NULL ? delimiter->start : parent->location.start), .end = child->location.end }, .as.constant_path_node = { .parent = parent, .delimiter = *delimiter, .child = child } };
  return node;
}

// Allocate a new ConstantPathWriteNode node.
yp_node_t *
yp_node_constant_path_write_node_create(yp_parser_t *parser, yp_node_t *target, const yp_token_t *operator, yp_node_t *value) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_CONSTANT_PATH_WRITE_NODE, .location = { .start = target->location.start, .end = (value == NULL ? target->location.end : value->location.end) }, .as.constant_path_write_node = { .target = target, .operator = *operator, .value = value } };
  return node;
}

// Allocate a new ConstantReadNode node.
yp_node_t *
yp_node_constant_read_node_create(yp_parser_t *parser, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_CONSTANT_READ_NODE, .location = *location };
  return node;
}

// Allocate a new DefNode node.
yp_node_t *
yp_node_def_node_create(yp_parser_t *parser, const yp_token_t *name, yp_node_t *receiver, yp_node_t *parameters, yp_node_t *statements, yp_node_t *scope, const yp_location_t *def_keyword_loc, const yp_location_t *operator_loc, const yp_location_t *lparen_loc, const yp_location_t *rparen_loc, const yp_location_t *equal_loc, const yp_location_t *end_keyword_loc, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_DEF_NODE, .location = *location, .as.def_node = { .name = *name, .receiver = receiver, .parameters = parameters, .statements = statements, .scope = scope, .def_keyword_loc = *def_keyword_loc, .operator_loc = *operator_loc, .lparen_loc = *lparen_loc, .rparen_loc = *rparen_loc, .equal_loc = *equal_loc, .end_keyword_loc = *end_keyword_loc } };
  return node;
}

// Allocate a new DefinedNode node.
yp_node_t *
yp_node_defined_node_create(yp_parser_t *parser, const yp_token_t *lparen, yp_node_t *value, const yp_token_t *rparen, const yp_location_t *keyword_loc) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_DEFINED_NODE, .location = { .start = keyword_loc->start, .end = (rparen->type == YP_TOKEN_NOT_PROVIDED ? value->location.end : rparen->end) }, .as.defined_node = { .lparen = *lparen, .value = value, .rparen = *rparen, .keyword_loc = *keyword_loc } };
  return node;
}

// Allocate a new ElseNode node.
yp_node_t *
yp_node_else_node_create(yp_parser_t *parser, const yp_token_t *else_keyword, yp_node_t *statements, const yp_token_t *end_keyword) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_ELSE_NODE, .location = { .start = else_keyword->start, .end = end_keyword->end }, .as.else_node = { .else_keyword = *else_keyword, .statements = statements, .end_keyword = *end_keyword } };
  return node;
}

// Allocate a new EnsureNode node.
yp_node_t *
yp_node_ensure_node_create(yp_parser_t *parser, const yp_token_t *ensure_keyword, yp_node_t *statements, const yp_token_t *end_keyword) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_ENSURE_NODE, .location = { .start = ensure_keyword->start, .end = end_keyword->end }, .as.ensure_node = { .ensure_keyword = *ensure_keyword, .statements = statements, .end_keyword = *end_keyword } };
  return node;
}

// Allocate a new FalseNode node.
yp_node_t *
yp_node_false_node_create(yp_parser_t *parser, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_FALSE_NODE, .location = *location };
  return node;
}

// Allocate a new FloatNode node.
yp_node_t *
yp_node_float_node_create(yp_parser_t *parser, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_FLOAT_NODE, .location = *location };
  return node;
}

// Allocate a new ForNode node.
yp_node_t *
yp_node_for_node_create(yp_parser_t *parser, yp_node_t *index, yp_node_t *collection, yp_node_t *statements, const yp_location_t *for_keyword_loc, const yp_location_t *in_keyword_loc, const yp_location_t *do_keyword_loc, const yp_location_t *end_keyword_loc, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_FOR_NODE, .location = *location, .as.for_node = { .index = index, .collection = collection, .statements = statements, .for_keyword_loc = *for_keyword_loc, .in_keyword_loc = *in_keyword_loc, .do_keyword_loc = *do_keyword_loc, .end_keyword_loc = *end_keyword_loc } };
  return node;
}

// Allocate a new ForwardingArgumentsNode node.
yp_node_t *
yp_node_forwarding_arguments_node_create(yp_parser_t *parser, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_FORWARDING_ARGUMENTS_NODE, .location = *location };
  return node;
}

// Allocate a new ForwardingParameterNode node.
yp_node_t *
yp_node_forwarding_parameter_node_create(yp_parser_t *parser, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_FORWARDING_PARAMETER_NODE, .location = *location };
  return node;
}

// Allocate a new ForwardingSuperNode node.
yp_node_t *
yp_node_forwarding_super_node_create(yp_parser_t *parser, yp_node_t *block, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_FORWARDING_SUPER_NODE, .location = *location, .as.forwarding_super_node = { .block = block } };
  return node;
}

// Allocate a new GlobalVariableReadNode node.
yp_node_t *
yp_node_global_variable_read_node_create(yp_parser_t *parser, const yp_token_t *name) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_GLOBAL_VARIABLE_READ_NODE, .location = { .start = name->start, .end = name->end }, .as.global_variable_read_node = { .name = *name } };
  return node;
}

// Allocate a new GlobalVariableWriteNode node.
yp_node_t *
yp_node_global_variable_write_node_create(yp_parser_t *parser, const yp_token_t *name, const yp_token_t *operator, yp_node_t *value) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_GLOBAL_VARIABLE_WRITE_NODE, .location = { .start = name->start, .end = (value == NULL ? name->end : value->location.end) }, .as.global_variable_write_node = { .name = *name, .operator = *operator, .value = value } };
  return node;
}

// Allocate a new HashNode node.
yp_node_t *
yp_node_hash_node_create(yp_parser_t *parser, const yp_token_t *opening, const yp_token_t *closing) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_HASH_NODE, .location = { .start = (opening->type == YP_TOKEN_NOT_PROVIDED ? 0 : opening->start), .end = (closing->type == YP_TOKEN_NOT_PROVIDED ? 0 : closing->end) }, .as.hash_node = { .opening = *opening, .closing = *closing } };
  yp_node_list_init(&node->as.hash_node.elements);
  return node;
}

// Allocate a new HeredocNode node.
yp_node_t *
yp_node_heredoc_node_create(yp_parser_t *parser, const yp_token_t *opening, const yp_token_t *closing, int dedent) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_HEREDOC_NODE, .location = { .start = opening->start, .end = closing->end }, .as.heredoc_node = { .opening = *opening, .closing = *closing, .dedent = dedent } };
  yp_node_list_init(&node->as.heredoc_node.parts);
  return node;
}

// Allocate a new IfNode node.
yp_node_t *
yp_node_if_node_create(yp_parser_t *parser, const yp_token_t *if_keyword, yp_node_t *predicate, yp_node_t *statements, yp_node_t *consequent, const yp_token_t *end_keyword) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_IF_NODE, .location = { .start = if_keyword->start, .end = (end_keyword->type == YP_TOKEN_NOT_PROVIDED ? (consequent == NULL ? statements->location.end : consequent->location.end) : end_keyword->end) }, .as.if_node = { .if_keyword = *if_keyword, .predicate = predicate, .statements = statements, .consequent = consequent, .end_keyword = *end_keyword } };
  return node;
}

// Allocate a new ImaginaryNode node.
yp_node_t *
yp_node_imaginary_node_create(yp_parser_t *parser, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_IMAGINARY_NODE, .location = *location };
  return node;
}

// Allocate a new InstanceVariableReadNode node.
yp_node_t *
yp_node_instance_variable_read_node_create(yp_parser_t *parser, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_INSTANCE_VARIABLE_READ_NODE, .location = *location };
  return node;
}

// Allocate a new InstanceVariableWriteNode node.
yp_node_t *
yp_node_instance_variable_write_node_create(yp_parser_t *parser, const yp_location_t *name_loc, yp_node_t *value, const yp_location_t *operator_loc, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_INSTANCE_VARIABLE_WRITE_NODE, .location = *location, .as.instance_variable_write_node = { .name_loc = *name_loc, .value = value, .operator_loc = *operator_loc } };
  return node;
}

// Allocate a new IntegerNode node.
yp_node_t *
yp_node_integer_node_create(yp_parser_t *parser, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_INTEGER_NODE, .location = *location };
  return node;
}

// Allocate a new InterpolatedRegularExpressionNode node.
yp_node_t *
yp_node_interpolated_regular_expression_node_create(yp_parser_t *parser, const yp_token_t *opening, const yp_token_t *closing) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_INTERPOLATED_REGULAR_EXPRESSION_NODE, .location = { .start = opening->start, .end = closing->end }, .as.interpolated_regular_expression_node = { .opening = *opening, .closing = *closing } };
  yp_node_list_init(&node->as.interpolated_regular_expression_node.parts);
  return node;
}

// Allocate a new InterpolatedStringNode node.
yp_node_t *
yp_node_interpolated_string_node_create(yp_parser_t *parser, const yp_token_t *opening, const yp_token_t *closing) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_INTERPOLATED_STRING_NODE, .location = { .start = (opening->type == YP_TOKEN_NOT_PROVIDED ? 0 : opening->start), .end = (closing->type == YP_TOKEN_NOT_PROVIDED ? 0 : closing->end) }, .as.interpolated_string_node = { .opening = *opening, .closing = *closing } };
  yp_node_list_init(&node->as.interpolated_string_node.parts);
  return node;
}

// Allocate a new InterpolatedSymbolNode node.
yp_node_t *
yp_node_interpolated_symbol_node_create(yp_parser_t *parser, const yp_token_t *opening, const yp_token_t *closing) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_INTERPOLATED_SYMBOL_NODE, .location = { .start = (opening->type == YP_TOKEN_NOT_PROVIDED ? 0 : opening->start), .end = (closing->type == YP_TOKEN_NOT_PROVIDED ? 0 : closing->end) }, .as.interpolated_symbol_node = { .opening = *opening, .closing = *closing } };
  yp_node_list_init(&node->as.interpolated_symbol_node.parts);
  return node;
}

// Allocate a new InterpolatedXStringNode node.
yp_node_t *
yp_node_interpolated_x_string_node_create(yp_parser_t *parser, const yp_token_t *opening, const yp_token_t *closing) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_INTERPOLATED_X_STRING_NODE, .location = { .start = opening->start, .end = closing->end }, .as.interpolated_x_string_node = { .opening = *opening, .closing = *closing } };
  yp_node_list_init(&node->as.interpolated_x_string_node.parts);
  return node;
}

// Allocate a new KeywordParameterNode node.
yp_node_t *
yp_node_keyword_parameter_node_create(yp_parser_t *parser, const yp_token_t *name, yp_node_t *value) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_KEYWORD_PARAMETER_NODE, .location = { .start = name->start, .end = name->end }, .as.keyword_parameter_node = { .name = *name, .value = value } };
  return node;
}

// Allocate a new KeywordRestParameterNode node.
yp_node_t *
yp_node_keyword_rest_parameter_node_create(yp_parser_t *parser, const yp_token_t *operator, const yp_token_t *name) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_KEYWORD_REST_PARAMETER_NODE, .location = { .start = operator->start, .end = (name->type == YP_TOKEN_NOT_PROVIDED ? operator->end : name->end) }, .as.keyword_rest_parameter_node = { .operator = *operator, .name = *name } };
  return node;
}

// Allocate a new KeywordStarNode node.
yp_node_t *
yp_node_keyword_star_node_create(yp_parser_t *parser, const yp_token_t *operator, yp_node_t *expression) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_KEYWORD_STAR_NODE, .location = { .start = operator->start, .end = expression->location.end }, .as.keyword_star_node = { .operator = *operator, .expression = expression } };
  return node;
}

// Allocate a new LambdaNode node.
yp_node_t *
yp_node_lambda_node_create(yp_parser_t *parser, yp_node_t *scope, const yp_token_t *lparen, yp_node_t *parameters, const yp_token_t *rparen, yp_node_t *statements) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_LAMBDA_NODE, .location = { .start = parameters->location.start, .end = statements->location.end }, .as.lambda_node = { .scope = scope, .lparen = *lparen, .parameters = parameters, .rparen = *rparen, .statements = statements } };
  return node;
}

// Allocate a new LocalVariableReadNode node.
yp_node_t *
yp_node_local_variable_read_node_create(yp_parser_t *parser, const yp_token_t *name, int depth) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_LOCAL_VARIABLE_READ_NODE, .location = { .start = name->start, .end = name->end }, .as.local_variable_read_node = { .name = *name, .depth = depth } };
  return node;
}

// Allocate a new LocalVariableWriteNode node.
yp_node_t *
yp_node_local_variable_write_node_create(yp_parser_t *parser, const yp_token_t *name, const yp_token_t *operator, yp_node_t *value, int depth) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_LOCAL_VARIABLE_WRITE_NODE, .location = { .start = name->start, .end = (value == NULL ? name->end : value->location.end) }, .as.local_variable_write_node = { .name = *name, .operator = *operator, .value = value, .depth = depth } };
  return node;
}

// Allocate a new MissingNode node.
yp_node_t *
yp_node_missing_node_create(yp_parser_t *parser, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_MISSING_NODE, .location = *location };
  return node;
}

// Allocate a new ModuleNode node.
yp_node_t *
yp_node_module_node_create(yp_parser_t *parser, yp_node_t *scope, const yp_token_t *module_keyword, yp_node_t *constant_path, yp_node_t *statements, const yp_token_t *end_keyword) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_MODULE_NODE, .location = { .start = module_keyword->start, .end = end_keyword->end }, .as.module_node = { .scope = scope, .module_keyword = *module_keyword, .constant_path = constant_path, .statements = statements, .end_keyword = *end_keyword } };
  return node;
}

// Allocate a new MultiWriteNode node.
yp_node_t *
yp_node_multi_write_node_create(yp_parser_t *parser, const yp_token_t *operator, yp_node_t *value, const yp_location_t *lparen_loc, const yp_location_t *rparen_loc) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_MULTI_WRITE_NODE, .location = { .start = 0, .end = 0 }, .as.multi_write_node = { .operator = *operator, .value = value, .lparen_loc = *lparen_loc, .rparen_loc = *rparen_loc } };
  yp_node_list_init(&node->as.multi_write_node.targets);
  return node;
}

// Allocate a new NextNode node.
yp_node_t *
yp_node_next_node_create(yp_parser_t *parser, yp_node_t *arguments, const yp_location_t *keyword_loc, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_NEXT_NODE, .location = *location, .as.next_node = { .arguments = arguments, .keyword_loc = *keyword_loc } };
  return node;
}

// Allocate a new NilNode node.
yp_node_t *
yp_node_nil_node_create(yp_parser_t *parser, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_NIL_NODE, .location = *location };
  return node;
}

// Allocate a new NoKeywordsParameterNode node.
yp_node_t *
yp_node_no_keywords_parameter_node_create(yp_parser_t *parser, const yp_location_t *operator_loc, const yp_location_t *keyword_loc, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_NO_KEYWORDS_PARAMETER_NODE, .location = *location, .as.no_keywords_parameter_node = { .operator_loc = *operator_loc, .keyword_loc = *keyword_loc } };
  return node;
}

// Allocate a new OperatorAndAssignmentNode node.
yp_node_t *
yp_node_operator_and_assignment_node_create(yp_parser_t *parser, yp_node_t *target, yp_node_t *value, const yp_location_t *operator_loc, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_OPERATOR_AND_ASSIGNMENT_NODE, .location = *location, .as.operator_and_assignment_node = { .target = target, .value = value, .operator_loc = *operator_loc } };
  return node;
}

// Allocate a new OperatorAssignmentNode node.
yp_node_t *
yp_node_operator_assignment_node_create(yp_parser_t *parser, yp_node_t *target, const yp_token_t *operator, yp_node_t *value) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_OPERATOR_ASSIGNMENT_NODE, .location = { .start = target->location.start, .end = value->location.end }, .as.operator_assignment_node = { .target = target, .operator = *operator, .value = value } };
  return node;
}

// Allocate a new OperatorOrAssignmentNode node.
yp_node_t *
yp_node_operator_or_assignment_node_create(yp_parser_t *parser, yp_node_t *target, yp_node_t *value, const yp_location_t *operator_loc, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_OPERATOR_OR_ASSIGNMENT_NODE, .location = *location, .as.operator_or_assignment_node = { .target = target, .value = value, .operator_loc = *operator_loc } };
  return node;
}

// Allocate a new OptionalParameterNode node.
yp_node_t *
yp_node_optional_parameter_node_create(yp_parser_t *parser, const yp_token_t *name, const yp_token_t *equal_operator, yp_node_t *value) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_OPTIONAL_PARAMETER_NODE, .location = { .start = name->start, .end = value->location.end }, .as.optional_parameter_node = { .name = *name, .equal_operator = *equal_operator, .value = value } };
  return node;
}

// Allocate a new OrNode node.
yp_node_t *
yp_node_or_node_create(yp_parser_t *parser, yp_node_t *left, yp_node_t *right, const yp_location_t *operator_loc, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_OR_NODE, .location = *location, .as.or_node = { .left = left, .right = right, .operator_loc = *operator_loc } };
  return node;
}

// Allocate a new ParametersNode node.
yp_node_t *
yp_node_parameters_node_create(yp_parser_t *parser, yp_node_t *rest, yp_node_t *keyword_rest, yp_node_t *block) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_PARAMETERS_NODE, .location = { .start = 0, .end = (block == NULL ? (keyword_rest == NULL ? 0 : keyword_rest->location.end) : block->location.end) }, .as.parameters_node = { .rest = rest, .keyword_rest = keyword_rest, .block = block } };
  yp_node_list_init(&node->as.parameters_node.requireds);
  yp_node_list_init(&node->as.parameters_node.optionals);
  yp_node_list_init(&node->as.parameters_node.keywords);
  return node;
}

// Allocate a new ParenthesesNode node.
yp_node_t *
yp_node_parentheses_node_create(yp_parser_t *parser, yp_node_t *statements, const yp_location_t *opening_loc, const yp_location_t *closing_loc, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_PARENTHESES_NODE, .location = *location, .as.parentheses_node = { .statements = statements, .opening_loc = *opening_loc, .closing_loc = *closing_loc } };
  return node;
}

// Allocate a new PostExecutionNode node.
yp_node_t *
yp_node_post_execution_node_create(yp_parser_t *parser, yp_node_t *statements, const yp_location_t *keyword_loc, const yp_location_t *opening_loc, const yp_location_t *closing_loc, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_POST_EXECUTION_NODE, .location = *location, .as.post_execution_node = { .statements = statements, .keyword_loc = *keyword_loc, .opening_loc = *opening_loc, .closing_loc = *closing_loc } };
  return node;
}

// Allocate a new PreExecutionNode node.
yp_node_t *
yp_node_pre_execution_node_create(yp_parser_t *parser, yp_node_t *statements, const yp_location_t *keyword_loc, const yp_location_t *opening_loc, const yp_location_t *closing_loc, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_PRE_EXECUTION_NODE, .location = *location, .as.pre_execution_node = { .statements = statements, .keyword_loc = *keyword_loc, .opening_loc = *opening_loc, .closing_loc = *closing_loc } };
  return node;
}

// Allocate a new ProgramNode node.
yp_node_t *
yp_node_program_node_create(yp_parser_t *parser, yp_node_t *scope, yp_node_t *statements) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_PROGRAM_NODE, .location = { .start = statements->location.start, .end = statements->location.end }, .as.program_node = { .scope = scope, .statements = statements } };
  return node;
}

// Allocate a new RangeNode node.
yp_node_t *
yp_node_range_node_create(yp_parser_t *parser, yp_node_t *left, yp_node_t *right, const yp_location_t *operator_loc, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_RANGE_NODE, .location = *location, .as.range_node = { .left = left, .right = right, .operator_loc = *operator_loc } };
  return node;
}

// Allocate a new RationalNode node.
yp_node_t *
yp_node_rational_node_create(yp_parser_t *parser, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_RATIONAL_NODE, .location = *location };
  return node;
}

// Allocate a new RedoNode node.
yp_node_t *
yp_node_redo_node_create(yp_parser_t *parser, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_REDO_NODE, .location = *location };
  return node;
}

// Allocate a new RegularExpressionNode node.
yp_node_t *
yp_node_regular_expression_node_create(yp_parser_t *parser, const yp_token_t *opening, const yp_token_t *content, const yp_token_t *closing) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_REGULAR_EXPRESSION_NODE, .location = { .start = opening->start, .end = closing->end }, .as.regular_expression_node = { .opening = *opening, .content = *content, .closing = *closing } };
  return node;
}

// Allocate a new RequiredDestructuredParameterNode node.
yp_node_t *
yp_node_required_destructured_parameter_node_create(yp_parser_t *parser, const yp_token_t *opening, const yp_token_t *closing) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_REQUIRED_DESTRUCTURED_PARAMETER_NODE, .location = { .start = 0, .end = 0 }, .as.required_destructured_parameter_node = { .opening = *opening, .closing = *closing } };
  yp_node_list_init(&node->as.required_destructured_parameter_node.parameters);
  return node;
}

// Allocate a new RequiredParameterNode node.
yp_node_t *
yp_node_required_parameter_node_create(yp_parser_t *parser, const yp_token_t *name) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_REQUIRED_PARAMETER_NODE, .location = { .start = name->start, .end = name->end }, .as.required_parameter_node = { .name = *name } };
  return node;
}

// Allocate a new RescueModifierNode node.
yp_node_t *
yp_node_rescue_modifier_node_create(yp_parser_t *parser, yp_node_t *expression, const yp_token_t *rescue_keyword, yp_node_t *rescue_expression) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_RESCUE_MODIFIER_NODE, .location = { .start = expression->location.start, .end = rescue_expression->location.end }, .as.rescue_modifier_node = { .expression = expression, .rescue_keyword = *rescue_keyword, .rescue_expression = rescue_expression } };
  return node;
}

// Allocate a new RescueNode node.
yp_node_t *
yp_node_rescue_node_create(yp_parser_t *parser, const yp_token_t *rescue_keyword, const yp_token_t *equal_greater, yp_node_t *exception, yp_node_t *statements, yp_node_t *consequent) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_RESCUE_NODE, .location = { .start = rescue_keyword->start, .end = statements->location.end }, .as.rescue_node = { .rescue_keyword = *rescue_keyword, .equal_greater = *equal_greater, .exception = exception, .statements = statements, .consequent = consequent } };
  yp_node_list_init(&node->as.rescue_node.exceptions);
  return node;
}

// Allocate a new RestParameterNode node.
yp_node_t *
yp_node_rest_parameter_node_create(yp_parser_t *parser, const yp_token_t *operator, const yp_token_t *name) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_REST_PARAMETER_NODE, .location = { .start = operator->start, .end = (name->type == YP_TOKEN_NOT_PROVIDED ? operator->end : name->end) }, .as.rest_parameter_node = { .operator = *operator, .name = *name } };
  return node;
}

// Allocate a new RetryNode node.
yp_node_t *
yp_node_retry_node_create(yp_parser_t *parser, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_RETRY_NODE, .location = *location };
  return node;
}

// Allocate a new ReturnNode node.
yp_node_t *
yp_node_return_node_create(yp_parser_t *parser, const yp_token_t *keyword, yp_node_t *arguments) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_RETURN_NODE, .location = { .start = keyword->start, .end = (arguments == NULL ? keyword->end : arguments->location.end) }, .as.return_node = { .keyword = *keyword, .arguments = arguments } };
  return node;
}

// Allocate a new Scope node.
yp_node_t *
yp_node_scope_create(yp_parser_t *parser) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_SCOPE, .location = { .start = 0, .end = 0 } };
  yp_token_list_init(&node->as.scope.locals);
  return node;
}

// Allocate a new SelfNode node.
yp_node_t *
yp_node_self_node_create(yp_parser_t *parser, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_SELF_NODE, .location = *location };
  return node;
}

// Allocate a new SingletonClassNode node.
yp_node_t *
yp_node_singleton_class_node_create(yp_parser_t *parser, yp_node_t *scope, const yp_token_t *class_keyword, const yp_token_t *operator, yp_node_t *expression, yp_node_t *statements, const yp_token_t *end_keyword) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_SINGLETON_CLASS_NODE, .location = { .start = class_keyword->start, .end = end_keyword->end }, .as.singleton_class_node = { .scope = scope, .class_keyword = *class_keyword, .operator = *operator, .expression = expression, .statements = statements, .end_keyword = *end_keyword } };
  return node;
}

// Allocate a new SourceEncodingNode node.
yp_node_t *
yp_node_source_encoding_node_create(yp_parser_t *parser, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_SOURCE_ENCODING_NODE, .location = *location };
  return node;
}

// Allocate a new SourceFileNode node.
yp_node_t *
yp_node_source_file_node_create(yp_parser_t *parser, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_SOURCE_FILE_NODE, .location = *location };
  return node;
}

// Allocate a new SourceLineNode node.
yp_node_t *
yp_node_source_line_node_create(yp_parser_t *parser, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_SOURCE_LINE_NODE, .location = *location };
  return node;
}

// Allocate a new SplatNode node.
yp_node_t *
yp_node_splat_node_create(yp_parser_t *parser, const yp_token_t *operator, yp_node_t *expression) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_SPLAT_NODE, .location = { .start = operator->start, .end = (expression == NULL ? operator->end : expression->location.end) }, .as.splat_node = { .operator = *operator, .expression = expression } };
  return node;
}

// Allocate a new StatementsNode node.
yp_node_t *
yp_node_statements_node_create(yp_parser_t *parser, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_STATEMENTS_NODE, .location = *location };
  yp_node_list_init(&node->as.statements_node.body);
  return node;
}

// Allocate a new StringConcatNode node.
yp_node_t *
yp_node_string_concat_node_create(yp_parser_t *parser, yp_node_t *left, yp_node_t *right) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_STRING_CONCAT_NODE, .location = { .start = left->location.start, .end = right->location.end }, .as.string_concat_node = { .left = left, .right = right } };
  return node;
}

// Allocate a new StringInterpolatedNode node.
yp_node_t *
yp_node_string_interpolated_node_create(yp_parser_t *parser, const yp_token_t *opening, yp_node_t *statements, const yp_token_t *closing) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_STRING_INTERPOLATED_NODE, .location = { .start = opening->start, .end = closing->end }, .as.string_interpolated_node = { .opening = *opening, .statements = statements, .closing = *closing } };
  return node;
}

// Allocate a new StringNode node.
yp_node_t *
yp_node_string_node_create(yp_parser_t *parser, const yp_token_t *opening, const yp_token_t *content, const yp_token_t *closing) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_STRING_NODE, .location = { .start = (opening->type == YP_TOKEN_NOT_PROVIDED ? content->start : opening->start), .end = (closing->type == YP_TOKEN_NOT_PROVIDED ? content->end : closing->end) }, .as.string_node = { .opening = *opening, .content = *content, .closing = *closing } };
  return node;
}

// Allocate a new SuperNode node.
yp_node_t *
yp_node_super_node_create(yp_parser_t *parser, const yp_token_t *keyword, const yp_token_t *lparen, yp_node_t *arguments, const yp_token_t *rparen, yp_node_t *block) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_SUPER_NODE, .location = { .start = keyword->start, .end = (block == NULL ? (rparen->type == YP_TOKEN_NOT_PROVIDED ? (arguments == NULL ? (lparen->type == YP_TOKEN_NOT_PROVIDED ? keyword->end : lparen->end) : arguments->location.end) : rparen->end) : block->location.end) }, .as.super_node = { .keyword = *keyword, .lparen = *lparen, .arguments = arguments, .rparen = *rparen, .block = block } };
  return node;
}

// Allocate a new SymbolNode node.
yp_node_t *
yp_node_symbol_node_create(yp_parser_t *parser, const yp_token_t *opening, const yp_token_t *value, const yp_token_t *closing) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_SYMBOL_NODE, .location = { .start = (opening->type == YP_TOKEN_NOT_PROVIDED ? value->start : opening->start), .end = (closing->type == YP_TOKEN_NOT_PROVIDED ? value->end : closing->end) }, .as.symbol_node = { .opening = *opening, .value = *value, .closing = *closing } };
  return node;
}

// Allocate a new TernaryNode node.
yp_node_t *
yp_node_ternary_node_create(yp_parser_t *parser, yp_node_t *predicate, const yp_token_t *question_mark, yp_node_t *true_expression, const yp_token_t *colon, yp_node_t *false_expression) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_TERNARY_NODE, .location = { .start = predicate->location.start, .end = false_expression->location.end }, .as.ternary_node = { .predicate = predicate, .question_mark = *question_mark, .true_expression = true_expression, .colon = *colon, .false_expression = false_expression } };
  return node;
}

// Allocate a new TrueNode node.
yp_node_t *
yp_node_true_node_create(yp_parser_t *parser, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_TRUE_NODE, .location = *location };
  return node;
}

// Allocate a new UndefNode node.
yp_node_t *
yp_node_undef_node_create(yp_parser_t *parser, const yp_location_t *keyword_loc, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_UNDEF_NODE, .location = *location, .as.undef_node = { .keyword_loc = *keyword_loc } };
  yp_node_list_init(&node->as.undef_node.names);
  return node;
}

// Allocate a new UnlessNode node.
yp_node_t *
yp_node_unless_node_create(yp_parser_t *parser, const yp_token_t *keyword, yp_node_t *predicate, yp_node_t *statements, yp_node_t *consequent, const yp_token_t *end_keyword) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_UNLESS_NODE, .location = { .start = keyword->start, .end = statements->location.end }, .as.unless_node = { .keyword = *keyword, .predicate = predicate, .statements = statements, .consequent = consequent, .end_keyword = *end_keyword } };
  return node;
}

// Allocate a new UntilNode node.
yp_node_t *
yp_node_until_node_create(yp_parser_t *parser, const yp_token_t *keyword, yp_node_t *predicate, yp_node_t *statements) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_UNTIL_NODE, .location = { .start = keyword->start, .end = statements->location.end }, .as.until_node = { .keyword = *keyword, .predicate = predicate, .statements = statements } };
  return node;
}

// Allocate a new WhenNode node.
yp_node_t *
yp_node_when_node_create(yp_parser_t *parser, const yp_token_t *when_keyword, yp_node_t *statements) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_WHEN_NODE, .location = { .start = when_keyword->start, .end = (statements == NULL ? 0 : statements->location.end) }, .as.when_node = { .when_keyword = *when_keyword, .statements = statements } };
  yp_node_list_init(&node->as.when_node.conditions);
  return node;
}

// Allocate a new WhileNode node.
yp_node_t *
yp_node_while_node_create(yp_parser_t *parser, const yp_token_t *keyword, yp_node_t *predicate, yp_node_t *statements) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_WHILE_NODE, .location = { .start = keyword->start, .end = statements->location.end }, .as.while_node = { .keyword = *keyword, .predicate = predicate, .statements = statements } };
  return node;
}

// Allocate a new XStringNode node.
yp_node_t *
yp_node_x_string_node_create(yp_parser_t *parser, const yp_token_t *opening, const yp_token_t *content, const yp_token_t *closing, yp_location_t *location) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_X_STRING_NODE, .location = *location, .as.x_string_node = { .opening = *opening, .content = *content, .closing = *closing } };
  return node;
}

// Allocate a new YieldNode node.
yp_node_t *
yp_node_yield_node_create(yp_parser_t *parser, const yp_token_t *keyword, const yp_token_t *lparen, yp_node_t *arguments, const yp_token_t *rparen) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = YP_NODE_YIELD_NODE, .location = { .start = keyword->start, .end = (rparen->type == YP_TOKEN_NOT_PROVIDED ? (arguments == NULL ? (lparen->type == YP_TOKEN_NOT_PROVIDED ? keyword->end : lparen->end) : arguments->location.end) : rparen->end) }, .as.yield_node = { .keyword = *keyword, .lparen = *lparen, .arguments = arguments, .rparen = *rparen } };
  return node;
}

// Deallocate the space for a yp_node_t. Similarly to yp_node_alloc, we're not
// using the parser argument, but it's there to allow for the future possibility
// of pre-allocating larger memory pools.
__attribute__((__visibility__("default"))) void
yp_node_destroy(yp_parser_t *parser, yp_node_t *node) {
  switch (node->type) {
    case YP_NODE_ALIAS_NODE:
      yp_node_destroy(parser, node->as.alias_node.new_name);
      yp_node_destroy(parser, node->as.alias_node.old_name);
      break;
    case YP_NODE_AND_NODE:
      yp_node_destroy(parser, node->as.and_node.left);
      yp_node_destroy(parser, node->as.and_node.right);
      break;
    case YP_NODE_ARGUMENTS_NODE:
      yp_node_list_free(parser, &node->as.arguments_node.arguments);
      break;
    case YP_NODE_ARRAY_NODE:
      yp_node_list_free(parser, &node->as.array_node.elements);
      break;
    case YP_NODE_ASSOC_NODE:
      yp_node_destroy(parser, node->as.assoc_node.key);
      if (node->as.assoc_node.value != NULL) {
        yp_node_destroy(parser, node->as.assoc_node.value);
      }
      break;
    case YP_NODE_ASSOC_SPLAT_NODE:
      yp_node_destroy(parser, node->as.assoc_splat_node.value);
      break;
    case YP_NODE_BEGIN_NODE:
      yp_node_destroy(parser, node->as.begin_node.statements);
      if (node->as.begin_node.rescue_clause != NULL) {
        yp_node_destroy(parser, node->as.begin_node.rescue_clause);
      }
      if (node->as.begin_node.else_clause != NULL) {
        yp_node_destroy(parser, node->as.begin_node.else_clause);
      }
      if (node->as.begin_node.ensure_clause != NULL) {
        yp_node_destroy(parser, node->as.begin_node.ensure_clause);
      }
      break;
    case YP_NODE_BLOCK_ARGUMENT_NODE:
      yp_node_destroy(parser, node->as.block_argument_node.expression);
      break;
    case YP_NODE_BLOCK_NODE:
      yp_node_destroy(parser, node->as.block_node.scope);
      if (node->as.block_node.parameters != NULL) {
        yp_node_destroy(parser, node->as.block_node.parameters);
      }
      if (node->as.block_node.statements != NULL) {
        yp_node_destroy(parser, node->as.block_node.statements);
      }
      break;
    case YP_NODE_BLOCK_PARAMETER_NODE:
      break;
    case YP_NODE_BLOCK_PARAMETERS_NODE:
      yp_node_destroy(parser, node->as.block_parameters_node.parameters);
      yp_token_list_free(&node->as.block_parameters_node.locals);
      break;
    case YP_NODE_BREAK_NODE:
      if (node->as.break_node.arguments != NULL) {
        yp_node_destroy(parser, node->as.break_node.arguments);
      }
      break;
    case YP_NODE_CALL_NODE:
      if (node->as.call_node.receiver != NULL) {
        yp_node_destroy(parser, node->as.call_node.receiver);
      }
      if (node->as.call_node.arguments != NULL) {
        yp_node_destroy(parser, node->as.call_node.arguments);
      }
      if (node->as.call_node.block != NULL) {
        yp_node_destroy(parser, node->as.call_node.block);
      }
      yp_string_free(&node->as.call_node.name);
      break;
    case YP_NODE_CASE_NODE:
      if (node->as.case_node.predicate != NULL) {
        yp_node_destroy(parser, node->as.case_node.predicate);
      }
      yp_node_list_free(parser, &node->as.case_node.conditions);
      if (node->as.case_node.consequent != NULL) {
        yp_node_destroy(parser, node->as.case_node.consequent);
      }
      break;
    case YP_NODE_CLASS_NODE:
      yp_node_destroy(parser, node->as.class_node.scope);
      yp_node_destroy(parser, node->as.class_node.constant_path);
      if (node->as.class_node.superclass != NULL) {
        yp_node_destroy(parser, node->as.class_node.superclass);
      }
      yp_node_destroy(parser, node->as.class_node.statements);
      break;
    case YP_NODE_CLASS_VARIABLE_READ_NODE:
      break;
    case YP_NODE_CLASS_VARIABLE_WRITE_NODE:
      if (node->as.class_variable_write_node.value != NULL) {
        yp_node_destroy(parser, node->as.class_variable_write_node.value);
      }
      break;
    case YP_NODE_CONSTANT_PATH_NODE:
      if (node->as.constant_path_node.parent != NULL) {
        yp_node_destroy(parser, node->as.constant_path_node.parent);
      }
      yp_node_destroy(parser, node->as.constant_path_node.child);
      break;
    case YP_NODE_CONSTANT_PATH_WRITE_NODE:
      yp_node_destroy(parser, node->as.constant_path_write_node.target);
      if (node->as.constant_path_write_node.value != NULL) {
        yp_node_destroy(parser, node->as.constant_path_write_node.value);
      }
      break;
    case YP_NODE_CONSTANT_READ_NODE:
      break;
    case YP_NODE_DEF_NODE:
      if (node->as.def_node.receiver != NULL) {
        yp_node_destroy(parser, node->as.def_node.receiver);
      }
      yp_node_destroy(parser, node->as.def_node.parameters);
      yp_node_destroy(parser, node->as.def_node.statements);
      yp_node_destroy(parser, node->as.def_node.scope);
      break;
    case YP_NODE_DEFINED_NODE:
      yp_node_destroy(parser, node->as.defined_node.value);
      break;
    case YP_NODE_ELSE_NODE:
      if (node->as.else_node.statements != NULL) {
        yp_node_destroy(parser, node->as.else_node.statements);
      }
      break;
    case YP_NODE_ENSURE_NODE:
      yp_node_destroy(parser, node->as.ensure_node.statements);
      break;
    case YP_NODE_FALSE_NODE:
      break;
    case YP_NODE_FLOAT_NODE:
      break;
    case YP_NODE_FOR_NODE:
      yp_node_destroy(parser, node->as.for_node.index);
      yp_node_destroy(parser, node->as.for_node.collection);
      yp_node_destroy(parser, node->as.for_node.statements);
      break;
    case YP_NODE_FORWARDING_ARGUMENTS_NODE:
      break;
    case YP_NODE_FORWARDING_PARAMETER_NODE:
      break;
    case YP_NODE_FORWARDING_SUPER_NODE:
      if (node->as.forwarding_super_node.block != NULL) {
        yp_node_destroy(parser, node->as.forwarding_super_node.block);
      }
      break;
    case YP_NODE_GLOBAL_VARIABLE_READ_NODE:
      break;
    case YP_NODE_GLOBAL_VARIABLE_WRITE_NODE:
      if (node->as.global_variable_write_node.value != NULL) {
        yp_node_destroy(parser, node->as.global_variable_write_node.value);
      }
      break;
    case YP_NODE_HASH_NODE:
      yp_node_list_free(parser, &node->as.hash_node.elements);
      break;
    case YP_NODE_HEREDOC_NODE:
      yp_node_list_free(parser, &node->as.heredoc_node.parts);
      break;
    case YP_NODE_IF_NODE:
      yp_node_destroy(parser, node->as.if_node.predicate);
      yp_node_destroy(parser, node->as.if_node.statements);
      if (node->as.if_node.consequent != NULL) {
        yp_node_destroy(parser, node->as.if_node.consequent);
      }
      break;
    case YP_NODE_IMAGINARY_NODE:
      break;
    case YP_NODE_INSTANCE_VARIABLE_READ_NODE:
      break;
    case YP_NODE_INSTANCE_VARIABLE_WRITE_NODE:
      if (node->as.instance_variable_write_node.value != NULL) {
        yp_node_destroy(parser, node->as.instance_variable_write_node.value);
      }
      break;
    case YP_NODE_INTEGER_NODE:
      break;
    case YP_NODE_INTERPOLATED_REGULAR_EXPRESSION_NODE:
      yp_node_list_free(parser, &node->as.interpolated_regular_expression_node.parts);
      break;
    case YP_NODE_INTERPOLATED_STRING_NODE:
      yp_node_list_free(parser, &node->as.interpolated_string_node.parts);
      break;
    case YP_NODE_INTERPOLATED_SYMBOL_NODE:
      yp_node_list_free(parser, &node->as.interpolated_symbol_node.parts);
      break;
    case YP_NODE_INTERPOLATED_X_STRING_NODE:
      yp_node_list_free(parser, &node->as.interpolated_x_string_node.parts);
      break;
    case YP_NODE_KEYWORD_PARAMETER_NODE:
      if (node->as.keyword_parameter_node.value != NULL) {
        yp_node_destroy(parser, node->as.keyword_parameter_node.value);
      }
      break;
    case YP_NODE_KEYWORD_REST_PARAMETER_NODE:
      break;
    case YP_NODE_KEYWORD_STAR_NODE:
      yp_node_destroy(parser, node->as.keyword_star_node.expression);
      break;
    case YP_NODE_LAMBDA_NODE:
      yp_node_destroy(parser, node->as.lambda_node.scope);
      yp_node_destroy(parser, node->as.lambda_node.parameters);
      yp_node_destroy(parser, node->as.lambda_node.statements);
      break;
    case YP_NODE_LOCAL_VARIABLE_READ_NODE:
      break;
    case YP_NODE_LOCAL_VARIABLE_WRITE_NODE:
      if (node->as.local_variable_write_node.value != NULL) {
        yp_node_destroy(parser, node->as.local_variable_write_node.value);
      }
      break;
    case YP_NODE_MISSING_NODE:
      break;
    case YP_NODE_MODULE_NODE:
      yp_node_destroy(parser, node->as.module_node.scope);
      yp_node_destroy(parser, node->as.module_node.constant_path);
      yp_node_destroy(parser, node->as.module_node.statements);
      break;
    case YP_NODE_MULTI_WRITE_NODE:
      yp_node_list_free(parser, &node->as.multi_write_node.targets);
      if (node->as.multi_write_node.value != NULL) {
        yp_node_destroy(parser, node->as.multi_write_node.value);
      }
      break;
    case YP_NODE_NEXT_NODE:
      if (node->as.next_node.arguments != NULL) {
        yp_node_destroy(parser, node->as.next_node.arguments);
      }
      break;
    case YP_NODE_NIL_NODE:
      break;
    case YP_NODE_NO_KEYWORDS_PARAMETER_NODE:
      break;
    case YP_NODE_OPERATOR_AND_ASSIGNMENT_NODE:
      yp_node_destroy(parser, node->as.operator_and_assignment_node.target);
      yp_node_destroy(parser, node->as.operator_and_assignment_node.value);
      break;
    case YP_NODE_OPERATOR_ASSIGNMENT_NODE:
      yp_node_destroy(parser, node->as.operator_assignment_node.target);
      yp_node_destroy(parser, node->as.operator_assignment_node.value);
      break;
    case YP_NODE_OPERATOR_OR_ASSIGNMENT_NODE:
      yp_node_destroy(parser, node->as.operator_or_assignment_node.target);
      yp_node_destroy(parser, node->as.operator_or_assignment_node.value);
      break;
    case YP_NODE_OPTIONAL_PARAMETER_NODE:
      yp_node_destroy(parser, node->as.optional_parameter_node.value);
      break;
    case YP_NODE_OR_NODE:
      yp_node_destroy(parser, node->as.or_node.left);
      yp_node_destroy(parser, node->as.or_node.right);
      break;
    case YP_NODE_PARAMETERS_NODE:
      yp_node_list_free(parser, &node->as.parameters_node.requireds);
      yp_node_list_free(parser, &node->as.parameters_node.optionals);
      if (node->as.parameters_node.rest != NULL) {
        yp_node_destroy(parser, node->as.parameters_node.rest);
      }
      yp_node_list_free(parser, &node->as.parameters_node.keywords);
      if (node->as.parameters_node.keyword_rest != NULL) {
        yp_node_destroy(parser, node->as.parameters_node.keyword_rest);
      }
      if (node->as.parameters_node.block != NULL) {
        yp_node_destroy(parser, node->as.parameters_node.block);
      }
      break;
    case YP_NODE_PARENTHESES_NODE:
      if (node->as.parentheses_node.statements != NULL) {
        yp_node_destroy(parser, node->as.parentheses_node.statements);
      }
      break;
    case YP_NODE_POST_EXECUTION_NODE:
      yp_node_destroy(parser, node->as.post_execution_node.statements);
      break;
    case YP_NODE_PRE_EXECUTION_NODE:
      yp_node_destroy(parser, node->as.pre_execution_node.statements);
      break;
    case YP_NODE_PROGRAM_NODE:
      yp_node_destroy(parser, node->as.program_node.scope);
      yp_node_destroy(parser, node->as.program_node.statements);
      break;
    case YP_NODE_RANGE_NODE:
      if (node->as.range_node.left != NULL) {
        yp_node_destroy(parser, node->as.range_node.left);
      }
      if (node->as.range_node.right != NULL) {
        yp_node_destroy(parser, node->as.range_node.right);
      }
      break;
    case YP_NODE_RATIONAL_NODE:
      break;
    case YP_NODE_REDO_NODE:
      break;
    case YP_NODE_REGULAR_EXPRESSION_NODE:
      yp_string_free(&node->as.regular_expression_node.unescaped);
      break;
    case YP_NODE_REQUIRED_DESTRUCTURED_PARAMETER_NODE:
      yp_node_list_free(parser, &node->as.required_destructured_parameter_node.parameters);
      break;
    case YP_NODE_REQUIRED_PARAMETER_NODE:
      break;
    case YP_NODE_RESCUE_MODIFIER_NODE:
      yp_node_destroy(parser, node->as.rescue_modifier_node.expression);
      yp_node_destroy(parser, node->as.rescue_modifier_node.rescue_expression);
      break;
    case YP_NODE_RESCUE_NODE:
      yp_node_list_free(parser, &node->as.rescue_node.exceptions);
      if (node->as.rescue_node.exception != NULL) {
        yp_node_destroy(parser, node->as.rescue_node.exception);
      }
      yp_node_destroy(parser, node->as.rescue_node.statements);
      if (node->as.rescue_node.consequent != NULL) {
        yp_node_destroy(parser, node->as.rescue_node.consequent);
      }
      break;
    case YP_NODE_REST_PARAMETER_NODE:
      break;
    case YP_NODE_RETRY_NODE:
      break;
    case YP_NODE_RETURN_NODE:
      if (node->as.return_node.arguments != NULL) {
        yp_node_destroy(parser, node->as.return_node.arguments);
      }
      break;
    case YP_NODE_SCOPE:
      yp_token_list_free(&node->as.scope.locals);
      break;
    case YP_NODE_SELF_NODE:
      break;
    case YP_NODE_SINGLETON_CLASS_NODE:
      yp_node_destroy(parser, node->as.singleton_class_node.scope);
      yp_node_destroy(parser, node->as.singleton_class_node.expression);
      yp_node_destroy(parser, node->as.singleton_class_node.statements);
      break;
    case YP_NODE_SOURCE_ENCODING_NODE:
      break;
    case YP_NODE_SOURCE_FILE_NODE:
      break;
    case YP_NODE_SOURCE_LINE_NODE:
      break;
    case YP_NODE_SPLAT_NODE:
      if (node->as.splat_node.expression != NULL) {
        yp_node_destroy(parser, node->as.splat_node.expression);
      }
      break;
    case YP_NODE_STATEMENTS_NODE:
      yp_node_list_free(parser, &node->as.statements_node.body);
      break;
    case YP_NODE_STRING_CONCAT_NODE:
      yp_node_destroy(parser, node->as.string_concat_node.left);
      yp_node_destroy(parser, node->as.string_concat_node.right);
      break;
    case YP_NODE_STRING_INTERPOLATED_NODE:
      yp_node_destroy(parser, node->as.string_interpolated_node.statements);
      break;
    case YP_NODE_STRING_NODE:
      yp_string_free(&node->as.string_node.unescaped);
      break;
    case YP_NODE_SUPER_NODE:
      if (node->as.super_node.arguments != NULL) {
        yp_node_destroy(parser, node->as.super_node.arguments);
      }
      if (node->as.super_node.block != NULL) {
        yp_node_destroy(parser, node->as.super_node.block);
      }
      break;
    case YP_NODE_SYMBOL_NODE:
      yp_string_free(&node->as.symbol_node.unescaped);
      break;
    case YP_NODE_TERNARY_NODE:
      yp_node_destroy(parser, node->as.ternary_node.predicate);
      yp_node_destroy(parser, node->as.ternary_node.true_expression);
      yp_node_destroy(parser, node->as.ternary_node.false_expression);
      break;
    case YP_NODE_TRUE_NODE:
      break;
    case YP_NODE_UNDEF_NODE:
      yp_node_list_free(parser, &node->as.undef_node.names);
      break;
    case YP_NODE_UNLESS_NODE:
      yp_node_destroy(parser, node->as.unless_node.predicate);
      yp_node_destroy(parser, node->as.unless_node.statements);
      if (node->as.unless_node.consequent != NULL) {
        yp_node_destroy(parser, node->as.unless_node.consequent);
      }
      break;
    case YP_NODE_UNTIL_NODE:
      yp_node_destroy(parser, node->as.until_node.predicate);
      yp_node_destroy(parser, node->as.until_node.statements);
      break;
    case YP_NODE_WHEN_NODE:
      yp_node_list_free(parser, &node->as.when_node.conditions);
      if (node->as.when_node.statements != NULL) {
        yp_node_destroy(parser, node->as.when_node.statements);
      }
      break;
    case YP_NODE_WHILE_NODE:
      yp_node_destroy(parser, node->as.while_node.predicate);
      yp_node_destroy(parser, node->as.while_node.statements);
      break;
    case YP_NODE_X_STRING_NODE:
      yp_string_free(&node->as.x_string_node.unescaped);
      break;
    case YP_NODE_YIELD_NODE:
      if (node->as.yield_node.arguments != NULL) {
        yp_node_destroy(parser, node->as.yield_node.arguments);
      }
      break;
    default:
      assert(false && "unreachable");
      break;
  }
  free(node);
}

static void
yp_node_memsize_node(yp_node_t *node, yp_memsize_t *memsize) {
  memsize->node_count++;

  switch (node->type) {
    case YP_NODE_ALIAS_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.alias_node.new_name, memsize);
      yp_node_memsize_node(node->as.alias_node.old_name, memsize);
      memsize->memsize += sizeof(yp_location_t);
      break;
    }
    case YP_NODE_AND_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.and_node.left, memsize);
      yp_node_memsize_node(node->as.and_node.right, memsize);
      break;
    }
    case YP_NODE_ARGUMENTS_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_list_memsize(&node->as.arguments_node.arguments, memsize);
      break;
    }
    case YP_NODE_ARRAY_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_list_memsize(&node->as.array_node.elements, memsize);
      break;
    }
    case YP_NODE_ASSOC_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.assoc_node.key, memsize);
      if (node->as.assoc_node.value != NULL) {
        yp_node_memsize_node(node->as.assoc_node.value, memsize);
      }
      break;
    }
    case YP_NODE_ASSOC_SPLAT_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.assoc_splat_node.value, memsize);
      memsize->memsize += sizeof(yp_location_t);
      break;
    }
    case YP_NODE_BEGIN_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.begin_node.statements, memsize);
      if (node->as.begin_node.rescue_clause != NULL) {
        yp_node_memsize_node(node->as.begin_node.rescue_clause, memsize);
      }
      if (node->as.begin_node.else_clause != NULL) {
        yp_node_memsize_node(node->as.begin_node.else_clause, memsize);
      }
      if (node->as.begin_node.ensure_clause != NULL) {
        yp_node_memsize_node(node->as.begin_node.ensure_clause, memsize);
      }
      break;
    }
    case YP_NODE_BLOCK_ARGUMENT_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.block_argument_node.expression, memsize);
      memsize->memsize += sizeof(yp_location_t);
      break;
    }
    case YP_NODE_BLOCK_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.block_node.scope, memsize);
      if (node->as.block_node.parameters != NULL) {
        yp_node_memsize_node(node->as.block_node.parameters, memsize);
      }
      if (node->as.block_node.statements != NULL) {
        yp_node_memsize_node(node->as.block_node.statements, memsize);
      }
      memsize->memsize += sizeof(yp_location_t);
      memsize->memsize += sizeof(yp_location_t);
      break;
    }
    case YP_NODE_BLOCK_PARAMETER_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      memsize->memsize += sizeof(yp_location_t);
      break;
    }
    case YP_NODE_BLOCK_PARAMETERS_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.block_parameters_node.parameters, memsize);
      memsize->memsize += yp_token_list_memsize(&node->as.block_parameters_node.locals);
      break;
    }
    case YP_NODE_BREAK_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      if (node->as.break_node.arguments != NULL) {
        yp_node_memsize_node(node->as.break_node.arguments, memsize);
      }
      memsize->memsize += sizeof(yp_location_t);
      break;
    }
    case YP_NODE_CALL_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      if (node->as.call_node.receiver != NULL) {
        yp_node_memsize_node(node->as.call_node.receiver, memsize);
      }
      if (node->as.call_node.arguments != NULL) {
        yp_node_memsize_node(node->as.call_node.arguments, memsize);
      }
      if (node->as.call_node.block != NULL) {
        yp_node_memsize_node(node->as.call_node.block, memsize);
      }
      memsize->memsize += yp_string_memsize(&node->as.call_node.name);
      break;
    }
    case YP_NODE_CASE_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      if (node->as.case_node.predicate != NULL) {
        yp_node_memsize_node(node->as.case_node.predicate, memsize);
      }
      yp_node_list_memsize(&node->as.case_node.conditions, memsize);
      if (node->as.case_node.consequent != NULL) {
        yp_node_memsize_node(node->as.case_node.consequent, memsize);
      }
      memsize->memsize += sizeof(yp_location_t);
      memsize->memsize += sizeof(yp_location_t);
      break;
    }
    case YP_NODE_CLASS_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.class_node.scope, memsize);
      yp_node_memsize_node(node->as.class_node.constant_path, memsize);
      if (node->as.class_node.superclass != NULL) {
        yp_node_memsize_node(node->as.class_node.superclass, memsize);
      }
      yp_node_memsize_node(node->as.class_node.statements, memsize);
      break;
    }
    case YP_NODE_CLASS_VARIABLE_READ_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      break;
    }
    case YP_NODE_CLASS_VARIABLE_WRITE_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      memsize->memsize += sizeof(yp_location_t);
      if (node->as.class_variable_write_node.value != NULL) {
        yp_node_memsize_node(node->as.class_variable_write_node.value, memsize);
      }
      memsize->memsize += sizeof(yp_location_t);
      break;
    }
    case YP_NODE_CONSTANT_PATH_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      if (node->as.constant_path_node.parent != NULL) {
        yp_node_memsize_node(node->as.constant_path_node.parent, memsize);
      }
      yp_node_memsize_node(node->as.constant_path_node.child, memsize);
      break;
    }
    case YP_NODE_CONSTANT_PATH_WRITE_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.constant_path_write_node.target, memsize);
      if (node->as.constant_path_write_node.value != NULL) {
        yp_node_memsize_node(node->as.constant_path_write_node.value, memsize);
      }
      break;
    }
    case YP_NODE_CONSTANT_READ_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      break;
    }
    case YP_NODE_DEF_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      if (node->as.def_node.receiver != NULL) {
        yp_node_memsize_node(node->as.def_node.receiver, memsize);
      }
      yp_node_memsize_node(node->as.def_node.parameters, memsize);
      yp_node_memsize_node(node->as.def_node.statements, memsize);
      yp_node_memsize_node(node->as.def_node.scope, memsize);
      memsize->memsize += sizeof(yp_location_t);
      memsize->memsize += sizeof(yp_location_t);
      memsize->memsize += sizeof(yp_location_t);
      memsize->memsize += sizeof(yp_location_t);
      memsize->memsize += sizeof(yp_location_t);
      memsize->memsize += sizeof(yp_location_t);
      break;
    }
    case YP_NODE_DEFINED_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.defined_node.value, memsize);
      memsize->memsize += sizeof(yp_location_t);
      break;
    }
    case YP_NODE_ELSE_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      if (node->as.else_node.statements != NULL) {
        yp_node_memsize_node(node->as.else_node.statements, memsize);
      }
      break;
    }
    case YP_NODE_ENSURE_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.ensure_node.statements, memsize);
      break;
    }
    case YP_NODE_FALSE_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      break;
    }
    case YP_NODE_FLOAT_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      break;
    }
    case YP_NODE_FOR_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.for_node.index, memsize);
      yp_node_memsize_node(node->as.for_node.collection, memsize);
      yp_node_memsize_node(node->as.for_node.statements, memsize);
      memsize->memsize += sizeof(yp_location_t);
      memsize->memsize += sizeof(yp_location_t);
      memsize->memsize += sizeof(yp_location_t);
      memsize->memsize += sizeof(yp_location_t);
      break;
    }
    case YP_NODE_FORWARDING_ARGUMENTS_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      break;
    }
    case YP_NODE_FORWARDING_PARAMETER_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      break;
    }
    case YP_NODE_FORWARDING_SUPER_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      if (node->as.forwarding_super_node.block != NULL) {
        yp_node_memsize_node(node->as.forwarding_super_node.block, memsize);
      }
      break;
    }
    case YP_NODE_GLOBAL_VARIABLE_READ_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      break;
    }
    case YP_NODE_GLOBAL_VARIABLE_WRITE_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      if (node->as.global_variable_write_node.value != NULL) {
        yp_node_memsize_node(node->as.global_variable_write_node.value, memsize);
      }
      break;
    }
    case YP_NODE_HASH_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_list_memsize(&node->as.hash_node.elements, memsize);
      break;
    }
    case YP_NODE_HEREDOC_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_list_memsize(&node->as.heredoc_node.parts, memsize);
      memsize->memsize += sizeof(int);
      break;
    }
    case YP_NODE_IF_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.if_node.predicate, memsize);
      yp_node_memsize_node(node->as.if_node.statements, memsize);
      if (node->as.if_node.consequent != NULL) {
        yp_node_memsize_node(node->as.if_node.consequent, memsize);
      }
      break;
    }
    case YP_NODE_IMAGINARY_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      break;
    }
    case YP_NODE_INSTANCE_VARIABLE_READ_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      break;
    }
    case YP_NODE_INSTANCE_VARIABLE_WRITE_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      memsize->memsize += sizeof(yp_location_t);
      if (node->as.instance_variable_write_node.value != NULL) {
        yp_node_memsize_node(node->as.instance_variable_write_node.value, memsize);
      }
      memsize->memsize += sizeof(yp_location_t);
      break;
    }
    case YP_NODE_INTEGER_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      break;
    }
    case YP_NODE_INTERPOLATED_REGULAR_EXPRESSION_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_list_memsize(&node->as.interpolated_regular_expression_node.parts, memsize);
      break;
    }
    case YP_NODE_INTERPOLATED_STRING_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_list_memsize(&node->as.interpolated_string_node.parts, memsize);
      break;
    }
    case YP_NODE_INTERPOLATED_SYMBOL_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_list_memsize(&node->as.interpolated_symbol_node.parts, memsize);
      break;
    }
    case YP_NODE_INTERPOLATED_X_STRING_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_list_memsize(&node->as.interpolated_x_string_node.parts, memsize);
      break;
    }
    case YP_NODE_KEYWORD_PARAMETER_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      if (node->as.keyword_parameter_node.value != NULL) {
        yp_node_memsize_node(node->as.keyword_parameter_node.value, memsize);
      }
      break;
    }
    case YP_NODE_KEYWORD_REST_PARAMETER_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      break;
    }
    case YP_NODE_KEYWORD_STAR_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.keyword_star_node.expression, memsize);
      break;
    }
    case YP_NODE_LAMBDA_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.lambda_node.scope, memsize);
      yp_node_memsize_node(node->as.lambda_node.parameters, memsize);
      yp_node_memsize_node(node->as.lambda_node.statements, memsize);
      break;
    }
    case YP_NODE_LOCAL_VARIABLE_READ_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      memsize->memsize += sizeof(int);
      break;
    }
    case YP_NODE_LOCAL_VARIABLE_WRITE_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      if (node->as.local_variable_write_node.value != NULL) {
        yp_node_memsize_node(node->as.local_variable_write_node.value, memsize);
      }
      memsize->memsize += sizeof(int);
      break;
    }
    case YP_NODE_MISSING_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      break;
    }
    case YP_NODE_MODULE_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.module_node.scope, memsize);
      yp_node_memsize_node(node->as.module_node.constant_path, memsize);
      yp_node_memsize_node(node->as.module_node.statements, memsize);
      break;
    }
    case YP_NODE_MULTI_WRITE_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_list_memsize(&node->as.multi_write_node.targets, memsize);
      if (node->as.multi_write_node.value != NULL) {
        yp_node_memsize_node(node->as.multi_write_node.value, memsize);
      }
      memsize->memsize += sizeof(yp_location_t);
      memsize->memsize += sizeof(yp_location_t);
      break;
    }
    case YP_NODE_NEXT_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      if (node->as.next_node.arguments != NULL) {
        yp_node_memsize_node(node->as.next_node.arguments, memsize);
      }
      memsize->memsize += sizeof(yp_location_t);
      break;
    }
    case YP_NODE_NIL_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      break;
    }
    case YP_NODE_NO_KEYWORDS_PARAMETER_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      memsize->memsize += sizeof(yp_location_t);
      memsize->memsize += sizeof(yp_location_t);
      break;
    }
    case YP_NODE_OPERATOR_AND_ASSIGNMENT_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.operator_and_assignment_node.target, memsize);
      yp_node_memsize_node(node->as.operator_and_assignment_node.value, memsize);
      memsize->memsize += sizeof(yp_location_t);
      break;
    }
    case YP_NODE_OPERATOR_ASSIGNMENT_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.operator_assignment_node.target, memsize);
      yp_node_memsize_node(node->as.operator_assignment_node.value, memsize);
      break;
    }
    case YP_NODE_OPERATOR_OR_ASSIGNMENT_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.operator_or_assignment_node.target, memsize);
      yp_node_memsize_node(node->as.operator_or_assignment_node.value, memsize);
      memsize->memsize += sizeof(yp_location_t);
      break;
    }
    case YP_NODE_OPTIONAL_PARAMETER_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.optional_parameter_node.value, memsize);
      break;
    }
    case YP_NODE_OR_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.or_node.left, memsize);
      yp_node_memsize_node(node->as.or_node.right, memsize);
      memsize->memsize += sizeof(yp_location_t);
      break;
    }
    case YP_NODE_PARAMETERS_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_list_memsize(&node->as.parameters_node.requireds, memsize);
      yp_node_list_memsize(&node->as.parameters_node.optionals, memsize);
      if (node->as.parameters_node.rest != NULL) {
        yp_node_memsize_node(node->as.parameters_node.rest, memsize);
      }
      yp_node_list_memsize(&node->as.parameters_node.keywords, memsize);
      if (node->as.parameters_node.keyword_rest != NULL) {
        yp_node_memsize_node(node->as.parameters_node.keyword_rest, memsize);
      }
      if (node->as.parameters_node.block != NULL) {
        yp_node_memsize_node(node->as.parameters_node.block, memsize);
      }
      break;
    }
    case YP_NODE_PARENTHESES_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      if (node->as.parentheses_node.statements != NULL) {
        yp_node_memsize_node(node->as.parentheses_node.statements, memsize);
      }
      memsize->memsize += sizeof(yp_location_t);
      memsize->memsize += sizeof(yp_location_t);
      break;
    }
    case YP_NODE_POST_EXECUTION_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.post_execution_node.statements, memsize);
      memsize->memsize += sizeof(yp_location_t);
      memsize->memsize += sizeof(yp_location_t);
      memsize->memsize += sizeof(yp_location_t);
      break;
    }
    case YP_NODE_PRE_EXECUTION_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.pre_execution_node.statements, memsize);
      memsize->memsize += sizeof(yp_location_t);
      memsize->memsize += sizeof(yp_location_t);
      memsize->memsize += sizeof(yp_location_t);
      break;
    }
    case YP_NODE_PROGRAM_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.program_node.scope, memsize);
      yp_node_memsize_node(node->as.program_node.statements, memsize);
      break;
    }
    case YP_NODE_RANGE_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      if (node->as.range_node.left != NULL) {
        yp_node_memsize_node(node->as.range_node.left, memsize);
      }
      if (node->as.range_node.right != NULL) {
        yp_node_memsize_node(node->as.range_node.right, memsize);
      }
      memsize->memsize += sizeof(yp_location_t);
      break;
    }
    case YP_NODE_RATIONAL_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      break;
    }
    case YP_NODE_REDO_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      break;
    }
    case YP_NODE_REGULAR_EXPRESSION_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      memsize->memsize += yp_string_memsize(&node->as.regular_expression_node.unescaped);
      break;
    }
    case YP_NODE_REQUIRED_DESTRUCTURED_PARAMETER_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_list_memsize(&node->as.required_destructured_parameter_node.parameters, memsize);
      break;
    }
    case YP_NODE_REQUIRED_PARAMETER_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      break;
    }
    case YP_NODE_RESCUE_MODIFIER_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.rescue_modifier_node.expression, memsize);
      yp_node_memsize_node(node->as.rescue_modifier_node.rescue_expression, memsize);
      break;
    }
    case YP_NODE_RESCUE_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_list_memsize(&node->as.rescue_node.exceptions, memsize);
      if (node->as.rescue_node.exception != NULL) {
        yp_node_memsize_node(node->as.rescue_node.exception, memsize);
      }
      yp_node_memsize_node(node->as.rescue_node.statements, memsize);
      if (node->as.rescue_node.consequent != NULL) {
        yp_node_memsize_node(node->as.rescue_node.consequent, memsize);
      }
      break;
    }
    case YP_NODE_REST_PARAMETER_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      break;
    }
    case YP_NODE_RETRY_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      break;
    }
    case YP_NODE_RETURN_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      if (node->as.return_node.arguments != NULL) {
        yp_node_memsize_node(node->as.return_node.arguments, memsize);
      }
      break;
    }
    case YP_NODE_SCOPE: {
      memsize->memsize += sizeof(yp_node_t);
      memsize->memsize += yp_token_list_memsize(&node->as.scope.locals);
      break;
    }
    case YP_NODE_SELF_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      break;
    }
    case YP_NODE_SINGLETON_CLASS_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.singleton_class_node.scope, memsize);
      yp_node_memsize_node(node->as.singleton_class_node.expression, memsize);
      yp_node_memsize_node(node->as.singleton_class_node.statements, memsize);
      break;
    }
    case YP_NODE_SOURCE_ENCODING_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      break;
    }
    case YP_NODE_SOURCE_FILE_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      break;
    }
    case YP_NODE_SOURCE_LINE_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      break;
    }
    case YP_NODE_SPLAT_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      if (node->as.splat_node.expression != NULL) {
        yp_node_memsize_node(node->as.splat_node.expression, memsize);
      }
      break;
    }
    case YP_NODE_STATEMENTS_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_list_memsize(&node->as.statements_node.body, memsize);
      break;
    }
    case YP_NODE_STRING_CONCAT_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.string_concat_node.left, memsize);
      yp_node_memsize_node(node->as.string_concat_node.right, memsize);
      break;
    }
    case YP_NODE_STRING_INTERPOLATED_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.string_interpolated_node.statements, memsize);
      break;
    }
    case YP_NODE_STRING_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      memsize->memsize += yp_string_memsize(&node->as.string_node.unescaped);
      break;
    }
    case YP_NODE_SUPER_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      if (node->as.super_node.arguments != NULL) {
        yp_node_memsize_node(node->as.super_node.arguments, memsize);
      }
      if (node->as.super_node.block != NULL) {
        yp_node_memsize_node(node->as.super_node.block, memsize);
      }
      break;
    }
    case YP_NODE_SYMBOL_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      memsize->memsize += yp_string_memsize(&node->as.symbol_node.unescaped);
      break;
    }
    case YP_NODE_TERNARY_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.ternary_node.predicate, memsize);
      yp_node_memsize_node(node->as.ternary_node.true_expression, memsize);
      yp_node_memsize_node(node->as.ternary_node.false_expression, memsize);
      break;
    }
    case YP_NODE_TRUE_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      break;
    }
    case YP_NODE_UNDEF_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_list_memsize(&node->as.undef_node.names, memsize);
      memsize->memsize += sizeof(yp_location_t);
      break;
    }
    case YP_NODE_UNLESS_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.unless_node.predicate, memsize);
      yp_node_memsize_node(node->as.unless_node.statements, memsize);
      if (node->as.unless_node.consequent != NULL) {
        yp_node_memsize_node(node->as.unless_node.consequent, memsize);
      }
      break;
    }
    case YP_NODE_UNTIL_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.until_node.predicate, memsize);
      yp_node_memsize_node(node->as.until_node.statements, memsize);
      break;
    }
    case YP_NODE_WHEN_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_list_memsize(&node->as.when_node.conditions, memsize);
      if (node->as.when_node.statements != NULL) {
        yp_node_memsize_node(node->as.when_node.statements, memsize);
      }
      break;
    }
    case YP_NODE_WHILE_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      yp_node_memsize_node(node->as.while_node.predicate, memsize);
      yp_node_memsize_node(node->as.while_node.statements, memsize);
      break;
    }
    case YP_NODE_X_STRING_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      memsize->memsize += yp_string_memsize(&node->as.x_string_node.unescaped);
      break;
    }
    case YP_NODE_YIELD_NODE: {
      memsize->memsize += sizeof(yp_node_t);
      if (node->as.yield_node.arguments != NULL) {
        yp_node_memsize_node(node->as.yield_node.arguments, memsize);
      }
      break;
    }
  }
}

// Calculates the memory footprint of a given node.
__attribute__((__visibility__("default"))) extern void
yp_node_memsize(yp_node_t *node, yp_memsize_t *memsize) {
  *memsize = (yp_memsize_t) { .memsize = 0, .node_count = 0 };
  yp_node_memsize_node(node, memsize);
}
