/******************************************************************************/
/* This file is generated by the bin/template script and should not be        */
/* modified manually. See                                                     */
/* templates/ext/yarp/api_node.c.erb                                          */
/* if you are looking to modify the                                           */
/* template                                                                   */
/******************************************************************************/
#line 2 "api_node.c.erb"
#include "yarp/extension.h"

extern VALUE rb_cYARP;
extern VALUE rb_cYARPNode;
extern VALUE rb_cYARPSource;
extern VALUE rb_cYARPToken;
extern VALUE rb_cYARPLocation;

static VALUE rb_cYARPAliasNode;
static VALUE rb_cYARPAlternationPatternNode;
static VALUE rb_cYARPAndNode;
static VALUE rb_cYARPArgumentsNode;
static VALUE rb_cYARPArrayNode;
static VALUE rb_cYARPArrayPatternNode;
static VALUE rb_cYARPAssocNode;
static VALUE rb_cYARPAssocSplatNode;
static VALUE rb_cYARPBackReferenceReadNode;
static VALUE rb_cYARPBeginNode;
static VALUE rb_cYARPBlockArgumentNode;
static VALUE rb_cYARPBlockNode;
static VALUE rb_cYARPBlockParameterNode;
static VALUE rb_cYARPBlockParametersNode;
static VALUE rb_cYARPBreakNode;
static VALUE rb_cYARPCallNode;
static VALUE rb_cYARPCallOperatorAndWriteNode;
static VALUE rb_cYARPCallOperatorOrWriteNode;
static VALUE rb_cYARPCallOperatorWriteNode;
static VALUE rb_cYARPCapturePatternNode;
static VALUE rb_cYARPCaseNode;
static VALUE rb_cYARPClassNode;
static VALUE rb_cYARPClassVariableOperatorAndWriteNode;
static VALUE rb_cYARPClassVariableOperatorOrWriteNode;
static VALUE rb_cYARPClassVariableOperatorWriteNode;
static VALUE rb_cYARPClassVariableReadNode;
static VALUE rb_cYARPClassVariableWriteNode;
static VALUE rb_cYARPConstantOperatorAndWriteNode;
static VALUE rb_cYARPConstantOperatorOrWriteNode;
static VALUE rb_cYARPConstantOperatorWriteNode;
static VALUE rb_cYARPConstantPathNode;
static VALUE rb_cYARPConstantPathOperatorAndWriteNode;
static VALUE rb_cYARPConstantPathOperatorOrWriteNode;
static VALUE rb_cYARPConstantPathOperatorWriteNode;
static VALUE rb_cYARPConstantPathWriteNode;
static VALUE rb_cYARPConstantReadNode;
static VALUE rb_cYARPConstantWriteNode;
static VALUE rb_cYARPDefNode;
static VALUE rb_cYARPDefinedNode;
static VALUE rb_cYARPElseNode;
static VALUE rb_cYARPEmbeddedStatementsNode;
static VALUE rb_cYARPEmbeddedVariableNode;
static VALUE rb_cYARPEnsureNode;
static VALUE rb_cYARPFalseNode;
static VALUE rb_cYARPFindPatternNode;
static VALUE rb_cYARPFlipFlopNode;
static VALUE rb_cYARPFloatNode;
static VALUE rb_cYARPForNode;
static VALUE rb_cYARPForwardingArgumentsNode;
static VALUE rb_cYARPForwardingParameterNode;
static VALUE rb_cYARPForwardingSuperNode;
static VALUE rb_cYARPGlobalVariableOperatorAndWriteNode;
static VALUE rb_cYARPGlobalVariableOperatorOrWriteNode;
static VALUE rb_cYARPGlobalVariableOperatorWriteNode;
static VALUE rb_cYARPGlobalVariableReadNode;
static VALUE rb_cYARPGlobalVariableWriteNode;
static VALUE rb_cYARPHashNode;
static VALUE rb_cYARPHashPatternNode;
static VALUE rb_cYARPIfNode;
static VALUE rb_cYARPImaginaryNode;
static VALUE rb_cYARPInNode;
static VALUE rb_cYARPInstanceVariableOperatorAndWriteNode;
static VALUE rb_cYARPInstanceVariableOperatorOrWriteNode;
static VALUE rb_cYARPInstanceVariableOperatorWriteNode;
static VALUE rb_cYARPInstanceVariableReadNode;
static VALUE rb_cYARPInstanceVariableWriteNode;
static VALUE rb_cYARPIntegerNode;
static VALUE rb_cYARPInterpolatedRegularExpressionNode;
static VALUE rb_cYARPInterpolatedStringNode;
static VALUE rb_cYARPInterpolatedSymbolNode;
static VALUE rb_cYARPInterpolatedXStringNode;
static VALUE rb_cYARPKeywordHashNode;
static VALUE rb_cYARPKeywordParameterNode;
static VALUE rb_cYARPKeywordRestParameterNode;
static VALUE rb_cYARPLambdaNode;
static VALUE rb_cYARPLocalVariableOperatorAndWriteNode;
static VALUE rb_cYARPLocalVariableOperatorOrWriteNode;
static VALUE rb_cYARPLocalVariableOperatorWriteNode;
static VALUE rb_cYARPLocalVariableReadNode;
static VALUE rb_cYARPLocalVariableWriteNode;
static VALUE rb_cYARPMatchPredicateNode;
static VALUE rb_cYARPMatchRequiredNode;
static VALUE rb_cYARPMissingNode;
static VALUE rb_cYARPModuleNode;
static VALUE rb_cYARPMultiWriteNode;
static VALUE rb_cYARPNextNode;
static VALUE rb_cYARPNilNode;
static VALUE rb_cYARPNoKeywordsParameterNode;
static VALUE rb_cYARPNumberedReferenceReadNode;
static VALUE rb_cYARPOptionalParameterNode;
static VALUE rb_cYARPOrNode;
static VALUE rb_cYARPParametersNode;
static VALUE rb_cYARPParenthesesNode;
static VALUE rb_cYARPPinnedExpressionNode;
static VALUE rb_cYARPPinnedVariableNode;
static VALUE rb_cYARPPostExecutionNode;
static VALUE rb_cYARPPreExecutionNode;
static VALUE rb_cYARPProgramNode;
static VALUE rb_cYARPRangeNode;
static VALUE rb_cYARPRationalNode;
static VALUE rb_cYARPRedoNode;
static VALUE rb_cYARPRegularExpressionNode;
static VALUE rb_cYARPRequiredDestructuredParameterNode;
static VALUE rb_cYARPRequiredParameterNode;
static VALUE rb_cYARPRescueModifierNode;
static VALUE rb_cYARPRescueNode;
static VALUE rb_cYARPRestParameterNode;
static VALUE rb_cYARPRetryNode;
static VALUE rb_cYARPReturnNode;
static VALUE rb_cYARPSelfNode;
static VALUE rb_cYARPSingletonClassNode;
static VALUE rb_cYARPSourceEncodingNode;
static VALUE rb_cYARPSourceFileNode;
static VALUE rb_cYARPSourceLineNode;
static VALUE rb_cYARPSplatNode;
static VALUE rb_cYARPStatementsNode;
static VALUE rb_cYARPStringConcatNode;
static VALUE rb_cYARPStringNode;
static VALUE rb_cYARPSuperNode;
static VALUE rb_cYARPSymbolNode;
static VALUE rb_cYARPTrueNode;
static VALUE rb_cYARPUndefNode;
static VALUE rb_cYARPUnlessNode;
static VALUE rb_cYARPUntilNode;
static VALUE rb_cYARPWhenNode;
static VALUE rb_cYARPWhileNode;
static VALUE rb_cYARPXStringNode;
static VALUE rb_cYARPYieldNode;

static VALUE
yp_location_new(yp_parser_t *parser, const char *start, const char *end, VALUE source) {
    VALUE argv[] = { source, LONG2FIX(start - parser->start), LONG2FIX(end - start) };
    return rb_class_new_instance(3, argv, rb_cYARPLocation);
}

VALUE
yp_token_new(yp_parser_t *parser, yp_token_t *token, rb_encoding *encoding, VALUE source) {
    ID type = rb_intern(yp_token_type_to_str(token->type));
    VALUE location = yp_location_new(parser, token->start, token->end, source);

    VALUE argv[] = {
        ID2SYM(type),
        rb_enc_str_new(token->start, token->end - token->start, encoding),
        location
    };

    return rb_class_new_instance(3, argv, rb_cYARPToken);
}

static VALUE
yp_string_new(yp_string_t *string, rb_encoding *encoding) {
    return rb_enc_str_new(yp_string_source(string), yp_string_length(string), encoding);
}

// Create a YARP::Source object from the given parser.
VALUE
yp_source_new(yp_parser_t *parser) {
    VALUE source = rb_str_new(parser->start, parser->end - parser->start);
    VALUE offsets = rb_ary_new_capa(parser->newline_list.size);

    for (size_t index = 0; index < parser->newline_list.size; index++) {
        rb_ary_push(offsets, INT2FIX(parser->newline_list.offsets[index]));
    }

    VALUE source_argv[] = { source, offsets };
    return rb_class_new_instance(2, source_argv, rb_cYARPSource);
}

typedef struct yp_node_stack_node {
    struct yp_node_stack_node *prev;
    yp_node_t *visit;
    bool visited;
} yp_node_stack_node_t;

static void
yp_node_stack_push(yp_node_stack_node_t **stack, yp_node_t *visit) {
    yp_node_stack_node_t *node = malloc(sizeof(yp_node_stack_node_t));
    node->prev = *stack;
    node->visit = visit;
    node->visited = false;
    *stack = node;
}

static yp_node_t *
yp_node_stack_pop(yp_node_stack_node_t **stack) {
    yp_node_stack_node_t *current = *stack;
    yp_node_t *visit = current->visit;

    *stack = current->prev;
    free(current);

    return visit;
}

VALUE
yp_ast_new(yp_parser_t *parser, yp_node_t *node, rb_encoding *encoding) {
    VALUE source = yp_source_new(parser);
    ID *constants = calloc(parser->constant_pool.size, sizeof(ID));

    for (size_t index = 0; index < parser->constant_pool.capacity; index++) {
        yp_constant_t constant = parser->constant_pool.constants[index];

        if (constant.id != 0) {
            constants[constant.id - 1] = rb_intern3(constant.start, constant.length, encoding);
        }
    }

    yp_node_stack_node_t *node_stack = NULL;
    yp_node_stack_push(&node_stack, node);
    VALUE value_stack = rb_ary_new();

    while (node_stack != NULL) {
        if (!node_stack->visited) {
            if (node_stack->visit == NULL) {
                yp_node_stack_pop(&node_stack);
                rb_ary_push(value_stack, Qnil);
                continue;
            }

            yp_node_t *node = node_stack->visit;
            node_stack->visited = true;

            switch (YP_NODE_TYPE(node)) {
#line 111 "api_node.c.erb"
                case YP_NODE_ALIAS_NODE: {
                    yp_alias_node_t *cast = (yp_alias_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->new_name);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->old_name);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_ALTERNATION_PATTERN_NODE: {
                    yp_alternation_pattern_node_t *cast = (yp_alternation_pattern_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->left);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->right);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_AND_NODE: {
                    yp_and_node_t *cast = (yp_and_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->left);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->right);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_ARGUMENTS_NODE: {
                    yp_arguments_node_t *cast = (yp_arguments_node_t *) node;
                    for (size_t index = 0; index < cast->arguments.size; index++) {
                        yp_node_stack_push(&node_stack, (yp_node_t *) cast->arguments.nodes[index]);
                    }
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_ARRAY_NODE: {
                    yp_array_node_t *cast = (yp_array_node_t *) node;
                    for (size_t index = 0; index < cast->elements.size; index++) {
                        yp_node_stack_push(&node_stack, (yp_node_t *) cast->elements.nodes[index]);
                    }
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_ARRAY_PATTERN_NODE: {
                    yp_array_pattern_node_t *cast = (yp_array_pattern_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->constant);
                    for (size_t index = 0; index < cast->requireds.size; index++) {
                        yp_node_stack_push(&node_stack, (yp_node_t *) cast->requireds.nodes[index]);
                    }
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->rest);
                    for (size_t index = 0; index < cast->posts.size; index++) {
                        yp_node_stack_push(&node_stack, (yp_node_t *) cast->posts.nodes[index]);
                    }
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_ASSOC_NODE: {
                    yp_assoc_node_t *cast = (yp_assoc_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->key);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_ASSOC_SPLAT_NODE: {
                    yp_assoc_splat_node_t *cast = (yp_assoc_splat_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_BEGIN_NODE: {
                    yp_begin_node_t *cast = (yp_begin_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->statements);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->rescue_clause);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->else_clause);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->ensure_clause);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_BLOCK_ARGUMENT_NODE: {
                    yp_block_argument_node_t *cast = (yp_block_argument_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->expression);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_BLOCK_NODE: {
                    yp_block_node_t *cast = (yp_block_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->parameters);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->statements);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_BLOCK_PARAMETERS_NODE: {
                    yp_block_parameters_node_t *cast = (yp_block_parameters_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->parameters);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_BREAK_NODE: {
                    yp_break_node_t *cast = (yp_break_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->arguments);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_CALL_NODE: {
                    yp_call_node_t *cast = (yp_call_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->receiver);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->arguments);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->block);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_CALL_OPERATOR_AND_WRITE_NODE: {
                    yp_call_operator_and_write_node_t *cast = (yp_call_operator_and_write_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->target);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_CALL_OPERATOR_OR_WRITE_NODE: {
                    yp_call_operator_or_write_node_t *cast = (yp_call_operator_or_write_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->target);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_CALL_OPERATOR_WRITE_NODE: {
                    yp_call_operator_write_node_t *cast = (yp_call_operator_write_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->target);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_CAPTURE_PATTERN_NODE: {
                    yp_capture_pattern_node_t *cast = (yp_capture_pattern_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->target);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_CASE_NODE: {
                    yp_case_node_t *cast = (yp_case_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->predicate);
                    for (size_t index = 0; index < cast->conditions.size; index++) {
                        yp_node_stack_push(&node_stack, (yp_node_t *) cast->conditions.nodes[index]);
                    }
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->consequent);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_CLASS_NODE: {
                    yp_class_node_t *cast = (yp_class_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->constant_path);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->superclass);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->statements);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_CLASS_VARIABLE_OPERATOR_AND_WRITE_NODE: {
                    yp_class_variable_operator_and_write_node_t *cast = (yp_class_variable_operator_and_write_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_CLASS_VARIABLE_OPERATOR_OR_WRITE_NODE: {
                    yp_class_variable_operator_or_write_node_t *cast = (yp_class_variable_operator_or_write_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_CLASS_VARIABLE_OPERATOR_WRITE_NODE: {
                    yp_class_variable_operator_write_node_t *cast = (yp_class_variable_operator_write_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_CLASS_VARIABLE_WRITE_NODE: {
                    yp_class_variable_write_node_t *cast = (yp_class_variable_write_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_CONSTANT_OPERATOR_AND_WRITE_NODE: {
                    yp_constant_operator_and_write_node_t *cast = (yp_constant_operator_and_write_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_CONSTANT_OPERATOR_OR_WRITE_NODE: {
                    yp_constant_operator_or_write_node_t *cast = (yp_constant_operator_or_write_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_CONSTANT_OPERATOR_WRITE_NODE: {
                    yp_constant_operator_write_node_t *cast = (yp_constant_operator_write_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_CONSTANT_PATH_NODE: {
                    yp_constant_path_node_t *cast = (yp_constant_path_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->parent);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->child);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_CONSTANT_PATH_OPERATOR_AND_WRITE_NODE: {
                    yp_constant_path_operator_and_write_node_t *cast = (yp_constant_path_operator_and_write_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->target);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_CONSTANT_PATH_OPERATOR_OR_WRITE_NODE: {
                    yp_constant_path_operator_or_write_node_t *cast = (yp_constant_path_operator_or_write_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->target);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_CONSTANT_PATH_OPERATOR_WRITE_NODE: {
                    yp_constant_path_operator_write_node_t *cast = (yp_constant_path_operator_write_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->target);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_CONSTANT_PATH_WRITE_NODE: {
                    yp_constant_path_write_node_t *cast = (yp_constant_path_write_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->target);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_CONSTANT_WRITE_NODE: {
                    yp_constant_write_node_t *cast = (yp_constant_write_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_DEF_NODE: {
                    yp_def_node_t *cast = (yp_def_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->receiver);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->parameters);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->statements);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_DEFINED_NODE: {
                    yp_defined_node_t *cast = (yp_defined_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_ELSE_NODE: {
                    yp_else_node_t *cast = (yp_else_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->statements);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_EMBEDDED_STATEMENTS_NODE: {
                    yp_embedded_statements_node_t *cast = (yp_embedded_statements_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->statements);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_EMBEDDED_VARIABLE_NODE: {
                    yp_embedded_variable_node_t *cast = (yp_embedded_variable_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->variable);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_ENSURE_NODE: {
                    yp_ensure_node_t *cast = (yp_ensure_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->statements);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_FIND_PATTERN_NODE: {
                    yp_find_pattern_node_t *cast = (yp_find_pattern_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->constant);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->left);
                    for (size_t index = 0; index < cast->requireds.size; index++) {
                        yp_node_stack_push(&node_stack, (yp_node_t *) cast->requireds.nodes[index]);
                    }
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->right);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_FLIP_FLOP_NODE: {
                    yp_flip_flop_node_t *cast = (yp_flip_flop_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->left);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->right);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_FOR_NODE: {
                    yp_for_node_t *cast = (yp_for_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->index);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->collection);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->statements);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_FORWARDING_SUPER_NODE: {
                    yp_forwarding_super_node_t *cast = (yp_forwarding_super_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->block);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_GLOBAL_VARIABLE_OPERATOR_AND_WRITE_NODE: {
                    yp_global_variable_operator_and_write_node_t *cast = (yp_global_variable_operator_and_write_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_GLOBAL_VARIABLE_OPERATOR_OR_WRITE_NODE: {
                    yp_global_variable_operator_or_write_node_t *cast = (yp_global_variable_operator_or_write_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_GLOBAL_VARIABLE_OPERATOR_WRITE_NODE: {
                    yp_global_variable_operator_write_node_t *cast = (yp_global_variable_operator_write_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_GLOBAL_VARIABLE_WRITE_NODE: {
                    yp_global_variable_write_node_t *cast = (yp_global_variable_write_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_HASH_NODE: {
                    yp_hash_node_t *cast = (yp_hash_node_t *) node;
                    for (size_t index = 0; index < cast->elements.size; index++) {
                        yp_node_stack_push(&node_stack, (yp_node_t *) cast->elements.nodes[index]);
                    }
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_HASH_PATTERN_NODE: {
                    yp_hash_pattern_node_t *cast = (yp_hash_pattern_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->constant);
                    for (size_t index = 0; index < cast->assocs.size; index++) {
                        yp_node_stack_push(&node_stack, (yp_node_t *) cast->assocs.nodes[index]);
                    }
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->kwrest);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_IF_NODE: {
                    yp_if_node_t *cast = (yp_if_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->predicate);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->statements);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->consequent);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_IMAGINARY_NODE: {
                    yp_imaginary_node_t *cast = (yp_imaginary_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->numeric);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_IN_NODE: {
                    yp_in_node_t *cast = (yp_in_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->pattern);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->statements);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_INSTANCE_VARIABLE_OPERATOR_AND_WRITE_NODE: {
                    yp_instance_variable_operator_and_write_node_t *cast = (yp_instance_variable_operator_and_write_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_INSTANCE_VARIABLE_OPERATOR_OR_WRITE_NODE: {
                    yp_instance_variable_operator_or_write_node_t *cast = (yp_instance_variable_operator_or_write_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_INSTANCE_VARIABLE_OPERATOR_WRITE_NODE: {
                    yp_instance_variable_operator_write_node_t *cast = (yp_instance_variable_operator_write_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_INSTANCE_VARIABLE_WRITE_NODE: {
                    yp_instance_variable_write_node_t *cast = (yp_instance_variable_write_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_INTERPOLATED_REGULAR_EXPRESSION_NODE: {
                    yp_interpolated_regular_expression_node_t *cast = (yp_interpolated_regular_expression_node_t *) node;
                    for (size_t index = 0; index < cast->parts.size; index++) {
                        yp_node_stack_push(&node_stack, (yp_node_t *) cast->parts.nodes[index]);
                    }
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_INTERPOLATED_STRING_NODE: {
                    yp_interpolated_string_node_t *cast = (yp_interpolated_string_node_t *) node;
                    for (size_t index = 0; index < cast->parts.size; index++) {
                        yp_node_stack_push(&node_stack, (yp_node_t *) cast->parts.nodes[index]);
                    }
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_INTERPOLATED_SYMBOL_NODE: {
                    yp_interpolated_symbol_node_t *cast = (yp_interpolated_symbol_node_t *) node;
                    for (size_t index = 0; index < cast->parts.size; index++) {
                        yp_node_stack_push(&node_stack, (yp_node_t *) cast->parts.nodes[index]);
                    }
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_INTERPOLATED_X_STRING_NODE: {
                    yp_interpolated_x_string_node_t *cast = (yp_interpolated_x_string_node_t *) node;
                    for (size_t index = 0; index < cast->parts.size; index++) {
                        yp_node_stack_push(&node_stack, (yp_node_t *) cast->parts.nodes[index]);
                    }
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_KEYWORD_HASH_NODE: {
                    yp_keyword_hash_node_t *cast = (yp_keyword_hash_node_t *) node;
                    for (size_t index = 0; index < cast->elements.size; index++) {
                        yp_node_stack_push(&node_stack, (yp_node_t *) cast->elements.nodes[index]);
                    }
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_KEYWORD_PARAMETER_NODE: {
                    yp_keyword_parameter_node_t *cast = (yp_keyword_parameter_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_LAMBDA_NODE: {
                    yp_lambda_node_t *cast = (yp_lambda_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->parameters);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->statements);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_LOCAL_VARIABLE_OPERATOR_AND_WRITE_NODE: {
                    yp_local_variable_operator_and_write_node_t *cast = (yp_local_variable_operator_and_write_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_LOCAL_VARIABLE_OPERATOR_OR_WRITE_NODE: {
                    yp_local_variable_operator_or_write_node_t *cast = (yp_local_variable_operator_or_write_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_LOCAL_VARIABLE_OPERATOR_WRITE_NODE: {
                    yp_local_variable_operator_write_node_t *cast = (yp_local_variable_operator_write_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_LOCAL_VARIABLE_WRITE_NODE: {
                    yp_local_variable_write_node_t *cast = (yp_local_variable_write_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_MATCH_PREDICATE_NODE: {
                    yp_match_predicate_node_t *cast = (yp_match_predicate_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->pattern);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_MATCH_REQUIRED_NODE: {
                    yp_match_required_node_t *cast = (yp_match_required_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->pattern);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_MODULE_NODE: {
                    yp_module_node_t *cast = (yp_module_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->constant_path);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->statements);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_MULTI_WRITE_NODE: {
                    yp_multi_write_node_t *cast = (yp_multi_write_node_t *) node;
                    for (size_t index = 0; index < cast->targets.size; index++) {
                        yp_node_stack_push(&node_stack, (yp_node_t *) cast->targets.nodes[index]);
                    }
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_NEXT_NODE: {
                    yp_next_node_t *cast = (yp_next_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->arguments);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_OPTIONAL_PARAMETER_NODE: {
                    yp_optional_parameter_node_t *cast = (yp_optional_parameter_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->value);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_OR_NODE: {
                    yp_or_node_t *cast = (yp_or_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->left);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->right);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_PARAMETERS_NODE: {
                    yp_parameters_node_t *cast = (yp_parameters_node_t *) node;
                    for (size_t index = 0; index < cast->requireds.size; index++) {
                        yp_node_stack_push(&node_stack, (yp_node_t *) cast->requireds.nodes[index]);
                    }
                    for (size_t index = 0; index < cast->optionals.size; index++) {
                        yp_node_stack_push(&node_stack, (yp_node_t *) cast->optionals.nodes[index]);
                    }
                    for (size_t index = 0; index < cast->posts.size; index++) {
                        yp_node_stack_push(&node_stack, (yp_node_t *) cast->posts.nodes[index]);
                    }
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->rest);
                    for (size_t index = 0; index < cast->keywords.size; index++) {
                        yp_node_stack_push(&node_stack, (yp_node_t *) cast->keywords.nodes[index]);
                    }
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->keyword_rest);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->block);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_PARENTHESES_NODE: {
                    yp_parentheses_node_t *cast = (yp_parentheses_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->statements);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_PINNED_EXPRESSION_NODE: {
                    yp_pinned_expression_node_t *cast = (yp_pinned_expression_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->expression);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_PINNED_VARIABLE_NODE: {
                    yp_pinned_variable_node_t *cast = (yp_pinned_variable_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->variable);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_POST_EXECUTION_NODE: {
                    yp_post_execution_node_t *cast = (yp_post_execution_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->statements);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_PRE_EXECUTION_NODE: {
                    yp_pre_execution_node_t *cast = (yp_pre_execution_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->statements);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_PROGRAM_NODE: {
                    yp_program_node_t *cast = (yp_program_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->statements);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_RANGE_NODE: {
                    yp_range_node_t *cast = (yp_range_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->left);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->right);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_RATIONAL_NODE: {
                    yp_rational_node_t *cast = (yp_rational_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->numeric);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_REQUIRED_DESTRUCTURED_PARAMETER_NODE: {
                    yp_required_destructured_parameter_node_t *cast = (yp_required_destructured_parameter_node_t *) node;
                    for (size_t index = 0; index < cast->parameters.size; index++) {
                        yp_node_stack_push(&node_stack, (yp_node_t *) cast->parameters.nodes[index]);
                    }
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_RESCUE_MODIFIER_NODE: {
                    yp_rescue_modifier_node_t *cast = (yp_rescue_modifier_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->expression);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->rescue_expression);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_RESCUE_NODE: {
                    yp_rescue_node_t *cast = (yp_rescue_node_t *) node;
                    for (size_t index = 0; index < cast->exceptions.size; index++) {
                        yp_node_stack_push(&node_stack, (yp_node_t *) cast->exceptions.nodes[index]);
                    }
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->reference);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->statements);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->consequent);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_RETURN_NODE: {
                    yp_return_node_t *cast = (yp_return_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->arguments);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_SINGLETON_CLASS_NODE: {
                    yp_singleton_class_node_t *cast = (yp_singleton_class_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->expression);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->statements);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_SPLAT_NODE: {
                    yp_splat_node_t *cast = (yp_splat_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->expression);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_STATEMENTS_NODE: {
                    yp_statements_node_t *cast = (yp_statements_node_t *) node;
                    for (size_t index = 0; index < cast->body.size; index++) {
                        yp_node_stack_push(&node_stack, (yp_node_t *) cast->body.nodes[index]);
                    }
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_STRING_CONCAT_NODE: {
                    yp_string_concat_node_t *cast = (yp_string_concat_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->left);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->right);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_SUPER_NODE: {
                    yp_super_node_t *cast = (yp_super_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->arguments);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->block);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_UNDEF_NODE: {
                    yp_undef_node_t *cast = (yp_undef_node_t *) node;
                    for (size_t index = 0; index < cast->names.size; index++) {
                        yp_node_stack_push(&node_stack, (yp_node_t *) cast->names.nodes[index]);
                    }
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_UNLESS_NODE: {
                    yp_unless_node_t *cast = (yp_unless_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->predicate);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->statements);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->consequent);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_UNTIL_NODE: {
                    yp_until_node_t *cast = (yp_until_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->predicate);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->statements);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_WHEN_NODE: {
                    yp_when_node_t *cast = (yp_when_node_t *) node;
                    for (size_t index = 0; index < cast->conditions.size; index++) {
                        yp_node_stack_push(&node_stack, (yp_node_t *) cast->conditions.nodes[index]);
                    }
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->statements);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_WHILE_NODE: {
                    yp_while_node_t *cast = (yp_while_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->predicate);
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->statements);
                    break;
                }
#line 111 "api_node.c.erb"
                case YP_NODE_YIELD_NODE: {
                    yp_yield_node_t *cast = (yp_yield_node_t *) node;
                    yp_node_stack_push(&node_stack, (yp_node_t *) cast->arguments);
                    break;
                }
                default:
                    break;
            }
#line 131 "api_node.c.erb"
        } else {
            yp_node_t *node = yp_node_stack_pop(&node_stack);

            switch (YP_NODE_TYPE(node)) {
#line 137 "api_node.c.erb"
                case YP_NODE_ALIAS_NODE: {
                    yp_alias_node_t *cast = (yp_alias_node_t *) node;
                    VALUE argv[4];

                    // new_name
                    argv[0] = rb_ary_pop(value_stack);

                    // old_name
                    argv[1] = rb_ary_pop(value_stack);

                    // keyword_loc
                    argv[2] = yp_location_new(parser, cast->keyword_loc.start, cast->keyword_loc.end, source);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPAliasNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_ALTERNATION_PATTERN_NODE: {
                    yp_alternation_pattern_node_t *cast = (yp_alternation_pattern_node_t *) node;
                    VALUE argv[4];

                    // left
                    argv[0] = rb_ary_pop(value_stack);

                    // right
                    argv[1] = rb_ary_pop(value_stack);

                    // operator_loc
                    argv[2] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPAlternationPatternNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_AND_NODE: {
                    yp_and_node_t *cast = (yp_and_node_t *) node;
                    VALUE argv[4];

                    // left
                    argv[0] = rb_ary_pop(value_stack);

                    // right
                    argv[1] = rb_ary_pop(value_stack);

                    // operator_loc
                    argv[2] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPAndNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_ARGUMENTS_NODE: {
                    yp_arguments_node_t *cast = (yp_arguments_node_t *) node;
                    VALUE argv[2];

                    // arguments
                    argv[0] = rb_ary_new_capa(cast->arguments.size);
                    for (size_t index = 0; index < cast->arguments.size; index++) {
                        rb_ary_push(argv[0], rb_ary_pop(value_stack));
                    }

                    // location
                    argv[1] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(2, argv, rb_cYARPArgumentsNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_ARRAY_NODE: {
                    yp_array_node_t *cast = (yp_array_node_t *) node;
                    VALUE argv[4];

                    // elements
                    argv[0] = rb_ary_new_capa(cast->elements.size);
                    for (size_t index = 0; index < cast->elements.size; index++) {
                        rb_ary_push(argv[0], rb_ary_pop(value_stack));
                    }

                    // opening_loc
                    argv[1] = cast->opening_loc.start == NULL ? Qnil : yp_location_new(parser, cast->opening_loc.start, cast->opening_loc.end, source);

                    // closing_loc
                    argv[2] = cast->closing_loc.start == NULL ? Qnil : yp_location_new(parser, cast->closing_loc.start, cast->closing_loc.end, source);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPArrayNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_ARRAY_PATTERN_NODE: {
                    yp_array_pattern_node_t *cast = (yp_array_pattern_node_t *) node;
                    VALUE argv[7];

                    // constant
                    argv[0] = rb_ary_pop(value_stack);

                    // requireds
                    argv[1] = rb_ary_new_capa(cast->requireds.size);
                    for (size_t index = 0; index < cast->requireds.size; index++) {
                        rb_ary_push(argv[1], rb_ary_pop(value_stack));
                    }

                    // rest
                    argv[2] = rb_ary_pop(value_stack);

                    // posts
                    argv[3] = rb_ary_new_capa(cast->posts.size);
                    for (size_t index = 0; index < cast->posts.size; index++) {
                        rb_ary_push(argv[3], rb_ary_pop(value_stack));
                    }

                    // opening_loc
                    argv[4] = cast->opening_loc.start == NULL ? Qnil : yp_location_new(parser, cast->opening_loc.start, cast->opening_loc.end, source);

                    // closing_loc
                    argv[5] = cast->closing_loc.start == NULL ? Qnil : yp_location_new(parser, cast->closing_loc.start, cast->closing_loc.end, source);

                    // location
                    argv[6] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(7, argv, rb_cYARPArrayPatternNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_ASSOC_NODE: {
                    yp_assoc_node_t *cast = (yp_assoc_node_t *) node;
                    VALUE argv[4];

                    // key
                    argv[0] = rb_ary_pop(value_stack);

                    // value
                    argv[1] = rb_ary_pop(value_stack);

                    // operator_loc
                    argv[2] = cast->operator_loc.start == NULL ? Qnil : yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPAssocNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_ASSOC_SPLAT_NODE: {
                    yp_assoc_splat_node_t *cast = (yp_assoc_splat_node_t *) node;
                    VALUE argv[3];

                    // value
                    argv[0] = rb_ary_pop(value_stack);

                    // operator_loc
                    argv[1] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // location
                    argv[2] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(3, argv, rb_cYARPAssocSplatNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_BACK_REFERENCE_READ_NODE: {
                    VALUE argv[1];

                    // location
                    argv[0] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(1, argv, rb_cYARPBackReferenceReadNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_BEGIN_NODE: {
                    yp_begin_node_t *cast = (yp_begin_node_t *) node;
                    VALUE argv[7];

                    // begin_keyword_loc
                    argv[0] = cast->begin_keyword_loc.start == NULL ? Qnil : yp_location_new(parser, cast->begin_keyword_loc.start, cast->begin_keyword_loc.end, source);

                    // statements
                    argv[1] = rb_ary_pop(value_stack);

                    // rescue_clause
                    argv[2] = rb_ary_pop(value_stack);

                    // else_clause
                    argv[3] = rb_ary_pop(value_stack);

                    // ensure_clause
                    argv[4] = rb_ary_pop(value_stack);

                    // end_keyword_loc
                    argv[5] = cast->end_keyword_loc.start == NULL ? Qnil : yp_location_new(parser, cast->end_keyword_loc.start, cast->end_keyword_loc.end, source);

                    // location
                    argv[6] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(7, argv, rb_cYARPBeginNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_BLOCK_ARGUMENT_NODE: {
                    yp_block_argument_node_t *cast = (yp_block_argument_node_t *) node;
                    VALUE argv[3];

                    // expression
                    argv[0] = rb_ary_pop(value_stack);

                    // operator_loc
                    argv[1] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // location
                    argv[2] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(3, argv, rb_cYARPBlockArgumentNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_BLOCK_NODE: {
                    yp_block_node_t *cast = (yp_block_node_t *) node;
                    VALUE argv[6];

                    // locals
                    argv[0] = rb_ary_new_capa(cast->locals.size);
                    for (size_t index = 0; index < cast->locals.size; index++) {
                        rb_ary_push(argv[0], rb_id2sym(constants[cast->locals.ids[index] - 1]));
                    }

                    // parameters
                    argv[1] = rb_ary_pop(value_stack);

                    // statements
                    argv[2] = rb_ary_pop(value_stack);

                    // opening_loc
                    argv[3] = yp_location_new(parser, cast->opening_loc.start, cast->opening_loc.end, source);

                    // closing_loc
                    argv[4] = yp_location_new(parser, cast->closing_loc.start, cast->closing_loc.end, source);

                    // location
                    argv[5] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(6, argv, rb_cYARPBlockNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_BLOCK_PARAMETER_NODE: {
                    yp_block_parameter_node_t *cast = (yp_block_parameter_node_t *) node;
                    VALUE argv[3];

                    // name_loc
                    argv[0] = cast->name_loc.start == NULL ? Qnil : yp_location_new(parser, cast->name_loc.start, cast->name_loc.end, source);

                    // operator_loc
                    argv[1] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // location
                    argv[2] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(3, argv, rb_cYARPBlockParameterNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_BLOCK_PARAMETERS_NODE: {
                    yp_block_parameters_node_t *cast = (yp_block_parameters_node_t *) node;
                    VALUE argv[5];

                    // parameters
                    argv[0] = rb_ary_pop(value_stack);

                    // locals
                    argv[1] = rb_ary_new_capa(cast->locals.size);
                    for (size_t index = 0; index < cast->locals.size; index++) {
                        yp_location_t location = cast->locals.locations[index];
                        rb_ary_push(argv[1], yp_location_new(parser, location.start, location.end, source));
                    }

                    // opening_loc
                    argv[2] = cast->opening_loc.start == NULL ? Qnil : yp_location_new(parser, cast->opening_loc.start, cast->opening_loc.end, source);

                    // closing_loc
                    argv[3] = cast->closing_loc.start == NULL ? Qnil : yp_location_new(parser, cast->closing_loc.start, cast->closing_loc.end, source);

                    // location
                    argv[4] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(5, argv, rb_cYARPBlockParametersNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_BREAK_NODE: {
                    yp_break_node_t *cast = (yp_break_node_t *) node;
                    VALUE argv[3];

                    // arguments
                    argv[0] = rb_ary_pop(value_stack);

                    // keyword_loc
                    argv[1] = yp_location_new(parser, cast->keyword_loc.start, cast->keyword_loc.end, source);

                    // location
                    argv[2] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(3, argv, rb_cYARPBreakNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_CALL_NODE: {
                    yp_call_node_t *cast = (yp_call_node_t *) node;
                    VALUE argv[10];

                    // receiver
                    argv[0] = rb_ary_pop(value_stack);

                    // operator_loc
                    argv[1] = cast->operator_loc.start == NULL ? Qnil : yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // message_loc
                    argv[2] = cast->message_loc.start == NULL ? Qnil : yp_location_new(parser, cast->message_loc.start, cast->message_loc.end, source);

                    // opening_loc
                    argv[3] = cast->opening_loc.start == NULL ? Qnil : yp_location_new(parser, cast->opening_loc.start, cast->opening_loc.end, source);

                    // arguments
                    argv[4] = rb_ary_pop(value_stack);

                    // closing_loc
                    argv[5] = cast->closing_loc.start == NULL ? Qnil : yp_location_new(parser, cast->closing_loc.start, cast->closing_loc.end, source);

                    // block
                    argv[6] = rb_ary_pop(value_stack);

                    // flags
                    argv[7] = ULONG2NUM(node->flags >> 1);

                    // name
                    argv[8] = yp_string_new(&cast->name, encoding);

                    // location
                    argv[9] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(10, argv, rb_cYARPCallNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_CALL_OPERATOR_AND_WRITE_NODE: {
                    yp_call_operator_and_write_node_t *cast = (yp_call_operator_and_write_node_t *) node;
                    VALUE argv[4];

                    // target
                    argv[0] = rb_ary_pop(value_stack);

                    // operator_loc
                    argv[1] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // value
                    argv[2] = rb_ary_pop(value_stack);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPCallOperatorAndWriteNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_CALL_OPERATOR_OR_WRITE_NODE: {
                    yp_call_operator_or_write_node_t *cast = (yp_call_operator_or_write_node_t *) node;
                    VALUE argv[4];

                    // target
                    argv[0] = rb_ary_pop(value_stack);

                    // value
                    argv[1] = rb_ary_pop(value_stack);

                    // operator_loc
                    argv[2] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPCallOperatorOrWriteNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_CALL_OPERATOR_WRITE_NODE: {
                    yp_call_operator_write_node_t *cast = (yp_call_operator_write_node_t *) node;
                    VALUE argv[5];

                    // target
                    argv[0] = rb_ary_pop(value_stack);

                    // operator_loc
                    argv[1] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // value
                    argv[2] = rb_ary_pop(value_stack);

                    // operator_id
                    argv[3] = rb_id2sym(constants[cast->operator_id - 1]);

                    // location
                    argv[4] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(5, argv, rb_cYARPCallOperatorWriteNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_CAPTURE_PATTERN_NODE: {
                    yp_capture_pattern_node_t *cast = (yp_capture_pattern_node_t *) node;
                    VALUE argv[4];

                    // value
                    argv[0] = rb_ary_pop(value_stack);

                    // target
                    argv[1] = rb_ary_pop(value_stack);

                    // operator_loc
                    argv[2] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPCapturePatternNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_CASE_NODE: {
                    yp_case_node_t *cast = (yp_case_node_t *) node;
                    VALUE argv[6];

                    // predicate
                    argv[0] = rb_ary_pop(value_stack);

                    // conditions
                    argv[1] = rb_ary_new_capa(cast->conditions.size);
                    for (size_t index = 0; index < cast->conditions.size; index++) {
                        rb_ary_push(argv[1], rb_ary_pop(value_stack));
                    }

                    // consequent
                    argv[2] = rb_ary_pop(value_stack);

                    // case_keyword_loc
                    argv[3] = yp_location_new(parser, cast->case_keyword_loc.start, cast->case_keyword_loc.end, source);

                    // end_keyword_loc
                    argv[4] = yp_location_new(parser, cast->end_keyword_loc.start, cast->end_keyword_loc.end, source);

                    // location
                    argv[5] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(6, argv, rb_cYARPCaseNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_CLASS_NODE: {
                    yp_class_node_t *cast = (yp_class_node_t *) node;
                    VALUE argv[8];

                    // locals
                    argv[0] = rb_ary_new_capa(cast->locals.size);
                    for (size_t index = 0; index < cast->locals.size; index++) {
                        rb_ary_push(argv[0], rb_id2sym(constants[cast->locals.ids[index] - 1]));
                    }

                    // class_keyword_loc
                    argv[1] = yp_location_new(parser, cast->class_keyword_loc.start, cast->class_keyword_loc.end, source);

                    // constant_path
                    argv[2] = rb_ary_pop(value_stack);

                    // inheritance_operator_loc
                    argv[3] = cast->inheritance_operator_loc.start == NULL ? Qnil : yp_location_new(parser, cast->inheritance_operator_loc.start, cast->inheritance_operator_loc.end, source);

                    // superclass
                    argv[4] = rb_ary_pop(value_stack);

                    // statements
                    argv[5] = rb_ary_pop(value_stack);

                    // end_keyword_loc
                    argv[6] = yp_location_new(parser, cast->end_keyword_loc.start, cast->end_keyword_loc.end, source);

                    // location
                    argv[7] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(8, argv, rb_cYARPClassNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_CLASS_VARIABLE_OPERATOR_AND_WRITE_NODE: {
                    yp_class_variable_operator_and_write_node_t *cast = (yp_class_variable_operator_and_write_node_t *) node;
                    VALUE argv[4];

                    // name_loc
                    argv[0] = yp_location_new(parser, cast->name_loc.start, cast->name_loc.end, source);

                    // operator_loc
                    argv[1] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // value
                    argv[2] = rb_ary_pop(value_stack);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPClassVariableOperatorAndWriteNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_CLASS_VARIABLE_OPERATOR_OR_WRITE_NODE: {
                    yp_class_variable_operator_or_write_node_t *cast = (yp_class_variable_operator_or_write_node_t *) node;
                    VALUE argv[4];

                    // name_loc
                    argv[0] = yp_location_new(parser, cast->name_loc.start, cast->name_loc.end, source);

                    // operator_loc
                    argv[1] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // value
                    argv[2] = rb_ary_pop(value_stack);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPClassVariableOperatorOrWriteNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_CLASS_VARIABLE_OPERATOR_WRITE_NODE: {
                    yp_class_variable_operator_write_node_t *cast = (yp_class_variable_operator_write_node_t *) node;
                    VALUE argv[5];

                    // name_loc
                    argv[0] = yp_location_new(parser, cast->name_loc.start, cast->name_loc.end, source);

                    // operator_loc
                    argv[1] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // value
                    argv[2] = rb_ary_pop(value_stack);

                    // operator
                    argv[3] = rb_id2sym(constants[cast->operator - 1]);

                    // location
                    argv[4] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(5, argv, rb_cYARPClassVariableOperatorWriteNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_CLASS_VARIABLE_READ_NODE: {
                    VALUE argv[1];

                    // location
                    argv[0] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(1, argv, rb_cYARPClassVariableReadNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_CLASS_VARIABLE_WRITE_NODE: {
                    yp_class_variable_write_node_t *cast = (yp_class_variable_write_node_t *) node;
                    VALUE argv[4];

                    // name_loc
                    argv[0] = yp_location_new(parser, cast->name_loc.start, cast->name_loc.end, source);

                    // value
                    argv[1] = rb_ary_pop(value_stack);

                    // operator_loc
                    argv[2] = cast->operator_loc.start == NULL ? Qnil : yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPClassVariableWriteNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_CONSTANT_OPERATOR_AND_WRITE_NODE: {
                    yp_constant_operator_and_write_node_t *cast = (yp_constant_operator_and_write_node_t *) node;
                    VALUE argv[4];

                    // name_loc
                    argv[0] = yp_location_new(parser, cast->name_loc.start, cast->name_loc.end, source);

                    // operator_loc
                    argv[1] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // value
                    argv[2] = rb_ary_pop(value_stack);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPConstantOperatorAndWriteNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_CONSTANT_OPERATOR_OR_WRITE_NODE: {
                    yp_constant_operator_or_write_node_t *cast = (yp_constant_operator_or_write_node_t *) node;
                    VALUE argv[4];

                    // name_loc
                    argv[0] = yp_location_new(parser, cast->name_loc.start, cast->name_loc.end, source);

                    // operator_loc
                    argv[1] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // value
                    argv[2] = rb_ary_pop(value_stack);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPConstantOperatorOrWriteNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_CONSTANT_OPERATOR_WRITE_NODE: {
                    yp_constant_operator_write_node_t *cast = (yp_constant_operator_write_node_t *) node;
                    VALUE argv[5];

                    // name_loc
                    argv[0] = yp_location_new(parser, cast->name_loc.start, cast->name_loc.end, source);

                    // operator_loc
                    argv[1] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // value
                    argv[2] = rb_ary_pop(value_stack);

                    // operator
                    argv[3] = rb_id2sym(constants[cast->operator - 1]);

                    // location
                    argv[4] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(5, argv, rb_cYARPConstantOperatorWriteNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_CONSTANT_PATH_NODE: {
                    yp_constant_path_node_t *cast = (yp_constant_path_node_t *) node;
                    VALUE argv[4];

                    // parent
                    argv[0] = rb_ary_pop(value_stack);

                    // child
                    argv[1] = rb_ary_pop(value_stack);

                    // delimiter_loc
                    argv[2] = yp_location_new(parser, cast->delimiter_loc.start, cast->delimiter_loc.end, source);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPConstantPathNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_CONSTANT_PATH_OPERATOR_AND_WRITE_NODE: {
                    yp_constant_path_operator_and_write_node_t *cast = (yp_constant_path_operator_and_write_node_t *) node;
                    VALUE argv[4];

                    // target
                    argv[0] = rb_ary_pop(value_stack);

                    // operator_loc
                    argv[1] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // value
                    argv[2] = rb_ary_pop(value_stack);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPConstantPathOperatorAndWriteNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_CONSTANT_PATH_OPERATOR_OR_WRITE_NODE: {
                    yp_constant_path_operator_or_write_node_t *cast = (yp_constant_path_operator_or_write_node_t *) node;
                    VALUE argv[4];

                    // target
                    argv[0] = rb_ary_pop(value_stack);

                    // operator_loc
                    argv[1] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // value
                    argv[2] = rb_ary_pop(value_stack);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPConstantPathOperatorOrWriteNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_CONSTANT_PATH_OPERATOR_WRITE_NODE: {
                    yp_constant_path_operator_write_node_t *cast = (yp_constant_path_operator_write_node_t *) node;
                    VALUE argv[5];

                    // target
                    argv[0] = rb_ary_pop(value_stack);

                    // operator_loc
                    argv[1] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // value
                    argv[2] = rb_ary_pop(value_stack);

                    // operator
                    argv[3] = rb_id2sym(constants[cast->operator - 1]);

                    // location
                    argv[4] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(5, argv, rb_cYARPConstantPathOperatorWriteNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_CONSTANT_PATH_WRITE_NODE: {
                    yp_constant_path_write_node_t *cast = (yp_constant_path_write_node_t *) node;
                    VALUE argv[4];

                    // target
                    argv[0] = rb_ary_pop(value_stack);

                    // operator_loc
                    argv[1] = cast->operator_loc.start == NULL ? Qnil : yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // value
                    argv[2] = rb_ary_pop(value_stack);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPConstantPathWriteNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_CONSTANT_READ_NODE: {
                    VALUE argv[1];

                    // location
                    argv[0] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(1, argv, rb_cYARPConstantReadNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_CONSTANT_WRITE_NODE: {
                    yp_constant_write_node_t *cast = (yp_constant_write_node_t *) node;
                    VALUE argv[4];

                    // name_loc
                    argv[0] = yp_location_new(parser, cast->name_loc.start, cast->name_loc.end, source);

                    // value
                    argv[1] = rb_ary_pop(value_stack);

                    // operator_loc
                    argv[2] = cast->operator_loc.start == NULL ? Qnil : yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPConstantWriteNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_DEF_NODE: {
                    yp_def_node_t *cast = (yp_def_node_t *) node;
                    VALUE argv[12];

                    // name_loc
                    argv[0] = yp_location_new(parser, cast->name_loc.start, cast->name_loc.end, source);

                    // receiver
                    argv[1] = rb_ary_pop(value_stack);

                    // parameters
                    argv[2] = rb_ary_pop(value_stack);

                    // statements
                    argv[3] = rb_ary_pop(value_stack);

                    // locals
                    argv[4] = rb_ary_new_capa(cast->locals.size);
                    for (size_t index = 0; index < cast->locals.size; index++) {
                        rb_ary_push(argv[4], rb_id2sym(constants[cast->locals.ids[index] - 1]));
                    }

                    // def_keyword_loc
                    argv[5] = yp_location_new(parser, cast->def_keyword_loc.start, cast->def_keyword_loc.end, source);

                    // operator_loc
                    argv[6] = cast->operator_loc.start == NULL ? Qnil : yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // lparen_loc
                    argv[7] = cast->lparen_loc.start == NULL ? Qnil : yp_location_new(parser, cast->lparen_loc.start, cast->lparen_loc.end, source);

                    // rparen_loc
                    argv[8] = cast->rparen_loc.start == NULL ? Qnil : yp_location_new(parser, cast->rparen_loc.start, cast->rparen_loc.end, source);

                    // equal_loc
                    argv[9] = cast->equal_loc.start == NULL ? Qnil : yp_location_new(parser, cast->equal_loc.start, cast->equal_loc.end, source);

                    // end_keyword_loc
                    argv[10] = cast->end_keyword_loc.start == NULL ? Qnil : yp_location_new(parser, cast->end_keyword_loc.start, cast->end_keyword_loc.end, source);

                    // location
                    argv[11] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(12, argv, rb_cYARPDefNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_DEFINED_NODE: {
                    yp_defined_node_t *cast = (yp_defined_node_t *) node;
                    VALUE argv[5];

                    // lparen_loc
                    argv[0] = cast->lparen_loc.start == NULL ? Qnil : yp_location_new(parser, cast->lparen_loc.start, cast->lparen_loc.end, source);

                    // value
                    argv[1] = rb_ary_pop(value_stack);

                    // rparen_loc
                    argv[2] = cast->rparen_loc.start == NULL ? Qnil : yp_location_new(parser, cast->rparen_loc.start, cast->rparen_loc.end, source);

                    // keyword_loc
                    argv[3] = yp_location_new(parser, cast->keyword_loc.start, cast->keyword_loc.end, source);

                    // location
                    argv[4] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(5, argv, rb_cYARPDefinedNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_ELSE_NODE: {
                    yp_else_node_t *cast = (yp_else_node_t *) node;
                    VALUE argv[4];

                    // else_keyword_loc
                    argv[0] = yp_location_new(parser, cast->else_keyword_loc.start, cast->else_keyword_loc.end, source);

                    // statements
                    argv[1] = rb_ary_pop(value_stack);

                    // end_keyword_loc
                    argv[2] = cast->end_keyword_loc.start == NULL ? Qnil : yp_location_new(parser, cast->end_keyword_loc.start, cast->end_keyword_loc.end, source);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPElseNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_EMBEDDED_STATEMENTS_NODE: {
                    yp_embedded_statements_node_t *cast = (yp_embedded_statements_node_t *) node;
                    VALUE argv[4];

                    // opening_loc
                    argv[0] = yp_location_new(parser, cast->opening_loc.start, cast->opening_loc.end, source);

                    // statements
                    argv[1] = rb_ary_pop(value_stack);

                    // closing_loc
                    argv[2] = yp_location_new(parser, cast->closing_loc.start, cast->closing_loc.end, source);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPEmbeddedStatementsNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_EMBEDDED_VARIABLE_NODE: {
                    yp_embedded_variable_node_t *cast = (yp_embedded_variable_node_t *) node;
                    VALUE argv[3];

                    // operator_loc
                    argv[0] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // variable
                    argv[1] = rb_ary_pop(value_stack);

                    // location
                    argv[2] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(3, argv, rb_cYARPEmbeddedVariableNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_ENSURE_NODE: {
                    yp_ensure_node_t *cast = (yp_ensure_node_t *) node;
                    VALUE argv[4];

                    // ensure_keyword_loc
                    argv[0] = yp_location_new(parser, cast->ensure_keyword_loc.start, cast->ensure_keyword_loc.end, source);

                    // statements
                    argv[1] = rb_ary_pop(value_stack);

                    // end_keyword_loc
                    argv[2] = yp_location_new(parser, cast->end_keyword_loc.start, cast->end_keyword_loc.end, source);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPEnsureNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_FALSE_NODE: {
                    VALUE argv[1];

                    // location
                    argv[0] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(1, argv, rb_cYARPFalseNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_FIND_PATTERN_NODE: {
                    yp_find_pattern_node_t *cast = (yp_find_pattern_node_t *) node;
                    VALUE argv[7];

                    // constant
                    argv[0] = rb_ary_pop(value_stack);

                    // left
                    argv[1] = rb_ary_pop(value_stack);

                    // requireds
                    argv[2] = rb_ary_new_capa(cast->requireds.size);
                    for (size_t index = 0; index < cast->requireds.size; index++) {
                        rb_ary_push(argv[2], rb_ary_pop(value_stack));
                    }

                    // right
                    argv[3] = rb_ary_pop(value_stack);

                    // opening_loc
                    argv[4] = cast->opening_loc.start == NULL ? Qnil : yp_location_new(parser, cast->opening_loc.start, cast->opening_loc.end, source);

                    // closing_loc
                    argv[5] = cast->closing_loc.start == NULL ? Qnil : yp_location_new(parser, cast->closing_loc.start, cast->closing_loc.end, source);

                    // location
                    argv[6] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(7, argv, rb_cYARPFindPatternNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_FLIP_FLOP_NODE: {
                    yp_flip_flop_node_t *cast = (yp_flip_flop_node_t *) node;
                    VALUE argv[5];

                    // left
                    argv[0] = rb_ary_pop(value_stack);

                    // right
                    argv[1] = rb_ary_pop(value_stack);

                    // operator_loc
                    argv[2] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // flags
                    argv[3] = ULONG2NUM(node->flags >> 1);

                    // location
                    argv[4] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(5, argv, rb_cYARPFlipFlopNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_FLOAT_NODE: {
                    VALUE argv[1];

                    // location
                    argv[0] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(1, argv, rb_cYARPFloatNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_FOR_NODE: {
                    yp_for_node_t *cast = (yp_for_node_t *) node;
                    VALUE argv[8];

                    // index
                    argv[0] = rb_ary_pop(value_stack);

                    // collection
                    argv[1] = rb_ary_pop(value_stack);

                    // statements
                    argv[2] = rb_ary_pop(value_stack);

                    // for_keyword_loc
                    argv[3] = yp_location_new(parser, cast->for_keyword_loc.start, cast->for_keyword_loc.end, source);

                    // in_keyword_loc
                    argv[4] = yp_location_new(parser, cast->in_keyword_loc.start, cast->in_keyword_loc.end, source);

                    // do_keyword_loc
                    argv[5] = cast->do_keyword_loc.start == NULL ? Qnil : yp_location_new(parser, cast->do_keyword_loc.start, cast->do_keyword_loc.end, source);

                    // end_keyword_loc
                    argv[6] = yp_location_new(parser, cast->end_keyword_loc.start, cast->end_keyword_loc.end, source);

                    // location
                    argv[7] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(8, argv, rb_cYARPForNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_FORWARDING_ARGUMENTS_NODE: {
                    VALUE argv[1];

                    // location
                    argv[0] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(1, argv, rb_cYARPForwardingArgumentsNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_FORWARDING_PARAMETER_NODE: {
                    VALUE argv[1];

                    // location
                    argv[0] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(1, argv, rb_cYARPForwardingParameterNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_FORWARDING_SUPER_NODE: {
                    VALUE argv[2];

                    // block
                    argv[0] = rb_ary_pop(value_stack);

                    // location
                    argv[1] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(2, argv, rb_cYARPForwardingSuperNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_GLOBAL_VARIABLE_OPERATOR_AND_WRITE_NODE: {
                    yp_global_variable_operator_and_write_node_t *cast = (yp_global_variable_operator_and_write_node_t *) node;
                    VALUE argv[4];

                    // name_loc
                    argv[0] = yp_location_new(parser, cast->name_loc.start, cast->name_loc.end, source);

                    // operator_loc
                    argv[1] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // value
                    argv[2] = rb_ary_pop(value_stack);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPGlobalVariableOperatorAndWriteNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_GLOBAL_VARIABLE_OPERATOR_OR_WRITE_NODE: {
                    yp_global_variable_operator_or_write_node_t *cast = (yp_global_variable_operator_or_write_node_t *) node;
                    VALUE argv[4];

                    // name_loc
                    argv[0] = yp_location_new(parser, cast->name_loc.start, cast->name_loc.end, source);

                    // operator_loc
                    argv[1] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // value
                    argv[2] = rb_ary_pop(value_stack);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPGlobalVariableOperatorOrWriteNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_GLOBAL_VARIABLE_OPERATOR_WRITE_NODE: {
                    yp_global_variable_operator_write_node_t *cast = (yp_global_variable_operator_write_node_t *) node;
                    VALUE argv[5];

                    // name_loc
                    argv[0] = yp_location_new(parser, cast->name_loc.start, cast->name_loc.end, source);

                    // operator_loc
                    argv[1] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // value
                    argv[2] = rb_ary_pop(value_stack);

                    // operator
                    argv[3] = rb_id2sym(constants[cast->operator - 1]);

                    // location
                    argv[4] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(5, argv, rb_cYARPGlobalVariableOperatorWriteNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_GLOBAL_VARIABLE_READ_NODE: {
                    VALUE argv[1];

                    // location
                    argv[0] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(1, argv, rb_cYARPGlobalVariableReadNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_GLOBAL_VARIABLE_WRITE_NODE: {
                    yp_global_variable_write_node_t *cast = (yp_global_variable_write_node_t *) node;
                    VALUE argv[4];

                    // name_loc
                    argv[0] = yp_location_new(parser, cast->name_loc.start, cast->name_loc.end, source);

                    // operator_loc
                    argv[1] = cast->operator_loc.start == NULL ? Qnil : yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // value
                    argv[2] = rb_ary_pop(value_stack);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPGlobalVariableWriteNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_HASH_NODE: {
                    yp_hash_node_t *cast = (yp_hash_node_t *) node;
                    VALUE argv[4];

                    // opening_loc
                    argv[0] = yp_location_new(parser, cast->opening_loc.start, cast->opening_loc.end, source);

                    // elements
                    argv[1] = rb_ary_new_capa(cast->elements.size);
                    for (size_t index = 0; index < cast->elements.size; index++) {
                        rb_ary_push(argv[1], rb_ary_pop(value_stack));
                    }

                    // closing_loc
                    argv[2] = yp_location_new(parser, cast->closing_loc.start, cast->closing_loc.end, source);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPHashNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_HASH_PATTERN_NODE: {
                    yp_hash_pattern_node_t *cast = (yp_hash_pattern_node_t *) node;
                    VALUE argv[6];

                    // constant
                    argv[0] = rb_ary_pop(value_stack);

                    // assocs
                    argv[1] = rb_ary_new_capa(cast->assocs.size);
                    for (size_t index = 0; index < cast->assocs.size; index++) {
                        rb_ary_push(argv[1], rb_ary_pop(value_stack));
                    }

                    // kwrest
                    argv[2] = rb_ary_pop(value_stack);

                    // opening_loc
                    argv[3] = cast->opening_loc.start == NULL ? Qnil : yp_location_new(parser, cast->opening_loc.start, cast->opening_loc.end, source);

                    // closing_loc
                    argv[4] = cast->closing_loc.start == NULL ? Qnil : yp_location_new(parser, cast->closing_loc.start, cast->closing_loc.end, source);

                    // location
                    argv[5] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(6, argv, rb_cYARPHashPatternNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_IF_NODE: {
                    yp_if_node_t *cast = (yp_if_node_t *) node;
                    VALUE argv[6];

                    // if_keyword_loc
                    argv[0] = cast->if_keyword_loc.start == NULL ? Qnil : yp_location_new(parser, cast->if_keyword_loc.start, cast->if_keyword_loc.end, source);

                    // predicate
                    argv[1] = rb_ary_pop(value_stack);

                    // statements
                    argv[2] = rb_ary_pop(value_stack);

                    // consequent
                    argv[3] = rb_ary_pop(value_stack);

                    // end_keyword_loc
                    argv[4] = cast->end_keyword_loc.start == NULL ? Qnil : yp_location_new(parser, cast->end_keyword_loc.start, cast->end_keyword_loc.end, source);

                    // location
                    argv[5] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(6, argv, rb_cYARPIfNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_IMAGINARY_NODE: {
                    VALUE argv[2];

                    // numeric
                    argv[0] = rb_ary_pop(value_stack);

                    // location
                    argv[1] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(2, argv, rb_cYARPImaginaryNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_IN_NODE: {
                    yp_in_node_t *cast = (yp_in_node_t *) node;
                    VALUE argv[5];

                    // pattern
                    argv[0] = rb_ary_pop(value_stack);

                    // statements
                    argv[1] = rb_ary_pop(value_stack);

                    // in_loc
                    argv[2] = yp_location_new(parser, cast->in_loc.start, cast->in_loc.end, source);

                    // then_loc
                    argv[3] = cast->then_loc.start == NULL ? Qnil : yp_location_new(parser, cast->then_loc.start, cast->then_loc.end, source);

                    // location
                    argv[4] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(5, argv, rb_cYARPInNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_INSTANCE_VARIABLE_OPERATOR_AND_WRITE_NODE: {
                    yp_instance_variable_operator_and_write_node_t *cast = (yp_instance_variable_operator_and_write_node_t *) node;
                    VALUE argv[4];

                    // name_loc
                    argv[0] = yp_location_new(parser, cast->name_loc.start, cast->name_loc.end, source);

                    // operator_loc
                    argv[1] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // value
                    argv[2] = rb_ary_pop(value_stack);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPInstanceVariableOperatorAndWriteNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_INSTANCE_VARIABLE_OPERATOR_OR_WRITE_NODE: {
                    yp_instance_variable_operator_or_write_node_t *cast = (yp_instance_variable_operator_or_write_node_t *) node;
                    VALUE argv[4];

                    // name_loc
                    argv[0] = yp_location_new(parser, cast->name_loc.start, cast->name_loc.end, source);

                    // operator_loc
                    argv[1] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // value
                    argv[2] = rb_ary_pop(value_stack);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPInstanceVariableOperatorOrWriteNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_INSTANCE_VARIABLE_OPERATOR_WRITE_NODE: {
                    yp_instance_variable_operator_write_node_t *cast = (yp_instance_variable_operator_write_node_t *) node;
                    VALUE argv[5];

                    // name_loc
                    argv[0] = yp_location_new(parser, cast->name_loc.start, cast->name_loc.end, source);

                    // operator_loc
                    argv[1] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // value
                    argv[2] = rb_ary_pop(value_stack);

                    // operator
                    argv[3] = rb_id2sym(constants[cast->operator - 1]);

                    // location
                    argv[4] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(5, argv, rb_cYARPInstanceVariableOperatorWriteNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_INSTANCE_VARIABLE_READ_NODE: {
                    VALUE argv[1];

                    // location
                    argv[0] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(1, argv, rb_cYARPInstanceVariableReadNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_INSTANCE_VARIABLE_WRITE_NODE: {
                    yp_instance_variable_write_node_t *cast = (yp_instance_variable_write_node_t *) node;
                    VALUE argv[4];

                    // name_loc
                    argv[0] = yp_location_new(parser, cast->name_loc.start, cast->name_loc.end, source);

                    // value
                    argv[1] = rb_ary_pop(value_stack);

                    // operator_loc
                    argv[2] = cast->operator_loc.start == NULL ? Qnil : yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPInstanceVariableWriteNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_INTEGER_NODE: {
                    VALUE argv[1];

                    // location
                    argv[0] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(1, argv, rb_cYARPIntegerNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_INTERPOLATED_REGULAR_EXPRESSION_NODE: {
                    yp_interpolated_regular_expression_node_t *cast = (yp_interpolated_regular_expression_node_t *) node;
                    VALUE argv[5];

                    // opening_loc
                    argv[0] = yp_location_new(parser, cast->opening_loc.start, cast->opening_loc.end, source);

                    // parts
                    argv[1] = rb_ary_new_capa(cast->parts.size);
                    for (size_t index = 0; index < cast->parts.size; index++) {
                        rb_ary_push(argv[1], rb_ary_pop(value_stack));
                    }

                    // closing_loc
                    argv[2] = yp_location_new(parser, cast->closing_loc.start, cast->closing_loc.end, source);

                    // flags
                    argv[3] = ULONG2NUM(node->flags >> 1);

                    // location
                    argv[4] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(5, argv, rb_cYARPInterpolatedRegularExpressionNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_INTERPOLATED_STRING_NODE: {
                    yp_interpolated_string_node_t *cast = (yp_interpolated_string_node_t *) node;
                    VALUE argv[4];

                    // opening_loc
                    argv[0] = cast->opening_loc.start == NULL ? Qnil : yp_location_new(parser, cast->opening_loc.start, cast->opening_loc.end, source);

                    // parts
                    argv[1] = rb_ary_new_capa(cast->parts.size);
                    for (size_t index = 0; index < cast->parts.size; index++) {
                        rb_ary_push(argv[1], rb_ary_pop(value_stack));
                    }

                    // closing_loc
                    argv[2] = cast->closing_loc.start == NULL ? Qnil : yp_location_new(parser, cast->closing_loc.start, cast->closing_loc.end, source);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPInterpolatedStringNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_INTERPOLATED_SYMBOL_NODE: {
                    yp_interpolated_symbol_node_t *cast = (yp_interpolated_symbol_node_t *) node;
                    VALUE argv[4];

                    // opening_loc
                    argv[0] = cast->opening_loc.start == NULL ? Qnil : yp_location_new(parser, cast->opening_loc.start, cast->opening_loc.end, source);

                    // parts
                    argv[1] = rb_ary_new_capa(cast->parts.size);
                    for (size_t index = 0; index < cast->parts.size; index++) {
                        rb_ary_push(argv[1], rb_ary_pop(value_stack));
                    }

                    // closing_loc
                    argv[2] = cast->closing_loc.start == NULL ? Qnil : yp_location_new(parser, cast->closing_loc.start, cast->closing_loc.end, source);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPInterpolatedSymbolNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_INTERPOLATED_X_STRING_NODE: {
                    yp_interpolated_x_string_node_t *cast = (yp_interpolated_x_string_node_t *) node;
                    VALUE argv[4];

                    // opening_loc
                    argv[0] = yp_location_new(parser, cast->opening_loc.start, cast->opening_loc.end, source);

                    // parts
                    argv[1] = rb_ary_new_capa(cast->parts.size);
                    for (size_t index = 0; index < cast->parts.size; index++) {
                        rb_ary_push(argv[1], rb_ary_pop(value_stack));
                    }

                    // closing_loc
                    argv[2] = yp_location_new(parser, cast->closing_loc.start, cast->closing_loc.end, source);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPInterpolatedXStringNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_KEYWORD_HASH_NODE: {
                    yp_keyword_hash_node_t *cast = (yp_keyword_hash_node_t *) node;
                    VALUE argv[2];

                    // elements
                    argv[0] = rb_ary_new_capa(cast->elements.size);
                    for (size_t index = 0; index < cast->elements.size; index++) {
                        rb_ary_push(argv[0], rb_ary_pop(value_stack));
                    }

                    // location
                    argv[1] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(2, argv, rb_cYARPKeywordHashNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_KEYWORD_PARAMETER_NODE: {
                    yp_keyword_parameter_node_t *cast = (yp_keyword_parameter_node_t *) node;
                    VALUE argv[3];

                    // name_loc
                    argv[0] = yp_location_new(parser, cast->name_loc.start, cast->name_loc.end, source);

                    // value
                    argv[1] = rb_ary_pop(value_stack);

                    // location
                    argv[2] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(3, argv, rb_cYARPKeywordParameterNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_KEYWORD_REST_PARAMETER_NODE: {
                    yp_keyword_rest_parameter_node_t *cast = (yp_keyword_rest_parameter_node_t *) node;
                    VALUE argv[3];

                    // operator_loc
                    argv[0] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // name_loc
                    argv[1] = cast->name_loc.start == NULL ? Qnil : yp_location_new(parser, cast->name_loc.start, cast->name_loc.end, source);

                    // location
                    argv[2] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(3, argv, rb_cYARPKeywordRestParameterNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_LAMBDA_NODE: {
                    yp_lambda_node_t *cast = (yp_lambda_node_t *) node;
                    VALUE argv[5];

                    // locals
                    argv[0] = rb_ary_new_capa(cast->locals.size);
                    for (size_t index = 0; index < cast->locals.size; index++) {
                        rb_ary_push(argv[0], rb_id2sym(constants[cast->locals.ids[index] - 1]));
                    }

                    // opening_loc
                    argv[1] = yp_location_new(parser, cast->opening_loc.start, cast->opening_loc.end, source);

                    // parameters
                    argv[2] = rb_ary_pop(value_stack);

                    // statements
                    argv[3] = rb_ary_pop(value_stack);

                    // location
                    argv[4] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(5, argv, rb_cYARPLambdaNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_LOCAL_VARIABLE_OPERATOR_AND_WRITE_NODE: {
                    yp_local_variable_operator_and_write_node_t *cast = (yp_local_variable_operator_and_write_node_t *) node;
                    VALUE argv[5];

                    // name_loc
                    argv[0] = yp_location_new(parser, cast->name_loc.start, cast->name_loc.end, source);

                    // operator_loc
                    argv[1] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // value
                    argv[2] = rb_ary_pop(value_stack);

                    // constant_id
                    argv[3] = rb_id2sym(constants[cast->constant_id - 1]);

                    // location
                    argv[4] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(5, argv, rb_cYARPLocalVariableOperatorAndWriteNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_LOCAL_VARIABLE_OPERATOR_OR_WRITE_NODE: {
                    yp_local_variable_operator_or_write_node_t *cast = (yp_local_variable_operator_or_write_node_t *) node;
                    VALUE argv[5];

                    // name_loc
                    argv[0] = yp_location_new(parser, cast->name_loc.start, cast->name_loc.end, source);

                    // operator_loc
                    argv[1] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // value
                    argv[2] = rb_ary_pop(value_stack);

                    // constant_id
                    argv[3] = rb_id2sym(constants[cast->constant_id - 1]);

                    // location
                    argv[4] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(5, argv, rb_cYARPLocalVariableOperatorOrWriteNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_LOCAL_VARIABLE_OPERATOR_WRITE_NODE: {
                    yp_local_variable_operator_write_node_t *cast = (yp_local_variable_operator_write_node_t *) node;
                    VALUE argv[6];

                    // name_loc
                    argv[0] = yp_location_new(parser, cast->name_loc.start, cast->name_loc.end, source);

                    // operator_loc
                    argv[1] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // value
                    argv[2] = rb_ary_pop(value_stack);

                    // constant_id
                    argv[3] = rb_id2sym(constants[cast->constant_id - 1]);

                    // operator_id
                    argv[4] = rb_id2sym(constants[cast->operator_id - 1]);

                    // location
                    argv[5] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(6, argv, rb_cYARPLocalVariableOperatorWriteNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_LOCAL_VARIABLE_READ_NODE: {
                    yp_local_variable_read_node_t *cast = (yp_local_variable_read_node_t *) node;
                    VALUE argv[3];

                    // constant_id
                    argv[0] = rb_id2sym(constants[cast->constant_id - 1]);

                    // depth
                    argv[1] = ULONG2NUM(cast->depth);

                    // location
                    argv[2] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(3, argv, rb_cYARPLocalVariableReadNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_LOCAL_VARIABLE_WRITE_NODE: {
                    yp_local_variable_write_node_t *cast = (yp_local_variable_write_node_t *) node;
                    VALUE argv[6];

                    // constant_id
                    argv[0] = rb_id2sym(constants[cast->constant_id - 1]);

                    // depth
                    argv[1] = ULONG2NUM(cast->depth);

                    // value
                    argv[2] = rb_ary_pop(value_stack);

                    // name_loc
                    argv[3] = yp_location_new(parser, cast->name_loc.start, cast->name_loc.end, source);

                    // operator_loc
                    argv[4] = cast->operator_loc.start == NULL ? Qnil : yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // location
                    argv[5] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(6, argv, rb_cYARPLocalVariableWriteNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_MATCH_PREDICATE_NODE: {
                    yp_match_predicate_node_t *cast = (yp_match_predicate_node_t *) node;
                    VALUE argv[4];

                    // value
                    argv[0] = rb_ary_pop(value_stack);

                    // pattern
                    argv[1] = rb_ary_pop(value_stack);

                    // operator_loc
                    argv[2] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPMatchPredicateNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_MATCH_REQUIRED_NODE: {
                    yp_match_required_node_t *cast = (yp_match_required_node_t *) node;
                    VALUE argv[4];

                    // value
                    argv[0] = rb_ary_pop(value_stack);

                    // pattern
                    argv[1] = rb_ary_pop(value_stack);

                    // operator_loc
                    argv[2] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPMatchRequiredNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_MISSING_NODE: {
                    VALUE argv[1];

                    // location
                    argv[0] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(1, argv, rb_cYARPMissingNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_MODULE_NODE: {
                    yp_module_node_t *cast = (yp_module_node_t *) node;
                    VALUE argv[6];

                    // locals
                    argv[0] = rb_ary_new_capa(cast->locals.size);
                    for (size_t index = 0; index < cast->locals.size; index++) {
                        rb_ary_push(argv[0], rb_id2sym(constants[cast->locals.ids[index] - 1]));
                    }

                    // module_keyword_loc
                    argv[1] = yp_location_new(parser, cast->module_keyword_loc.start, cast->module_keyword_loc.end, source);

                    // constant_path
                    argv[2] = rb_ary_pop(value_stack);

                    // statements
                    argv[3] = rb_ary_pop(value_stack);

                    // end_keyword_loc
                    argv[4] = yp_location_new(parser, cast->end_keyword_loc.start, cast->end_keyword_loc.end, source);

                    // location
                    argv[5] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(6, argv, rb_cYARPModuleNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_MULTI_WRITE_NODE: {
                    yp_multi_write_node_t *cast = (yp_multi_write_node_t *) node;
                    VALUE argv[6];

                    // targets
                    argv[0] = rb_ary_new_capa(cast->targets.size);
                    for (size_t index = 0; index < cast->targets.size; index++) {
                        rb_ary_push(argv[0], rb_ary_pop(value_stack));
                    }

                    // operator_loc
                    argv[1] = cast->operator_loc.start == NULL ? Qnil : yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // value
                    argv[2] = rb_ary_pop(value_stack);

                    // lparen_loc
                    argv[3] = cast->lparen_loc.start == NULL ? Qnil : yp_location_new(parser, cast->lparen_loc.start, cast->lparen_loc.end, source);

                    // rparen_loc
                    argv[4] = cast->rparen_loc.start == NULL ? Qnil : yp_location_new(parser, cast->rparen_loc.start, cast->rparen_loc.end, source);

                    // location
                    argv[5] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(6, argv, rb_cYARPMultiWriteNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_NEXT_NODE: {
                    yp_next_node_t *cast = (yp_next_node_t *) node;
                    VALUE argv[3];

                    // arguments
                    argv[0] = rb_ary_pop(value_stack);

                    // keyword_loc
                    argv[1] = yp_location_new(parser, cast->keyword_loc.start, cast->keyword_loc.end, source);

                    // location
                    argv[2] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(3, argv, rb_cYARPNextNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_NIL_NODE: {
                    VALUE argv[1];

                    // location
                    argv[0] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(1, argv, rb_cYARPNilNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_NO_KEYWORDS_PARAMETER_NODE: {
                    yp_no_keywords_parameter_node_t *cast = (yp_no_keywords_parameter_node_t *) node;
                    VALUE argv[3];

                    // operator_loc
                    argv[0] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // keyword_loc
                    argv[1] = yp_location_new(parser, cast->keyword_loc.start, cast->keyword_loc.end, source);

                    // location
                    argv[2] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(3, argv, rb_cYARPNoKeywordsParameterNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_NUMBERED_REFERENCE_READ_NODE: {
                    VALUE argv[1];

                    // location
                    argv[0] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(1, argv, rb_cYARPNumberedReferenceReadNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_OPTIONAL_PARAMETER_NODE: {
                    yp_optional_parameter_node_t *cast = (yp_optional_parameter_node_t *) node;
                    VALUE argv[5];

                    // constant_id
                    argv[0] = rb_id2sym(constants[cast->constant_id - 1]);

                    // name_loc
                    argv[1] = yp_location_new(parser, cast->name_loc.start, cast->name_loc.end, source);

                    // operator_loc
                    argv[2] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // value
                    argv[3] = rb_ary_pop(value_stack);

                    // location
                    argv[4] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(5, argv, rb_cYARPOptionalParameterNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_OR_NODE: {
                    yp_or_node_t *cast = (yp_or_node_t *) node;
                    VALUE argv[4];

                    // left
                    argv[0] = rb_ary_pop(value_stack);

                    // right
                    argv[1] = rb_ary_pop(value_stack);

                    // operator_loc
                    argv[2] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPOrNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_PARAMETERS_NODE: {
                    yp_parameters_node_t *cast = (yp_parameters_node_t *) node;
                    VALUE argv[8];

                    // requireds
                    argv[0] = rb_ary_new_capa(cast->requireds.size);
                    for (size_t index = 0; index < cast->requireds.size; index++) {
                        rb_ary_push(argv[0], rb_ary_pop(value_stack));
                    }

                    // optionals
                    argv[1] = rb_ary_new_capa(cast->optionals.size);
                    for (size_t index = 0; index < cast->optionals.size; index++) {
                        rb_ary_push(argv[1], rb_ary_pop(value_stack));
                    }

                    // posts
                    argv[2] = rb_ary_new_capa(cast->posts.size);
                    for (size_t index = 0; index < cast->posts.size; index++) {
                        rb_ary_push(argv[2], rb_ary_pop(value_stack));
                    }

                    // rest
                    argv[3] = rb_ary_pop(value_stack);

                    // keywords
                    argv[4] = rb_ary_new_capa(cast->keywords.size);
                    for (size_t index = 0; index < cast->keywords.size; index++) {
                        rb_ary_push(argv[4], rb_ary_pop(value_stack));
                    }

                    // keyword_rest
                    argv[5] = rb_ary_pop(value_stack);

                    // block
                    argv[6] = rb_ary_pop(value_stack);

                    // location
                    argv[7] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(8, argv, rb_cYARPParametersNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_PARENTHESES_NODE: {
                    yp_parentheses_node_t *cast = (yp_parentheses_node_t *) node;
                    VALUE argv[4];

                    // statements
                    argv[0] = rb_ary_pop(value_stack);

                    // opening_loc
                    argv[1] = yp_location_new(parser, cast->opening_loc.start, cast->opening_loc.end, source);

                    // closing_loc
                    argv[2] = yp_location_new(parser, cast->closing_loc.start, cast->closing_loc.end, source);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPParenthesesNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_PINNED_EXPRESSION_NODE: {
                    yp_pinned_expression_node_t *cast = (yp_pinned_expression_node_t *) node;
                    VALUE argv[5];

                    // expression
                    argv[0] = rb_ary_pop(value_stack);

                    // operator_loc
                    argv[1] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // lparen_loc
                    argv[2] = yp_location_new(parser, cast->lparen_loc.start, cast->lparen_loc.end, source);

                    // rparen_loc
                    argv[3] = yp_location_new(parser, cast->rparen_loc.start, cast->rparen_loc.end, source);

                    // location
                    argv[4] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(5, argv, rb_cYARPPinnedExpressionNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_PINNED_VARIABLE_NODE: {
                    yp_pinned_variable_node_t *cast = (yp_pinned_variable_node_t *) node;
                    VALUE argv[3];

                    // variable
                    argv[0] = rb_ary_pop(value_stack);

                    // operator_loc
                    argv[1] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // location
                    argv[2] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(3, argv, rb_cYARPPinnedVariableNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_POST_EXECUTION_NODE: {
                    yp_post_execution_node_t *cast = (yp_post_execution_node_t *) node;
                    VALUE argv[5];

                    // statements
                    argv[0] = rb_ary_pop(value_stack);

                    // keyword_loc
                    argv[1] = yp_location_new(parser, cast->keyword_loc.start, cast->keyword_loc.end, source);

                    // opening_loc
                    argv[2] = yp_location_new(parser, cast->opening_loc.start, cast->opening_loc.end, source);

                    // closing_loc
                    argv[3] = yp_location_new(parser, cast->closing_loc.start, cast->closing_loc.end, source);

                    // location
                    argv[4] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(5, argv, rb_cYARPPostExecutionNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_PRE_EXECUTION_NODE: {
                    yp_pre_execution_node_t *cast = (yp_pre_execution_node_t *) node;
                    VALUE argv[5];

                    // statements
                    argv[0] = rb_ary_pop(value_stack);

                    // keyword_loc
                    argv[1] = yp_location_new(parser, cast->keyword_loc.start, cast->keyword_loc.end, source);

                    // opening_loc
                    argv[2] = yp_location_new(parser, cast->opening_loc.start, cast->opening_loc.end, source);

                    // closing_loc
                    argv[3] = yp_location_new(parser, cast->closing_loc.start, cast->closing_loc.end, source);

                    // location
                    argv[4] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(5, argv, rb_cYARPPreExecutionNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_PROGRAM_NODE: {
                    yp_program_node_t *cast = (yp_program_node_t *) node;
                    VALUE argv[3];

                    // locals
                    argv[0] = rb_ary_new_capa(cast->locals.size);
                    for (size_t index = 0; index < cast->locals.size; index++) {
                        rb_ary_push(argv[0], rb_id2sym(constants[cast->locals.ids[index] - 1]));
                    }

                    // statements
                    argv[1] = rb_ary_pop(value_stack);

                    // location
                    argv[2] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(3, argv, rb_cYARPProgramNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_RANGE_NODE: {
                    yp_range_node_t *cast = (yp_range_node_t *) node;
                    VALUE argv[5];

                    // left
                    argv[0] = rb_ary_pop(value_stack);

                    // right
                    argv[1] = rb_ary_pop(value_stack);

                    // operator_loc
                    argv[2] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // flags
                    argv[3] = ULONG2NUM(node->flags >> 1);

                    // location
                    argv[4] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(5, argv, rb_cYARPRangeNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_RATIONAL_NODE: {
                    VALUE argv[2];

                    // numeric
                    argv[0] = rb_ary_pop(value_stack);

                    // location
                    argv[1] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(2, argv, rb_cYARPRationalNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_REDO_NODE: {
                    VALUE argv[1];

                    // location
                    argv[0] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(1, argv, rb_cYARPRedoNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_REGULAR_EXPRESSION_NODE: {
                    yp_regular_expression_node_t *cast = (yp_regular_expression_node_t *) node;
                    VALUE argv[6];

                    // opening_loc
                    argv[0] = yp_location_new(parser, cast->opening_loc.start, cast->opening_loc.end, source);

                    // content_loc
                    argv[1] = yp_location_new(parser, cast->content_loc.start, cast->content_loc.end, source);

                    // closing_loc
                    argv[2] = yp_location_new(parser, cast->closing_loc.start, cast->closing_loc.end, source);

                    // unescaped
                    argv[3] = yp_string_new(&cast->unescaped, encoding);

                    // flags
                    argv[4] = ULONG2NUM(node->flags >> 1);

                    // location
                    argv[5] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(6, argv, rb_cYARPRegularExpressionNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_REQUIRED_DESTRUCTURED_PARAMETER_NODE: {
                    yp_required_destructured_parameter_node_t *cast = (yp_required_destructured_parameter_node_t *) node;
                    VALUE argv[4];

                    // parameters
                    argv[0] = rb_ary_new_capa(cast->parameters.size);
                    for (size_t index = 0; index < cast->parameters.size; index++) {
                        rb_ary_push(argv[0], rb_ary_pop(value_stack));
                    }

                    // opening_loc
                    argv[1] = yp_location_new(parser, cast->opening_loc.start, cast->opening_loc.end, source);

                    // closing_loc
                    argv[2] = yp_location_new(parser, cast->closing_loc.start, cast->closing_loc.end, source);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPRequiredDestructuredParameterNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_REQUIRED_PARAMETER_NODE: {
                    yp_required_parameter_node_t *cast = (yp_required_parameter_node_t *) node;
                    VALUE argv[2];

                    // constant_id
                    argv[0] = rb_id2sym(constants[cast->constant_id - 1]);

                    // location
                    argv[1] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(2, argv, rb_cYARPRequiredParameterNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_RESCUE_MODIFIER_NODE: {
                    yp_rescue_modifier_node_t *cast = (yp_rescue_modifier_node_t *) node;
                    VALUE argv[4];

                    // expression
                    argv[0] = rb_ary_pop(value_stack);

                    // keyword_loc
                    argv[1] = yp_location_new(parser, cast->keyword_loc.start, cast->keyword_loc.end, source);

                    // rescue_expression
                    argv[2] = rb_ary_pop(value_stack);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPRescueModifierNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_RESCUE_NODE: {
                    yp_rescue_node_t *cast = (yp_rescue_node_t *) node;
                    VALUE argv[7];

                    // keyword_loc
                    argv[0] = yp_location_new(parser, cast->keyword_loc.start, cast->keyword_loc.end, source);

                    // exceptions
                    argv[1] = rb_ary_new_capa(cast->exceptions.size);
                    for (size_t index = 0; index < cast->exceptions.size; index++) {
                        rb_ary_push(argv[1], rb_ary_pop(value_stack));
                    }

                    // operator_loc
                    argv[2] = cast->operator_loc.start == NULL ? Qnil : yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // reference
                    argv[3] = rb_ary_pop(value_stack);

                    // statements
                    argv[4] = rb_ary_pop(value_stack);

                    // consequent
                    argv[5] = rb_ary_pop(value_stack);

                    // location
                    argv[6] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(7, argv, rb_cYARPRescueNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_REST_PARAMETER_NODE: {
                    yp_rest_parameter_node_t *cast = (yp_rest_parameter_node_t *) node;
                    VALUE argv[3];

                    // operator_loc
                    argv[0] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // name_loc
                    argv[1] = cast->name_loc.start == NULL ? Qnil : yp_location_new(parser, cast->name_loc.start, cast->name_loc.end, source);

                    // location
                    argv[2] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(3, argv, rb_cYARPRestParameterNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_RETRY_NODE: {
                    VALUE argv[1];

                    // location
                    argv[0] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(1, argv, rb_cYARPRetryNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_RETURN_NODE: {
                    yp_return_node_t *cast = (yp_return_node_t *) node;
                    VALUE argv[3];

                    // keyword_loc
                    argv[0] = yp_location_new(parser, cast->keyword_loc.start, cast->keyword_loc.end, source);

                    // arguments
                    argv[1] = rb_ary_pop(value_stack);

                    // location
                    argv[2] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(3, argv, rb_cYARPReturnNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_SELF_NODE: {
                    VALUE argv[1];

                    // location
                    argv[0] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(1, argv, rb_cYARPSelfNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_SINGLETON_CLASS_NODE: {
                    yp_singleton_class_node_t *cast = (yp_singleton_class_node_t *) node;
                    VALUE argv[7];

                    // locals
                    argv[0] = rb_ary_new_capa(cast->locals.size);
                    for (size_t index = 0; index < cast->locals.size; index++) {
                        rb_ary_push(argv[0], rb_id2sym(constants[cast->locals.ids[index] - 1]));
                    }

                    // class_keyword_loc
                    argv[1] = yp_location_new(parser, cast->class_keyword_loc.start, cast->class_keyword_loc.end, source);

                    // operator_loc
                    argv[2] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // expression
                    argv[3] = rb_ary_pop(value_stack);

                    // statements
                    argv[4] = rb_ary_pop(value_stack);

                    // end_keyword_loc
                    argv[5] = yp_location_new(parser, cast->end_keyword_loc.start, cast->end_keyword_loc.end, source);

                    // location
                    argv[6] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(7, argv, rb_cYARPSingletonClassNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_SOURCE_ENCODING_NODE: {
                    VALUE argv[1];

                    // location
                    argv[0] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(1, argv, rb_cYARPSourceEncodingNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_SOURCE_FILE_NODE: {
                    yp_source_file_node_t *cast = (yp_source_file_node_t *) node;
                    VALUE argv[2];

                    // filepath
                    argv[0] = yp_string_new(&cast->filepath, encoding);

                    // location
                    argv[1] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(2, argv, rb_cYARPSourceFileNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_SOURCE_LINE_NODE: {
                    VALUE argv[1];

                    // location
                    argv[0] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(1, argv, rb_cYARPSourceLineNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_SPLAT_NODE: {
                    yp_splat_node_t *cast = (yp_splat_node_t *) node;
                    VALUE argv[3];

                    // operator_loc
                    argv[0] = yp_location_new(parser, cast->operator_loc.start, cast->operator_loc.end, source);

                    // expression
                    argv[1] = rb_ary_pop(value_stack);

                    // location
                    argv[2] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(3, argv, rb_cYARPSplatNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_STATEMENTS_NODE: {
                    yp_statements_node_t *cast = (yp_statements_node_t *) node;
                    VALUE argv[2];

                    // body
                    argv[0] = rb_ary_new_capa(cast->body.size);
                    for (size_t index = 0; index < cast->body.size; index++) {
                        rb_ary_push(argv[0], rb_ary_pop(value_stack));
                    }

                    // location
                    argv[1] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(2, argv, rb_cYARPStatementsNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_STRING_CONCAT_NODE: {
                    VALUE argv[3];

                    // left
                    argv[0] = rb_ary_pop(value_stack);

                    // right
                    argv[1] = rb_ary_pop(value_stack);

                    // location
                    argv[2] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(3, argv, rb_cYARPStringConcatNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_STRING_NODE: {
                    yp_string_node_t *cast = (yp_string_node_t *) node;
                    VALUE argv[5];

                    // opening_loc
                    argv[0] = cast->opening_loc.start == NULL ? Qnil : yp_location_new(parser, cast->opening_loc.start, cast->opening_loc.end, source);

                    // content_loc
                    argv[1] = yp_location_new(parser, cast->content_loc.start, cast->content_loc.end, source);

                    // closing_loc
                    argv[2] = cast->closing_loc.start == NULL ? Qnil : yp_location_new(parser, cast->closing_loc.start, cast->closing_loc.end, source);

                    // unescaped
                    argv[3] = yp_string_new(&cast->unescaped, encoding);

                    // location
                    argv[4] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(5, argv, rb_cYARPStringNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_SUPER_NODE: {
                    yp_super_node_t *cast = (yp_super_node_t *) node;
                    VALUE argv[6];

                    // keyword_loc
                    argv[0] = yp_location_new(parser, cast->keyword_loc.start, cast->keyword_loc.end, source);

                    // lparen_loc
                    argv[1] = cast->lparen_loc.start == NULL ? Qnil : yp_location_new(parser, cast->lparen_loc.start, cast->lparen_loc.end, source);

                    // arguments
                    argv[2] = rb_ary_pop(value_stack);

                    // rparen_loc
                    argv[3] = cast->rparen_loc.start == NULL ? Qnil : yp_location_new(parser, cast->rparen_loc.start, cast->rparen_loc.end, source);

                    // block
                    argv[4] = rb_ary_pop(value_stack);

                    // location
                    argv[5] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(6, argv, rb_cYARPSuperNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_SYMBOL_NODE: {
                    yp_symbol_node_t *cast = (yp_symbol_node_t *) node;
                    VALUE argv[5];

                    // opening_loc
                    argv[0] = cast->opening_loc.start == NULL ? Qnil : yp_location_new(parser, cast->opening_loc.start, cast->opening_loc.end, source);

                    // value_loc
                    argv[1] = yp_location_new(parser, cast->value_loc.start, cast->value_loc.end, source);

                    // closing_loc
                    argv[2] = cast->closing_loc.start == NULL ? Qnil : yp_location_new(parser, cast->closing_loc.start, cast->closing_loc.end, source);

                    // unescaped
                    argv[3] = yp_string_new(&cast->unescaped, encoding);

                    // location
                    argv[4] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(5, argv, rb_cYARPSymbolNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_TRUE_NODE: {
                    VALUE argv[1];

                    // location
                    argv[0] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(1, argv, rb_cYARPTrueNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_UNDEF_NODE: {
                    yp_undef_node_t *cast = (yp_undef_node_t *) node;
                    VALUE argv[3];

                    // names
                    argv[0] = rb_ary_new_capa(cast->names.size);
                    for (size_t index = 0; index < cast->names.size; index++) {
                        rb_ary_push(argv[0], rb_ary_pop(value_stack));
                    }

                    // keyword_loc
                    argv[1] = yp_location_new(parser, cast->keyword_loc.start, cast->keyword_loc.end, source);

                    // location
                    argv[2] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(3, argv, rb_cYARPUndefNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_UNLESS_NODE: {
                    yp_unless_node_t *cast = (yp_unless_node_t *) node;
                    VALUE argv[6];

                    // keyword_loc
                    argv[0] = yp_location_new(parser, cast->keyword_loc.start, cast->keyword_loc.end, source);

                    // predicate
                    argv[1] = rb_ary_pop(value_stack);

                    // statements
                    argv[2] = rb_ary_pop(value_stack);

                    // consequent
                    argv[3] = rb_ary_pop(value_stack);

                    // end_keyword_loc
                    argv[4] = cast->end_keyword_loc.start == NULL ? Qnil : yp_location_new(parser, cast->end_keyword_loc.start, cast->end_keyword_loc.end, source);

                    // location
                    argv[5] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(6, argv, rb_cYARPUnlessNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_UNTIL_NODE: {
                    yp_until_node_t *cast = (yp_until_node_t *) node;
                    VALUE argv[5];

                    // keyword_loc
                    argv[0] = yp_location_new(parser, cast->keyword_loc.start, cast->keyword_loc.end, source);

                    // predicate
                    argv[1] = rb_ary_pop(value_stack);

                    // statements
                    argv[2] = rb_ary_pop(value_stack);

                    // flags
                    argv[3] = ULONG2NUM(node->flags >> 1);

                    // location
                    argv[4] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(5, argv, rb_cYARPUntilNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_WHEN_NODE: {
                    yp_when_node_t *cast = (yp_when_node_t *) node;
                    VALUE argv[4];

                    // keyword_loc
                    argv[0] = yp_location_new(parser, cast->keyword_loc.start, cast->keyword_loc.end, source);

                    // conditions
                    argv[1] = rb_ary_new_capa(cast->conditions.size);
                    for (size_t index = 0; index < cast->conditions.size; index++) {
                        rb_ary_push(argv[1], rb_ary_pop(value_stack));
                    }

                    // statements
                    argv[2] = rb_ary_pop(value_stack);

                    // location
                    argv[3] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(4, argv, rb_cYARPWhenNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_WHILE_NODE: {
                    yp_while_node_t *cast = (yp_while_node_t *) node;
                    VALUE argv[5];

                    // keyword_loc
                    argv[0] = yp_location_new(parser, cast->keyword_loc.start, cast->keyword_loc.end, source);

                    // predicate
                    argv[1] = rb_ary_pop(value_stack);

                    // statements
                    argv[2] = rb_ary_pop(value_stack);

                    // flags
                    argv[3] = ULONG2NUM(node->flags >> 1);

                    // location
                    argv[4] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(5, argv, rb_cYARPWhileNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_X_STRING_NODE: {
                    yp_x_string_node_t *cast = (yp_x_string_node_t *) node;
                    VALUE argv[5];

                    // opening_loc
                    argv[0] = yp_location_new(parser, cast->opening_loc.start, cast->opening_loc.end, source);

                    // content_loc
                    argv[1] = yp_location_new(parser, cast->content_loc.start, cast->content_loc.end, source);

                    // closing_loc
                    argv[2] = yp_location_new(parser, cast->closing_loc.start, cast->closing_loc.end, source);

                    // unescaped
                    argv[3] = yp_string_new(&cast->unescaped, encoding);

                    // location
                    argv[4] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(5, argv, rb_cYARPXStringNode));
                    break;
                }
#line 137 "api_node.c.erb"
                case YP_NODE_YIELD_NODE: {
                    yp_yield_node_t *cast = (yp_yield_node_t *) node;
                    VALUE argv[5];

                    // keyword_loc
                    argv[0] = yp_location_new(parser, cast->keyword_loc.start, cast->keyword_loc.end, source);

                    // lparen_loc
                    argv[1] = cast->lparen_loc.start == NULL ? Qnil : yp_location_new(parser, cast->lparen_loc.start, cast->lparen_loc.end, source);

                    // arguments
                    argv[2] = rb_ary_pop(value_stack);

                    // rparen_loc
                    argv[3] = cast->rparen_loc.start == NULL ? Qnil : yp_location_new(parser, cast->rparen_loc.start, cast->rparen_loc.end, source);

                    // location
                    argv[4] = yp_location_new(parser, node->location.start, node->location.end, source);

                    rb_ary_push(value_stack, rb_class_new_instance(5, argv, rb_cYARPYieldNode));
                    break;
                }
                default:
                    rb_raise(rb_eRuntimeError, "unknown node type: %d", YP_NODE_TYPE(node));
            }
        }
    }

    VALUE result = rb_ary_pop(value_stack);
    free(constants);
    return result;
}

void
Init_yarp_api_node(void) {
    rb_cYARPAliasNode = rb_define_class_under(rb_cYARP, "AliasNode", rb_cYARPNode);
    rb_cYARPAlternationPatternNode = rb_define_class_under(rb_cYARP, "AlternationPatternNode", rb_cYARPNode);
    rb_cYARPAndNode = rb_define_class_under(rb_cYARP, "AndNode", rb_cYARPNode);
    rb_cYARPArgumentsNode = rb_define_class_under(rb_cYARP, "ArgumentsNode", rb_cYARPNode);
    rb_cYARPArrayNode = rb_define_class_under(rb_cYARP, "ArrayNode", rb_cYARPNode);
    rb_cYARPArrayPatternNode = rb_define_class_under(rb_cYARP, "ArrayPatternNode", rb_cYARPNode);
    rb_cYARPAssocNode = rb_define_class_under(rb_cYARP, "AssocNode", rb_cYARPNode);
    rb_cYARPAssocSplatNode = rb_define_class_under(rb_cYARP, "AssocSplatNode", rb_cYARPNode);
    rb_cYARPBackReferenceReadNode = rb_define_class_under(rb_cYARP, "BackReferenceReadNode", rb_cYARPNode);
    rb_cYARPBeginNode = rb_define_class_under(rb_cYARP, "BeginNode", rb_cYARPNode);
    rb_cYARPBlockArgumentNode = rb_define_class_under(rb_cYARP, "BlockArgumentNode", rb_cYARPNode);
    rb_cYARPBlockNode = rb_define_class_under(rb_cYARP, "BlockNode", rb_cYARPNode);
    rb_cYARPBlockParameterNode = rb_define_class_under(rb_cYARP, "BlockParameterNode", rb_cYARPNode);
    rb_cYARPBlockParametersNode = rb_define_class_under(rb_cYARP, "BlockParametersNode", rb_cYARPNode);
    rb_cYARPBreakNode = rb_define_class_under(rb_cYARP, "BreakNode", rb_cYARPNode);
    rb_cYARPCallNode = rb_define_class_under(rb_cYARP, "CallNode", rb_cYARPNode);
    rb_cYARPCallOperatorAndWriteNode = rb_define_class_under(rb_cYARP, "CallOperatorAndWriteNode", rb_cYARPNode);
    rb_cYARPCallOperatorOrWriteNode = rb_define_class_under(rb_cYARP, "CallOperatorOrWriteNode", rb_cYARPNode);
    rb_cYARPCallOperatorWriteNode = rb_define_class_under(rb_cYARP, "CallOperatorWriteNode", rb_cYARPNode);
    rb_cYARPCapturePatternNode = rb_define_class_under(rb_cYARP, "CapturePatternNode", rb_cYARPNode);
    rb_cYARPCaseNode = rb_define_class_under(rb_cYARP, "CaseNode", rb_cYARPNode);
    rb_cYARPClassNode = rb_define_class_under(rb_cYARP, "ClassNode", rb_cYARPNode);
    rb_cYARPClassVariableOperatorAndWriteNode = rb_define_class_under(rb_cYARP, "ClassVariableOperatorAndWriteNode", rb_cYARPNode);
    rb_cYARPClassVariableOperatorOrWriteNode = rb_define_class_under(rb_cYARP, "ClassVariableOperatorOrWriteNode", rb_cYARPNode);
    rb_cYARPClassVariableOperatorWriteNode = rb_define_class_under(rb_cYARP, "ClassVariableOperatorWriteNode", rb_cYARPNode);
    rb_cYARPClassVariableReadNode = rb_define_class_under(rb_cYARP, "ClassVariableReadNode", rb_cYARPNode);
    rb_cYARPClassVariableWriteNode = rb_define_class_under(rb_cYARP, "ClassVariableWriteNode", rb_cYARPNode);
    rb_cYARPConstantOperatorAndWriteNode = rb_define_class_under(rb_cYARP, "ConstantOperatorAndWriteNode", rb_cYARPNode);
    rb_cYARPConstantOperatorOrWriteNode = rb_define_class_under(rb_cYARP, "ConstantOperatorOrWriteNode", rb_cYARPNode);
    rb_cYARPConstantOperatorWriteNode = rb_define_class_under(rb_cYARP, "ConstantOperatorWriteNode", rb_cYARPNode);
    rb_cYARPConstantPathNode = rb_define_class_under(rb_cYARP, "ConstantPathNode", rb_cYARPNode);
    rb_cYARPConstantPathOperatorAndWriteNode = rb_define_class_under(rb_cYARP, "ConstantPathOperatorAndWriteNode", rb_cYARPNode);
    rb_cYARPConstantPathOperatorOrWriteNode = rb_define_class_under(rb_cYARP, "ConstantPathOperatorOrWriteNode", rb_cYARPNode);
    rb_cYARPConstantPathOperatorWriteNode = rb_define_class_under(rb_cYARP, "ConstantPathOperatorWriteNode", rb_cYARPNode);
    rb_cYARPConstantPathWriteNode = rb_define_class_under(rb_cYARP, "ConstantPathWriteNode", rb_cYARPNode);
    rb_cYARPConstantReadNode = rb_define_class_under(rb_cYARP, "ConstantReadNode", rb_cYARPNode);
    rb_cYARPConstantWriteNode = rb_define_class_under(rb_cYARP, "ConstantWriteNode", rb_cYARPNode);
    rb_cYARPDefNode = rb_define_class_under(rb_cYARP, "DefNode", rb_cYARPNode);
    rb_cYARPDefinedNode = rb_define_class_under(rb_cYARP, "DefinedNode", rb_cYARPNode);
    rb_cYARPElseNode = rb_define_class_under(rb_cYARP, "ElseNode", rb_cYARPNode);
    rb_cYARPEmbeddedStatementsNode = rb_define_class_under(rb_cYARP, "EmbeddedStatementsNode", rb_cYARPNode);
    rb_cYARPEmbeddedVariableNode = rb_define_class_under(rb_cYARP, "EmbeddedVariableNode", rb_cYARPNode);
    rb_cYARPEnsureNode = rb_define_class_under(rb_cYARP, "EnsureNode", rb_cYARPNode);
    rb_cYARPFalseNode = rb_define_class_under(rb_cYARP, "FalseNode", rb_cYARPNode);
    rb_cYARPFindPatternNode = rb_define_class_under(rb_cYARP, "FindPatternNode", rb_cYARPNode);
    rb_cYARPFlipFlopNode = rb_define_class_under(rb_cYARP, "FlipFlopNode", rb_cYARPNode);
    rb_cYARPFloatNode = rb_define_class_under(rb_cYARP, "FloatNode", rb_cYARPNode);
    rb_cYARPForNode = rb_define_class_under(rb_cYARP, "ForNode", rb_cYARPNode);
    rb_cYARPForwardingArgumentsNode = rb_define_class_under(rb_cYARP, "ForwardingArgumentsNode", rb_cYARPNode);
    rb_cYARPForwardingParameterNode = rb_define_class_under(rb_cYARP, "ForwardingParameterNode", rb_cYARPNode);
    rb_cYARPForwardingSuperNode = rb_define_class_under(rb_cYARP, "ForwardingSuperNode", rb_cYARPNode);
    rb_cYARPGlobalVariableOperatorAndWriteNode = rb_define_class_under(rb_cYARP, "GlobalVariableOperatorAndWriteNode", rb_cYARPNode);
    rb_cYARPGlobalVariableOperatorOrWriteNode = rb_define_class_under(rb_cYARP, "GlobalVariableOperatorOrWriteNode", rb_cYARPNode);
    rb_cYARPGlobalVariableOperatorWriteNode = rb_define_class_under(rb_cYARP, "GlobalVariableOperatorWriteNode", rb_cYARPNode);
    rb_cYARPGlobalVariableReadNode = rb_define_class_under(rb_cYARP, "GlobalVariableReadNode", rb_cYARPNode);
    rb_cYARPGlobalVariableWriteNode = rb_define_class_under(rb_cYARP, "GlobalVariableWriteNode", rb_cYARPNode);
    rb_cYARPHashNode = rb_define_class_under(rb_cYARP, "HashNode", rb_cYARPNode);
    rb_cYARPHashPatternNode = rb_define_class_under(rb_cYARP, "HashPatternNode", rb_cYARPNode);
    rb_cYARPIfNode = rb_define_class_under(rb_cYARP, "IfNode", rb_cYARPNode);
    rb_cYARPImaginaryNode = rb_define_class_under(rb_cYARP, "ImaginaryNode", rb_cYARPNode);
    rb_cYARPInNode = rb_define_class_under(rb_cYARP, "InNode", rb_cYARPNode);
    rb_cYARPInstanceVariableOperatorAndWriteNode = rb_define_class_under(rb_cYARP, "InstanceVariableOperatorAndWriteNode", rb_cYARPNode);
    rb_cYARPInstanceVariableOperatorOrWriteNode = rb_define_class_under(rb_cYARP, "InstanceVariableOperatorOrWriteNode", rb_cYARPNode);
    rb_cYARPInstanceVariableOperatorWriteNode = rb_define_class_under(rb_cYARP, "InstanceVariableOperatorWriteNode", rb_cYARPNode);
    rb_cYARPInstanceVariableReadNode = rb_define_class_under(rb_cYARP, "InstanceVariableReadNode", rb_cYARPNode);
    rb_cYARPInstanceVariableWriteNode = rb_define_class_under(rb_cYARP, "InstanceVariableWriteNode", rb_cYARPNode);
    rb_cYARPIntegerNode = rb_define_class_under(rb_cYARP, "IntegerNode", rb_cYARPNode);
    rb_cYARPInterpolatedRegularExpressionNode = rb_define_class_under(rb_cYARP, "InterpolatedRegularExpressionNode", rb_cYARPNode);
    rb_cYARPInterpolatedStringNode = rb_define_class_under(rb_cYARP, "InterpolatedStringNode", rb_cYARPNode);
    rb_cYARPInterpolatedSymbolNode = rb_define_class_under(rb_cYARP, "InterpolatedSymbolNode", rb_cYARPNode);
    rb_cYARPInterpolatedXStringNode = rb_define_class_under(rb_cYARP, "InterpolatedXStringNode", rb_cYARPNode);
    rb_cYARPKeywordHashNode = rb_define_class_under(rb_cYARP, "KeywordHashNode", rb_cYARPNode);
    rb_cYARPKeywordParameterNode = rb_define_class_under(rb_cYARP, "KeywordParameterNode", rb_cYARPNode);
    rb_cYARPKeywordRestParameterNode = rb_define_class_under(rb_cYARP, "KeywordRestParameterNode", rb_cYARPNode);
    rb_cYARPLambdaNode = rb_define_class_under(rb_cYARP, "LambdaNode", rb_cYARPNode);
    rb_cYARPLocalVariableOperatorAndWriteNode = rb_define_class_under(rb_cYARP, "LocalVariableOperatorAndWriteNode", rb_cYARPNode);
    rb_cYARPLocalVariableOperatorOrWriteNode = rb_define_class_under(rb_cYARP, "LocalVariableOperatorOrWriteNode", rb_cYARPNode);
    rb_cYARPLocalVariableOperatorWriteNode = rb_define_class_under(rb_cYARP, "LocalVariableOperatorWriteNode", rb_cYARPNode);
    rb_cYARPLocalVariableReadNode = rb_define_class_under(rb_cYARP, "LocalVariableReadNode", rb_cYARPNode);
    rb_cYARPLocalVariableWriteNode = rb_define_class_under(rb_cYARP, "LocalVariableWriteNode", rb_cYARPNode);
    rb_cYARPMatchPredicateNode = rb_define_class_under(rb_cYARP, "MatchPredicateNode", rb_cYARPNode);
    rb_cYARPMatchRequiredNode = rb_define_class_under(rb_cYARP, "MatchRequiredNode", rb_cYARPNode);
    rb_cYARPMissingNode = rb_define_class_under(rb_cYARP, "MissingNode", rb_cYARPNode);
    rb_cYARPModuleNode = rb_define_class_under(rb_cYARP, "ModuleNode", rb_cYARPNode);
    rb_cYARPMultiWriteNode = rb_define_class_under(rb_cYARP, "MultiWriteNode", rb_cYARPNode);
    rb_cYARPNextNode = rb_define_class_under(rb_cYARP, "NextNode", rb_cYARPNode);
    rb_cYARPNilNode = rb_define_class_under(rb_cYARP, "NilNode", rb_cYARPNode);
    rb_cYARPNoKeywordsParameterNode = rb_define_class_under(rb_cYARP, "NoKeywordsParameterNode", rb_cYARPNode);
    rb_cYARPNumberedReferenceReadNode = rb_define_class_under(rb_cYARP, "NumberedReferenceReadNode", rb_cYARPNode);
    rb_cYARPOptionalParameterNode = rb_define_class_under(rb_cYARP, "OptionalParameterNode", rb_cYARPNode);
    rb_cYARPOrNode = rb_define_class_under(rb_cYARP, "OrNode", rb_cYARPNode);
    rb_cYARPParametersNode = rb_define_class_under(rb_cYARP, "ParametersNode", rb_cYARPNode);
    rb_cYARPParenthesesNode = rb_define_class_under(rb_cYARP, "ParenthesesNode", rb_cYARPNode);
    rb_cYARPPinnedExpressionNode = rb_define_class_under(rb_cYARP, "PinnedExpressionNode", rb_cYARPNode);
    rb_cYARPPinnedVariableNode = rb_define_class_under(rb_cYARP, "PinnedVariableNode", rb_cYARPNode);
    rb_cYARPPostExecutionNode = rb_define_class_under(rb_cYARP, "PostExecutionNode", rb_cYARPNode);
    rb_cYARPPreExecutionNode = rb_define_class_under(rb_cYARP, "PreExecutionNode", rb_cYARPNode);
    rb_cYARPProgramNode = rb_define_class_under(rb_cYARP, "ProgramNode", rb_cYARPNode);
    rb_cYARPRangeNode = rb_define_class_under(rb_cYARP, "RangeNode", rb_cYARPNode);
    rb_cYARPRationalNode = rb_define_class_under(rb_cYARP, "RationalNode", rb_cYARPNode);
    rb_cYARPRedoNode = rb_define_class_under(rb_cYARP, "RedoNode", rb_cYARPNode);
    rb_cYARPRegularExpressionNode = rb_define_class_under(rb_cYARP, "RegularExpressionNode", rb_cYARPNode);
    rb_cYARPRequiredDestructuredParameterNode = rb_define_class_under(rb_cYARP, "RequiredDestructuredParameterNode", rb_cYARPNode);
    rb_cYARPRequiredParameterNode = rb_define_class_under(rb_cYARP, "RequiredParameterNode", rb_cYARPNode);
    rb_cYARPRescueModifierNode = rb_define_class_under(rb_cYARP, "RescueModifierNode", rb_cYARPNode);
    rb_cYARPRescueNode = rb_define_class_under(rb_cYARP, "RescueNode", rb_cYARPNode);
    rb_cYARPRestParameterNode = rb_define_class_under(rb_cYARP, "RestParameterNode", rb_cYARPNode);
    rb_cYARPRetryNode = rb_define_class_under(rb_cYARP, "RetryNode", rb_cYARPNode);
    rb_cYARPReturnNode = rb_define_class_under(rb_cYARP, "ReturnNode", rb_cYARPNode);
    rb_cYARPSelfNode = rb_define_class_under(rb_cYARP, "SelfNode", rb_cYARPNode);
    rb_cYARPSingletonClassNode = rb_define_class_under(rb_cYARP, "SingletonClassNode", rb_cYARPNode);
    rb_cYARPSourceEncodingNode = rb_define_class_under(rb_cYARP, "SourceEncodingNode", rb_cYARPNode);
    rb_cYARPSourceFileNode = rb_define_class_under(rb_cYARP, "SourceFileNode", rb_cYARPNode);
    rb_cYARPSourceLineNode = rb_define_class_under(rb_cYARP, "SourceLineNode", rb_cYARPNode);
    rb_cYARPSplatNode = rb_define_class_under(rb_cYARP, "SplatNode", rb_cYARPNode);
    rb_cYARPStatementsNode = rb_define_class_under(rb_cYARP, "StatementsNode", rb_cYARPNode);
    rb_cYARPStringConcatNode = rb_define_class_under(rb_cYARP, "StringConcatNode", rb_cYARPNode);
    rb_cYARPStringNode = rb_define_class_under(rb_cYARP, "StringNode", rb_cYARPNode);
    rb_cYARPSuperNode = rb_define_class_under(rb_cYARP, "SuperNode", rb_cYARPNode);
    rb_cYARPSymbolNode = rb_define_class_under(rb_cYARP, "SymbolNode", rb_cYARPNode);
    rb_cYARPTrueNode = rb_define_class_under(rb_cYARP, "TrueNode", rb_cYARPNode);
    rb_cYARPUndefNode = rb_define_class_under(rb_cYARP, "UndefNode", rb_cYARPNode);
    rb_cYARPUnlessNode = rb_define_class_under(rb_cYARP, "UnlessNode", rb_cYARPNode);
    rb_cYARPUntilNode = rb_define_class_under(rb_cYARP, "UntilNode", rb_cYARPNode);
    rb_cYARPWhenNode = rb_define_class_under(rb_cYARP, "WhenNode", rb_cYARPNode);
    rb_cYARPWhileNode = rb_define_class_under(rb_cYARP, "WhileNode", rb_cYARPNode);
    rb_cYARPXStringNode = rb_define_class_under(rb_cYARP, "XStringNode", rb_cYARPNode);
    rb_cYARPYieldNode = rb_define_class_under(rb_cYARP, "YieldNode", rb_cYARPNode);
}
