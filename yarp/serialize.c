/******************************************************************************/
/* This file is generated by the bin/template script and should not be        */
/* modified manually.                                                         */
/******************************************************************************/

#include "util/yp_buffer.h"
#include "ast.h"
#include "parser.h"

static void
serialize_token(yp_parser_t *parser, yp_token_t *token, yp_buffer_t *buffer) {
  yp_buffer_append_u8(buffer, token->type);
  yp_buffer_append_u32(buffer, token->start - parser->start);
  yp_buffer_append_u32(buffer, token->end - parser->start);
}

static void
serialize_location(yp_parser_t *parser, yp_location_t *location, yp_buffer_t *buffer) {
  yp_buffer_append_u32(buffer, location->start - parser->start);
  yp_buffer_append_u32(buffer, location->end - parser->start);
}

void
yp_serialize_node(yp_parser_t *parser, yp_node_t *node, yp_buffer_t *buffer) {
  yp_buffer_append_u8(buffer, node->type);

  size_t offset = buffer->length;
  yp_buffer_append_u32(buffer, 0); /* Updated below */

  yp_buffer_append_u32(buffer, node->location.start - parser->start);
  yp_buffer_append_u32(buffer, node->location.end - parser->start);

  switch (node->type) {
    case YP_NODE_ALIAS_NODE: {
      yp_serialize_node(parser, node->as.alias_node.new_name, buffer);
      yp_serialize_node(parser, node->as.alias_node.old_name, buffer);
      serialize_location(parser, &node->as.alias_node.keyword_loc, buffer);
      break;
    }
    case YP_NODE_AND_NODE: {
      yp_serialize_node(parser, node->as.and_node.left, buffer);
      yp_serialize_node(parser, node->as.and_node.right, buffer);
      serialize_token(parser, &node->as.and_node.operator, buffer);
      break;
    }
    case YP_NODE_ARGUMENTS_NODE: {
      uint32_t arguments_size = node->as.arguments_node.arguments.size;
      yp_buffer_append_u32(buffer, arguments_size);
      for (uint32_t index = 0; index < arguments_size; index++) {
        yp_serialize_node(parser, node->as.arguments_node.arguments.nodes[index], buffer);
      }
      break;
    }
    case YP_NODE_ARRAY_NODE: {
      uint32_t elements_size = node->as.array_node.elements.size;
      yp_buffer_append_u32(buffer, elements_size);
      for (uint32_t index = 0; index < elements_size; index++) {
        yp_serialize_node(parser, node->as.array_node.elements.nodes[index], buffer);
      }
      if (node->as.array_node.opening.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.array_node.opening, buffer);
      }
      if (node->as.array_node.closing.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.array_node.closing, buffer);
      }
      break;
    }
    case YP_NODE_ASSOC_NODE: {
      yp_serialize_node(parser, node->as.assoc_node.key, buffer);
      if (node->as.assoc_node.value == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.assoc_node.value, buffer);
      }
      if (node->as.assoc_node.operator.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.assoc_node.operator, buffer);
      }
      break;
    }
    case YP_NODE_ASSOC_SPLAT_NODE: {
      yp_serialize_node(parser, node->as.assoc_splat_node.value, buffer);
      serialize_location(parser, &node->as.assoc_splat_node.operator_loc, buffer);
      break;
    }
    case YP_NODE_BEGIN_NODE: {
      if (node->as.begin_node.begin_keyword.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.begin_node.begin_keyword, buffer);
      }
      yp_serialize_node(parser, node->as.begin_node.statements, buffer);
      if (node->as.begin_node.rescue_clause == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.begin_node.rescue_clause, buffer);
      }
      if (node->as.begin_node.else_clause == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.begin_node.else_clause, buffer);
      }
      if (node->as.begin_node.ensure_clause == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.begin_node.ensure_clause, buffer);
      }
      if (node->as.begin_node.end_keyword.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.begin_node.end_keyword, buffer);
      }
      break;
    }
    case YP_NODE_BLOCK_ARGUMENT_NODE: {
      yp_serialize_node(parser, node->as.block_argument_node.expression, buffer);
      serialize_location(parser, &node->as.block_argument_node.operator_loc, buffer);
      break;
    }
    case YP_NODE_BLOCK_NODE: {
      yp_serialize_node(parser, node->as.block_node.scope, buffer);
      if (node->as.block_node.parameters == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.block_node.parameters, buffer);
      }
      if (node->as.block_node.statements == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.block_node.statements, buffer);
      }
      serialize_location(parser, &node->as.block_node.opening_loc, buffer);
      serialize_location(parser, &node->as.block_node.closing_loc, buffer);
      break;
    }
    case YP_NODE_BLOCK_PARAMETER_NODE: {
      if (node->as.block_parameter_node.name.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.block_parameter_node.name, buffer);
      }
      serialize_location(parser, &node->as.block_parameter_node.operator_loc, buffer);
      break;
    }
    case YP_NODE_BLOCK_PARAMETERS_NODE: {
      yp_serialize_node(parser, node->as.block_parameters_node.parameters, buffer);
      uint32_t locals_size = node->as.block_parameters_node.locals.size;
      yp_buffer_append_u32(buffer, locals_size);
      for (uint32_t index = 0; index < locals_size; index++) {
        serialize_token(parser, &node->as.block_parameters_node.locals.tokens[index], buffer);
      }
      break;
    }
    case YP_NODE_BREAK_NODE: {
      if (node->as.break_node.arguments == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.break_node.arguments, buffer);
      }
      serialize_location(parser, &node->as.break_node.keyword_loc, buffer);
      break;
    }
    case YP_NODE_CALL_NODE: {
      if (node->as.call_node.receiver == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.call_node.receiver, buffer);
      }
      if (node->as.call_node.call_operator.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.call_node.call_operator, buffer);
      }
      if (node->as.call_node.message.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.call_node.message, buffer);
      }
      if (node->as.call_node.opening.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.call_node.opening, buffer);
      }
      if (node->as.call_node.arguments == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.call_node.arguments, buffer);
      }
      if (node->as.call_node.closing.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.call_node.closing, buffer);
      }
      if (node->as.call_node.block == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.call_node.block, buffer);
      }
      uint32_t name_length = yp_string_length(&node->as.call_node.name);
      yp_buffer_append_u32(buffer, name_length);
      yp_buffer_append_str(buffer, yp_string_source(&node->as.call_node.name), name_length);
      break;
    }
    case YP_NODE_CASE_NODE: {
      if (node->as.case_node.predicate == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.case_node.predicate, buffer);
      }
      uint32_t conditions_size = node->as.case_node.conditions.size;
      yp_buffer_append_u32(buffer, conditions_size);
      for (uint32_t index = 0; index < conditions_size; index++) {
        yp_serialize_node(parser, node->as.case_node.conditions.nodes[index], buffer);
      }
      if (node->as.case_node.consequent == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.case_node.consequent, buffer);
      }
      serialize_location(parser, &node->as.case_node.case_keyword_loc, buffer);
      serialize_location(parser, &node->as.case_node.end_keyword_loc, buffer);
      break;
    }
    case YP_NODE_CLASS_NODE: {
      yp_serialize_node(parser, node->as.class_node.scope, buffer);
      serialize_token(parser, &node->as.class_node.class_keyword, buffer);
      yp_serialize_node(parser, node->as.class_node.constant_path, buffer);
      if (node->as.class_node.inheritance_operator.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.class_node.inheritance_operator, buffer);
      }
      if (node->as.class_node.superclass == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.class_node.superclass, buffer);
      }
      yp_serialize_node(parser, node->as.class_node.statements, buffer);
      serialize_token(parser, &node->as.class_node.end_keyword, buffer);
      break;
    }
    case YP_NODE_CLASS_VARIABLE_READ_NODE: {
      break;
    }
    case YP_NODE_CLASS_VARIABLE_WRITE_NODE: {
      serialize_location(parser, &node->as.class_variable_write_node.name_loc, buffer);
      if (node->as.class_variable_write_node.value == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.class_variable_write_node.value, buffer);
      }
      if (node->as.class_variable_write_node.operator_loc.start == parser->start) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_location(parser, &node->as.class_variable_write_node.operator_loc, buffer);
      }
      break;
    }
    case YP_NODE_CONSTANT_PATH_NODE: {
      if (node->as.constant_path_node.parent == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.constant_path_node.parent, buffer);
      }
      serialize_token(parser, &node->as.constant_path_node.delimiter, buffer);
      yp_serialize_node(parser, node->as.constant_path_node.child, buffer);
      break;
    }
    case YP_NODE_CONSTANT_PATH_WRITE_NODE: {
      yp_serialize_node(parser, node->as.constant_path_write_node.target, buffer);
      if (node->as.constant_path_write_node.operator.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.constant_path_write_node.operator, buffer);
      }
      if (node->as.constant_path_write_node.value == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.constant_path_write_node.value, buffer);
      }
      break;
    }
    case YP_NODE_CONSTANT_READ_NODE: {
      break;
    }
    case YP_NODE_DEF_NODE: {
      serialize_token(parser, &node->as.def_node.name, buffer);
      if (node->as.def_node.receiver == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.def_node.receiver, buffer);
      }
      yp_serialize_node(parser, node->as.def_node.parameters, buffer);
      yp_serialize_node(parser, node->as.def_node.statements, buffer);
      yp_serialize_node(parser, node->as.def_node.scope, buffer);
      serialize_location(parser, &node->as.def_node.def_keyword_loc, buffer);
      if (node->as.def_node.operator_loc.start == parser->start) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_location(parser, &node->as.def_node.operator_loc, buffer);
      }
      if (node->as.def_node.lparen_loc.start == parser->start) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_location(parser, &node->as.def_node.lparen_loc, buffer);
      }
      if (node->as.def_node.rparen_loc.start == parser->start) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_location(parser, &node->as.def_node.rparen_loc, buffer);
      }
      if (node->as.def_node.equal_loc.start == parser->start) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_location(parser, &node->as.def_node.equal_loc, buffer);
      }
      if (node->as.def_node.end_keyword_loc.start == parser->start) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_location(parser, &node->as.def_node.end_keyword_loc, buffer);
      }
      break;
    }
    case YP_NODE_DEFINED_NODE: {
      if (node->as.defined_node.lparen.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.defined_node.lparen, buffer);
      }
      yp_serialize_node(parser, node->as.defined_node.value, buffer);
      if (node->as.defined_node.rparen.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.defined_node.rparen, buffer);
      }
      serialize_location(parser, &node->as.defined_node.keyword_loc, buffer);
      break;
    }
    case YP_NODE_ELSE_NODE: {
      serialize_token(parser, &node->as.else_node.else_keyword, buffer);
      if (node->as.else_node.statements == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.else_node.statements, buffer);
      }
      serialize_token(parser, &node->as.else_node.end_keyword, buffer);
      break;
    }
    case YP_NODE_ENSURE_NODE: {
      serialize_token(parser, &node->as.ensure_node.ensure_keyword, buffer);
      yp_serialize_node(parser, node->as.ensure_node.statements, buffer);
      serialize_token(parser, &node->as.ensure_node.end_keyword, buffer);
      break;
    }
    case YP_NODE_FALSE_NODE: {
      break;
    }
    case YP_NODE_FLOAT_NODE: {
      break;
    }
    case YP_NODE_FOR_NODE: {
      yp_serialize_node(parser, node->as.for_node.index, buffer);
      yp_serialize_node(parser, node->as.for_node.collection, buffer);
      yp_serialize_node(parser, node->as.for_node.statements, buffer);
      serialize_location(parser, &node->as.for_node.for_keyword_loc, buffer);
      serialize_location(parser, &node->as.for_node.in_keyword_loc, buffer);
      if (node->as.for_node.do_keyword_loc.start == parser->start) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_location(parser, &node->as.for_node.do_keyword_loc, buffer);
      }
      serialize_location(parser, &node->as.for_node.end_keyword_loc, buffer);
      break;
    }
    case YP_NODE_FORWARDING_ARGUMENTS_NODE: {
      break;
    }
    case YP_NODE_FORWARDING_PARAMETER_NODE: {
      break;
    }
    case YP_NODE_FORWARDING_SUPER_NODE: {
      if (node->as.forwarding_super_node.block == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.forwarding_super_node.block, buffer);
      }
      break;
    }
    case YP_NODE_GLOBAL_VARIABLE_READ_NODE: {
      serialize_token(parser, &node->as.global_variable_read_node.name, buffer);
      break;
    }
    case YP_NODE_GLOBAL_VARIABLE_WRITE_NODE: {
      serialize_token(parser, &node->as.global_variable_write_node.name, buffer);
      if (node->as.global_variable_write_node.operator.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.global_variable_write_node.operator, buffer);
      }
      if (node->as.global_variable_write_node.value == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.global_variable_write_node.value, buffer);
      }
      break;
    }
    case YP_NODE_HASH_NODE: {
      if (node->as.hash_node.opening.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.hash_node.opening, buffer);
      }
      uint32_t elements_size = node->as.hash_node.elements.size;
      yp_buffer_append_u32(buffer, elements_size);
      for (uint32_t index = 0; index < elements_size; index++) {
        yp_serialize_node(parser, node->as.hash_node.elements.nodes[index], buffer);
      }
      if (node->as.hash_node.closing.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.hash_node.closing, buffer);
      }
      break;
    }
    case YP_NODE_HEREDOC_NODE: {
      serialize_token(parser, &node->as.heredoc_node.opening, buffer);
      uint32_t parts_size = node->as.heredoc_node.parts.size;
      yp_buffer_append_u32(buffer, parts_size);
      for (uint32_t index = 0; index < parts_size; index++) {
        yp_serialize_node(parser, node->as.heredoc_node.parts.nodes[index], buffer);
      }
      serialize_token(parser, &node->as.heredoc_node.closing, buffer);
      yp_buffer_append_int(buffer, node->as.heredoc_node.dedent);
      break;
    }
    case YP_NODE_IF_NODE: {
      serialize_token(parser, &node->as.if_node.if_keyword, buffer);
      yp_serialize_node(parser, node->as.if_node.predicate, buffer);
      yp_serialize_node(parser, node->as.if_node.statements, buffer);
      if (node->as.if_node.consequent == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.if_node.consequent, buffer);
      }
      if (node->as.if_node.end_keyword.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.if_node.end_keyword, buffer);
      }
      break;
    }
    case YP_NODE_IMAGINARY_NODE: {
      break;
    }
    case YP_NODE_INSTANCE_VARIABLE_READ_NODE: {
      break;
    }
    case YP_NODE_INSTANCE_VARIABLE_WRITE_NODE: {
      serialize_location(parser, &node->as.instance_variable_write_node.name_loc, buffer);
      if (node->as.instance_variable_write_node.value == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.instance_variable_write_node.value, buffer);
      }
      if (node->as.instance_variable_write_node.operator_loc.start == parser->start) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_location(parser, &node->as.instance_variable_write_node.operator_loc, buffer);
      }
      break;
    }
    case YP_NODE_INTEGER_NODE: {
      break;
    }
    case YP_NODE_INTERPOLATED_REGULAR_EXPRESSION_NODE: {
      serialize_token(parser, &node->as.interpolated_regular_expression_node.opening, buffer);
      uint32_t parts_size = node->as.interpolated_regular_expression_node.parts.size;
      yp_buffer_append_u32(buffer, parts_size);
      for (uint32_t index = 0; index < parts_size; index++) {
        yp_serialize_node(parser, node->as.interpolated_regular_expression_node.parts.nodes[index], buffer);
      }
      serialize_token(parser, &node->as.interpolated_regular_expression_node.closing, buffer);
      break;
    }
    case YP_NODE_INTERPOLATED_STRING_NODE: {
      if (node->as.interpolated_string_node.opening.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.interpolated_string_node.opening, buffer);
      }
      uint32_t parts_size = node->as.interpolated_string_node.parts.size;
      yp_buffer_append_u32(buffer, parts_size);
      for (uint32_t index = 0; index < parts_size; index++) {
        yp_serialize_node(parser, node->as.interpolated_string_node.parts.nodes[index], buffer);
      }
      if (node->as.interpolated_string_node.closing.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.interpolated_string_node.closing, buffer);
      }
      break;
    }
    case YP_NODE_INTERPOLATED_SYMBOL_NODE: {
      if (node->as.interpolated_symbol_node.opening.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.interpolated_symbol_node.opening, buffer);
      }
      uint32_t parts_size = node->as.interpolated_symbol_node.parts.size;
      yp_buffer_append_u32(buffer, parts_size);
      for (uint32_t index = 0; index < parts_size; index++) {
        yp_serialize_node(parser, node->as.interpolated_symbol_node.parts.nodes[index], buffer);
      }
      if (node->as.interpolated_symbol_node.closing.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.interpolated_symbol_node.closing, buffer);
      }
      break;
    }
    case YP_NODE_INTERPOLATED_X_STRING_NODE: {
      serialize_token(parser, &node->as.interpolated_x_string_node.opening, buffer);
      uint32_t parts_size = node->as.interpolated_x_string_node.parts.size;
      yp_buffer_append_u32(buffer, parts_size);
      for (uint32_t index = 0; index < parts_size; index++) {
        yp_serialize_node(parser, node->as.interpolated_x_string_node.parts.nodes[index], buffer);
      }
      serialize_token(parser, &node->as.interpolated_x_string_node.closing, buffer);
      break;
    }
    case YP_NODE_KEYWORD_PARAMETER_NODE: {
      serialize_token(parser, &node->as.keyword_parameter_node.name, buffer);
      if (node->as.keyword_parameter_node.value == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.keyword_parameter_node.value, buffer);
      }
      break;
    }
    case YP_NODE_KEYWORD_REST_PARAMETER_NODE: {
      serialize_token(parser, &node->as.keyword_rest_parameter_node.operator, buffer);
      if (node->as.keyword_rest_parameter_node.name.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.keyword_rest_parameter_node.name, buffer);
      }
      break;
    }
    case YP_NODE_KEYWORD_STAR_NODE: {
      serialize_token(parser, &node->as.keyword_star_node.operator, buffer);
      yp_serialize_node(parser, node->as.keyword_star_node.expression, buffer);
      break;
    }
    case YP_NODE_LAMBDA_NODE: {
      yp_serialize_node(parser, node->as.lambda_node.scope, buffer);
      if (node->as.lambda_node.lparen.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.lambda_node.lparen, buffer);
      }
      yp_serialize_node(parser, node->as.lambda_node.parameters, buffer);
      if (node->as.lambda_node.rparen.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.lambda_node.rparen, buffer);
      }
      yp_serialize_node(parser, node->as.lambda_node.statements, buffer);
      break;
    }
    case YP_NODE_LOCAL_VARIABLE_READ_NODE: {
      serialize_token(parser, &node->as.local_variable_read_node.name, buffer);
      yp_buffer_append_int(buffer, node->as.local_variable_read_node.depth);
      break;
    }
    case YP_NODE_LOCAL_VARIABLE_WRITE_NODE: {
      serialize_token(parser, &node->as.local_variable_write_node.name, buffer);
      if (node->as.local_variable_write_node.operator.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.local_variable_write_node.operator, buffer);
      }
      if (node->as.local_variable_write_node.value == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.local_variable_write_node.value, buffer);
      }
      yp_buffer_append_int(buffer, node->as.local_variable_write_node.depth);
      break;
    }
    case YP_NODE_MISSING_NODE: {
      break;
    }
    case YP_NODE_MODULE_NODE: {
      yp_serialize_node(parser, node->as.module_node.scope, buffer);
      serialize_token(parser, &node->as.module_node.module_keyword, buffer);
      yp_serialize_node(parser, node->as.module_node.constant_path, buffer);
      yp_serialize_node(parser, node->as.module_node.statements, buffer);
      serialize_token(parser, &node->as.module_node.end_keyword, buffer);
      break;
    }
    case YP_NODE_MULTI_WRITE_NODE: {
      uint32_t targets_size = node->as.multi_write_node.targets.size;
      yp_buffer_append_u32(buffer, targets_size);
      for (uint32_t index = 0; index < targets_size; index++) {
        yp_serialize_node(parser, node->as.multi_write_node.targets.nodes[index], buffer);
      }
      if (node->as.multi_write_node.operator.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.multi_write_node.operator, buffer);
      }
      if (node->as.multi_write_node.value == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.multi_write_node.value, buffer);
      }
      if (node->as.multi_write_node.lparen_loc.start == parser->start) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_location(parser, &node->as.multi_write_node.lparen_loc, buffer);
      }
      if (node->as.multi_write_node.rparen_loc.start == parser->start) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_location(parser, &node->as.multi_write_node.rparen_loc, buffer);
      }
      break;
    }
    case YP_NODE_NEXT_NODE: {
      if (node->as.next_node.arguments == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.next_node.arguments, buffer);
      }
      serialize_location(parser, &node->as.next_node.keyword_loc, buffer);
      break;
    }
    case YP_NODE_NIL_NODE: {
      break;
    }
    case YP_NODE_NO_KEYWORDS_PARAMETER_NODE: {
      serialize_location(parser, &node->as.no_keywords_parameter_node.operator_loc, buffer);
      serialize_location(parser, &node->as.no_keywords_parameter_node.keyword_loc, buffer);
      break;
    }
    case YP_NODE_OPERATOR_AND_ASSIGNMENT_NODE: {
      yp_serialize_node(parser, node->as.operator_and_assignment_node.target, buffer);
      yp_serialize_node(parser, node->as.operator_and_assignment_node.value, buffer);
      serialize_location(parser, &node->as.operator_and_assignment_node.operator_loc, buffer);
      break;
    }
    case YP_NODE_OPERATOR_ASSIGNMENT_NODE: {
      yp_serialize_node(parser, node->as.operator_assignment_node.target, buffer);
      serialize_token(parser, &node->as.operator_assignment_node.operator, buffer);
      yp_serialize_node(parser, node->as.operator_assignment_node.value, buffer);
      break;
    }
    case YP_NODE_OPERATOR_OR_ASSIGNMENT_NODE: {
      yp_serialize_node(parser, node->as.operator_or_assignment_node.target, buffer);
      yp_serialize_node(parser, node->as.operator_or_assignment_node.value, buffer);
      serialize_location(parser, &node->as.operator_or_assignment_node.operator_loc, buffer);
      break;
    }
    case YP_NODE_OPTIONAL_PARAMETER_NODE: {
      serialize_token(parser, &node->as.optional_parameter_node.name, buffer);
      serialize_token(parser, &node->as.optional_parameter_node.equal_operator, buffer);
      yp_serialize_node(parser, node->as.optional_parameter_node.value, buffer);
      break;
    }
    case YP_NODE_OR_NODE: {
      yp_serialize_node(parser, node->as.or_node.left, buffer);
      yp_serialize_node(parser, node->as.or_node.right, buffer);
      serialize_location(parser, &node->as.or_node.operator_loc, buffer);
      break;
    }
    case YP_NODE_PARAMETERS_NODE: {
      uint32_t requireds_size = node->as.parameters_node.requireds.size;
      yp_buffer_append_u32(buffer, requireds_size);
      for (uint32_t index = 0; index < requireds_size; index++) {
        yp_serialize_node(parser, node->as.parameters_node.requireds.nodes[index], buffer);
      }
      uint32_t optionals_size = node->as.parameters_node.optionals.size;
      yp_buffer_append_u32(buffer, optionals_size);
      for (uint32_t index = 0; index < optionals_size; index++) {
        yp_serialize_node(parser, node->as.parameters_node.optionals.nodes[index], buffer);
      }
      if (node->as.parameters_node.rest == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.parameters_node.rest, buffer);
      }
      uint32_t keywords_size = node->as.parameters_node.keywords.size;
      yp_buffer_append_u32(buffer, keywords_size);
      for (uint32_t index = 0; index < keywords_size; index++) {
        yp_serialize_node(parser, node->as.parameters_node.keywords.nodes[index], buffer);
      }
      if (node->as.parameters_node.keyword_rest == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.parameters_node.keyword_rest, buffer);
      }
      if (node->as.parameters_node.block == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.parameters_node.block, buffer);
      }
      break;
    }
    case YP_NODE_PARENTHESES_NODE: {
      if (node->as.parentheses_node.statements == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.parentheses_node.statements, buffer);
      }
      serialize_location(parser, &node->as.parentheses_node.opening_loc, buffer);
      serialize_location(parser, &node->as.parentheses_node.closing_loc, buffer);
      break;
    }
    case YP_NODE_POST_EXECUTION_NODE: {
      yp_serialize_node(parser, node->as.post_execution_node.statements, buffer);
      serialize_location(parser, &node->as.post_execution_node.keyword_loc, buffer);
      serialize_location(parser, &node->as.post_execution_node.opening_loc, buffer);
      serialize_location(parser, &node->as.post_execution_node.closing_loc, buffer);
      break;
    }
    case YP_NODE_PRE_EXECUTION_NODE: {
      yp_serialize_node(parser, node->as.pre_execution_node.statements, buffer);
      serialize_location(parser, &node->as.pre_execution_node.keyword_loc, buffer);
      serialize_location(parser, &node->as.pre_execution_node.opening_loc, buffer);
      serialize_location(parser, &node->as.pre_execution_node.closing_loc, buffer);
      break;
    }
    case YP_NODE_PROGRAM_NODE: {
      yp_serialize_node(parser, node->as.program_node.scope, buffer);
      yp_serialize_node(parser, node->as.program_node.statements, buffer);
      break;
    }
    case YP_NODE_RANGE_NODE: {
      if (node->as.range_node.left == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.range_node.left, buffer);
      }
      if (node->as.range_node.right == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.range_node.right, buffer);
      }
      serialize_location(parser, &node->as.range_node.operator_loc, buffer);
      break;
    }
    case YP_NODE_RATIONAL_NODE: {
      break;
    }
    case YP_NODE_REDO_NODE: {
      break;
    }
    case YP_NODE_REGULAR_EXPRESSION_NODE: {
      serialize_token(parser, &node->as.regular_expression_node.opening, buffer);
      serialize_token(parser, &node->as.regular_expression_node.content, buffer);
      serialize_token(parser, &node->as.regular_expression_node.closing, buffer);
      uint32_t unescaped_length = yp_string_length(&node->as.regular_expression_node.unescaped);
      yp_buffer_append_u32(buffer, unescaped_length);
      yp_buffer_append_str(buffer, yp_string_source(&node->as.regular_expression_node.unescaped), unescaped_length);
      break;
    }
    case YP_NODE_REQUIRED_DESTRUCTURED_PARAMETER_NODE: {
      uint32_t parameters_size = node->as.required_destructured_parameter_node.parameters.size;
      yp_buffer_append_u32(buffer, parameters_size);
      for (uint32_t index = 0; index < parameters_size; index++) {
        yp_serialize_node(parser, node->as.required_destructured_parameter_node.parameters.nodes[index], buffer);
      }
      serialize_token(parser, &node->as.required_destructured_parameter_node.opening, buffer);
      serialize_token(parser, &node->as.required_destructured_parameter_node.closing, buffer);
      break;
    }
    case YP_NODE_REQUIRED_PARAMETER_NODE: {
      serialize_token(parser, &node->as.required_parameter_node.name, buffer);
      break;
    }
    case YP_NODE_RESCUE_MODIFIER_NODE: {
      yp_serialize_node(parser, node->as.rescue_modifier_node.expression, buffer);
      serialize_token(parser, &node->as.rescue_modifier_node.rescue_keyword, buffer);
      yp_serialize_node(parser, node->as.rescue_modifier_node.rescue_expression, buffer);
      break;
    }
    case YP_NODE_RESCUE_NODE: {
      serialize_token(parser, &node->as.rescue_node.rescue_keyword, buffer);
      uint32_t exceptions_size = node->as.rescue_node.exceptions.size;
      yp_buffer_append_u32(buffer, exceptions_size);
      for (uint32_t index = 0; index < exceptions_size; index++) {
        yp_serialize_node(parser, node->as.rescue_node.exceptions.nodes[index], buffer);
      }
      if (node->as.rescue_node.equal_greater.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.rescue_node.equal_greater, buffer);
      }
      if (node->as.rescue_node.exception == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.rescue_node.exception, buffer);
      }
      yp_serialize_node(parser, node->as.rescue_node.statements, buffer);
      if (node->as.rescue_node.consequent == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.rescue_node.consequent, buffer);
      }
      break;
    }
    case YP_NODE_REST_PARAMETER_NODE: {
      serialize_token(parser, &node->as.rest_parameter_node.operator, buffer);
      if (node->as.rest_parameter_node.name.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.rest_parameter_node.name, buffer);
      }
      break;
    }
    case YP_NODE_RETRY_NODE: {
      break;
    }
    case YP_NODE_RETURN_NODE: {
      serialize_token(parser, &node->as.return_node.keyword, buffer);
      if (node->as.return_node.arguments == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.return_node.arguments, buffer);
      }
      break;
    }
    case YP_NODE_SCOPE: {
      uint32_t locals_size = node->as.scope.locals.size;
      yp_buffer_append_u32(buffer, locals_size);
      for (uint32_t index = 0; index < locals_size; index++) {
        serialize_token(parser, &node->as.scope.locals.tokens[index], buffer);
      }
      break;
    }
    case YP_NODE_SELF_NODE: {
      break;
    }
    case YP_NODE_SINGLETON_CLASS_NODE: {
      yp_serialize_node(parser, node->as.singleton_class_node.scope, buffer);
      serialize_token(parser, &node->as.singleton_class_node.class_keyword, buffer);
      serialize_token(parser, &node->as.singleton_class_node.operator, buffer);
      yp_serialize_node(parser, node->as.singleton_class_node.expression, buffer);
      yp_serialize_node(parser, node->as.singleton_class_node.statements, buffer);
      serialize_token(parser, &node->as.singleton_class_node.end_keyword, buffer);
      break;
    }
    case YP_NODE_SOURCE_ENCODING_NODE: {
      break;
    }
    case YP_NODE_SOURCE_FILE_NODE: {
      break;
    }
    case YP_NODE_SOURCE_LINE_NODE: {
      break;
    }
    case YP_NODE_SPLAT_NODE: {
      serialize_token(parser, &node->as.splat_node.operator, buffer);
      if (node->as.splat_node.expression == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.splat_node.expression, buffer);
      }
      break;
    }
    case YP_NODE_STATEMENTS_NODE: {
      uint32_t body_size = node->as.statements_node.body.size;
      yp_buffer_append_u32(buffer, body_size);
      for (uint32_t index = 0; index < body_size; index++) {
        yp_serialize_node(parser, node->as.statements_node.body.nodes[index], buffer);
      }
      break;
    }
    case YP_NODE_STRING_CONCAT_NODE: {
      yp_serialize_node(parser, node->as.string_concat_node.left, buffer);
      yp_serialize_node(parser, node->as.string_concat_node.right, buffer);
      break;
    }
    case YP_NODE_STRING_INTERPOLATED_NODE: {
      serialize_token(parser, &node->as.string_interpolated_node.opening, buffer);
      yp_serialize_node(parser, node->as.string_interpolated_node.statements, buffer);
      serialize_token(parser, &node->as.string_interpolated_node.closing, buffer);
      break;
    }
    case YP_NODE_STRING_NODE: {
      if (node->as.string_node.opening.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.string_node.opening, buffer);
      }
      serialize_token(parser, &node->as.string_node.content, buffer);
      if (node->as.string_node.closing.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.string_node.closing, buffer);
      }
      uint32_t unescaped_length = yp_string_length(&node->as.string_node.unescaped);
      yp_buffer_append_u32(buffer, unescaped_length);
      yp_buffer_append_str(buffer, yp_string_source(&node->as.string_node.unescaped), unescaped_length);
      break;
    }
    case YP_NODE_SUPER_NODE: {
      serialize_token(parser, &node->as.super_node.keyword, buffer);
      if (node->as.super_node.lparen.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.super_node.lparen, buffer);
      }
      if (node->as.super_node.arguments == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.super_node.arguments, buffer);
      }
      if (node->as.super_node.rparen.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.super_node.rparen, buffer);
      }
      if (node->as.super_node.block == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.super_node.block, buffer);
      }
      break;
    }
    case YP_NODE_SYMBOL_NODE: {
      if (node->as.symbol_node.opening.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.symbol_node.opening, buffer);
      }
      serialize_token(parser, &node->as.symbol_node.value, buffer);
      if (node->as.symbol_node.closing.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.symbol_node.closing, buffer);
      }
      uint32_t unescaped_length = yp_string_length(&node->as.symbol_node.unescaped);
      yp_buffer_append_u32(buffer, unescaped_length);
      yp_buffer_append_str(buffer, yp_string_source(&node->as.symbol_node.unescaped), unescaped_length);
      break;
    }
    case YP_NODE_TERNARY_NODE: {
      yp_serialize_node(parser, node->as.ternary_node.predicate, buffer);
      serialize_token(parser, &node->as.ternary_node.question_mark, buffer);
      yp_serialize_node(parser, node->as.ternary_node.true_expression, buffer);
      serialize_token(parser, &node->as.ternary_node.colon, buffer);
      yp_serialize_node(parser, node->as.ternary_node.false_expression, buffer);
      break;
    }
    case YP_NODE_TRUE_NODE: {
      break;
    }
    case YP_NODE_UNDEF_NODE: {
      uint32_t names_size = node->as.undef_node.names.size;
      yp_buffer_append_u32(buffer, names_size);
      for (uint32_t index = 0; index < names_size; index++) {
        yp_serialize_node(parser, node->as.undef_node.names.nodes[index], buffer);
      }
      serialize_location(parser, &node->as.undef_node.keyword_loc, buffer);
      break;
    }
    case YP_NODE_UNLESS_NODE: {
      serialize_token(parser, &node->as.unless_node.keyword, buffer);
      yp_serialize_node(parser, node->as.unless_node.predicate, buffer);
      yp_serialize_node(parser, node->as.unless_node.statements, buffer);
      if (node->as.unless_node.consequent == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.unless_node.consequent, buffer);
      }
      if (node->as.unless_node.end_keyword.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.unless_node.end_keyword, buffer);
      }
      break;
    }
    case YP_NODE_UNTIL_NODE: {
      serialize_token(parser, &node->as.until_node.keyword, buffer);
      yp_serialize_node(parser, node->as.until_node.predicate, buffer);
      yp_serialize_node(parser, node->as.until_node.statements, buffer);
      break;
    }
    case YP_NODE_WHEN_NODE: {
      serialize_token(parser, &node->as.when_node.when_keyword, buffer);
      uint32_t conditions_size = node->as.when_node.conditions.size;
      yp_buffer_append_u32(buffer, conditions_size);
      for (uint32_t index = 0; index < conditions_size; index++) {
        yp_serialize_node(parser, node->as.when_node.conditions.nodes[index], buffer);
      }
      if (node->as.when_node.statements == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.when_node.statements, buffer);
      }
      break;
    }
    case YP_NODE_WHILE_NODE: {
      serialize_token(parser, &node->as.while_node.keyword, buffer);
      yp_serialize_node(parser, node->as.while_node.predicate, buffer);
      yp_serialize_node(parser, node->as.while_node.statements, buffer);
      break;
    }
    case YP_NODE_X_STRING_NODE: {
      serialize_token(parser, &node->as.x_string_node.opening, buffer);
      serialize_token(parser, &node->as.x_string_node.content, buffer);
      serialize_token(parser, &node->as.x_string_node.closing, buffer);
      uint32_t unescaped_length = yp_string_length(&node->as.x_string_node.unescaped);
      yp_buffer_append_u32(buffer, unescaped_length);
      yp_buffer_append_str(buffer, yp_string_source(&node->as.x_string_node.unescaped), unescaped_length);
      break;
    }
    case YP_NODE_YIELD_NODE: {
      serialize_token(parser, &node->as.yield_node.keyword, buffer);
      if (node->as.yield_node.lparen.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.yield_node.lparen, buffer);
      }
      if (node->as.yield_node.arguments == NULL) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        yp_serialize_node(parser, node->as.yield_node.arguments, buffer);
      }
      if (node->as.yield_node.rparen.type == YP_TOKEN_NOT_PROVIDED) {
        yp_buffer_append_u8(buffer, 0);
      } else {
        serialize_token(parser, &node->as.yield_node.rparen, buffer);
      }
      break;
    }
  }

  uint32_t length = buffer->length - offset - sizeof(uint32_t);
  memcpy(buffer->value + offset, &length, sizeof(uint32_t));
}
