.\"ruby.1 -				       -*- Nroff -*-
.\"  $Author: matz $
.\"  $Date: 1994/11/22 01:22:40 $
.\"  created at: Tue Apr 12 01:45:04 JST 1994
.TH RUBY 1 "\*(RP"
.UC
.SH NAME
ruby \- オブジェクト指向スクリプト言語
.SH SYNOPSIS
.B ruby
[
.B options
] filename args
.SH DESCRIPTION
.B Ruby
は, 手軽なオブジェクト指向プログラミングを実現するための種々
の機能を持つオブジェクト指向スクリプト言語である．その設計の
基本原則は, 以下の通りである.

.IP 機能性
オブジェクト指向プログラミングとスクリプトプログラミングのた
めに必要な機能を十分に備える. 特にテキスト処理関係の機能を豊
富に持つ。また, 純粋なオブジェクト指向言語でありながら, 必要
であれば手続き型プログラミングも可能である.
.IP 拡張性
必要に応じて容易に機能を拡張できる. クラスを自由に追加できる
ことは勿論, Cプログラムのリンクによってインタプリタにあらゆ
る機能を追加できる. さらにプラットフォームによっては, 動的に
オブジェクトコードをリンクする機能も提供する.
.IP 一貫性
少数の原則が全体に適用されるような一貫性のある言語仕様を持つ.
これによって「パズルの楽しさ」は減少したかも知れない. ただし,
一貫性のため使いやすさを犠牲にすることはない.
.PP
.B Ruby
はshやperlを知っている人にとっての常識にできる限り従ったので,
それらの言語に精通している人にとっては習得が(多分)容易だろう.
.SH OPTIONS 
.B ruby
インタプリタは以下の引数を受け付ける.
.TP 5
.B \-a
`\-n'や`\-p'とともに用いて, オートスプリットモードをONにする.
オートスプリットモードでは各ループの先頭で,
.nf
.ne 2

	$F = $_.split

.fi
が実行される. `\-n'か`\-p'オプションが同時に指定されない限り,
このオプションは意味を持たない.
.TP 5
.B \-c
スクリプトの内部形式へのコンパイルのみを行い, 実行しない. コ
ンパイル終了後, 文法エラーが無ければ, "Syntax OK"と出力する.
.TP 5
.B \-C " code"
.B ruby
の処理する漢字コードを指定する.
.B ruby
は指定した文字列が `E'または`e'から始まる場合は文字列やアク
セスするファイルがEUCで記述されていると仮定する. 同様に`S'ま
たは`s'の場合はSJISとして処理する. `N'は漢字を処理しない. デ
フォルトはEUC.
.nf
.ne 2

	ruby -C EUC -e 'print "テスト"'
	ruby -Ceuc -e 'print "テスト"'
	ruby -C 'Shift JIS' -e 'print "テスト"'
	ruby -CN 'print "テスト"'

.fi
このオプションは将来文字コードの自動判別機能が追加された場合
等には変更される.
.TP 5
.B \-d, \-\-debug
デバッグモードをonにする. このフラグがセットされるとシステム
変数$DEBUGがセットされる.
.TP 5
.B \-e " script"
コマンドラインからスクリプトを指定する. \-eオプションを付け
た時には引数からスクリプトファイル名を取らない.
.TP 5
.B \-F " 文字列"
入力フィールドセパレータ(`$;')の値を文字列にセットする. awk
の同名のオプションと同じ働きをする.
.TP 5
.B \-i " extension"
引数で指定されたファイルの内容を置き換える(in-place edit)こ
とを指定する. 元のファイルは拡張子をつけた形で保存される.
.nf
例:
.ne 2

	% echo matz > /tmp/junk
	% cat /tmp/junk
	matz
	% ruby -p -i.bak -e '$_.upcase' /tmp/junk
	% cat /tmp/junk
	MATZ
	% cat /tmp/junk.bak
	matz

.fi
.TP 5
.B \-I " directory"
ファイルをロードするパスを指定(追加)する. 指定されたディレク
トリは
.B ruby
の配列変数$LOAD_PATHに追加される.
.TP 5
.B \-l
`$\\'を`$/'と同じ値に設定し, print()での出力時に改行を付加す
る. また, \-nまたは\-pとともに用いられると, 入力された各行の
最後の文字をchopする.
.TP 5
.B \-n
このフラグがセットされるとプログラム全体が
.nf
.ne 2

	while gets()
	  \.\.\.
	end

.fi
で囲まれているように動作する.
.TP 5
.B \-p
`\-n'フラグと同じだが, 各ループの最後に変数`$_'の値を出力する.
.nf
例:
.ne 2

	% echo matz | ruby \-p \-e '$_\.tr "a-z", "A-Z"'
	MATZ

.fi
.TP 5
.B \-R 文字列(または8進数)
入力レコードセパレータ(`$/')の値を文字列にセットする. 文字列
がすべて数字(0-7まで)から構成されている時には, その8進数で指
定されたコードをもつ文字をセパレータとする.

この場合, \-R0で, パラグラフモード, \-R777で(そのコードを持
つ文字は存在しないので)全ファイルを一度に読み込むモードに設
定できる.
.TP 5
.B \-s
スクリプト名に続く, \-で始まる引数を解釈して, 同名の大域変数
に値を設定する. `\-\-'なる引数以降は解釈を行なわない. 該当す
る引数は$ARGVから取り除かれる.
.nf
例:
.ne 2

	#! /usr/local/bin/ruby \-s
	# \-xyzオプションが与えられると"true"を表示する.
	print "true\n" if $xyz

.fi
.TP 5
.B \-S
スクリプト名が`/'で始まっていない場合, 環境変数`PATH'の値を
使ってスクリプトを探す.  これは、#! をサポートしていないマシ
ンで、#! による実行をエミュレートするために、以下のようにし
て使うことができる:

        #! /usr/local/bin/ruby
	# This line makes the next one a comment in ruby \
        eval "exec /usr/local/bin/ruby -S $0 $*"

システムは最初の行を無視し，スクリプトを`/bin/sh'に渡す．
`/bin/sh'はrubyスクリプトをシェルスクリプトとして実行しよう
とする．シェルは2行目だけをコメントであると解釈し，3行目を通
常のシェルコマンドとして実行し，rubyインタプリタを起動する．

システムによっては`$0'は必ずしもフルパスを含まないので，`-S'
を用いてrubyに必要に応じてスクリプトを探すように指示する．
rubyがスクリプトを見つけると、これらの行の解析を始めるが，
rubyは2行目の行末にあるバックスラッシュにより，2行目のコメン
トが3行目まで継続するとみなして，3行目を無視する．

ファイル名に含まれるスペースなどを正しく扱うには，`$*'よりも
`${1+"$@"}'のほうがよいだろうが，cshが解釈する場合には動作し
ない．

.TP 5
.B \-v, \-\-verbose
冗長モード. 起動時にバージョン番号の表示を行い, システム変数 
$VERBOSEをセットする. この変数がセットされている時, いくつか
のメソッドは実行時に冗長なメッセージを出力する. \-v オプショ
ンが指定されてq, オプション以外の引数がない時にはバージョン
を表示した後, 実行を終了する(標準入力からのスクリプトを待た
ない).
.TP 5
.B \-\-version
.B ruby
のバージョンを表示する.
.nf
表示例:
.ne 2

	ruby - version 0.56 (94/11/19)

.fi
.TP 5
.B \-x
メッセージ中のスクリプトを取り出して実行する. #!で始まり,
"ruby"という文字列を含む行までを読み飛ばす. スクリプトの終り
はEOF(ファイルの終り), ^D(コントロールD), ^Z(コントロールZ)
または予約語``__END__''で指定する.
.TP 5
.B \-X " directory"
スクリプト実行前に指定されたディレクトリに移る.
.TP 5
.B \-y, \-\-yydebug
コンパイラデバッグモード. コンパイル時の構文解析の過程を表示
する. この表示は非常に冗長なので, コンパイラそのものをデバッ
グする人以外は表示させない方が良いと思う.

.SH BUGS
.PP
遅い. 単純な処理の場合perlやawkなどの2,3倍の実行時間がかかる.
これらの言語と異なり, その提供する機能のほとんどがメソッド呼
び出しを介することが原因だが, 他の言語でも関数呼び出しが多く
なるような処理ではメソッドキャッシュの分だけ
.B ruby
が有利になるし, データ構造が複雑になれば, オブジェクト指向の
メリットが活かせるので, まあ許せるかも知れない.
.PP
perlより記述量が多い. これは
.B ruby
が一貫性を追求した結果である. だが, その結果,
.B ruby
スクリプトはperlより読みやすいはずで, 若干の記述量を犠牲に理
解しやすさと可読性を得ていると思って欲しい.
.PP
ドキュメントが不十分. 必要な情報を得るためにはソースを読んで
欲しい.
.PP
テストが不十分. バグにつき当たったら, できれば自分で直して,
こっそり私に教えて欲しい. 無理ならば, せめてバグが再現する条
件を明確にしてレポートして欲しい.

.SH AUTHOR
松本 行弘 (matz@caelum.co.jp)
