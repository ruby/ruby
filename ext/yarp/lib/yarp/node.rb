=begin
This file is generated by the bin/template script and should not be
modified manually. See bin/templates/lib/yarp/node.rb.erb
if you are looking to modify the template
=end

module YARP
  # Represents the use of the `alias` keyword.
  # 
  #     alias foo bar
  #     ^^^^^^^^^^^^^
  class AliasNode < Node
    # attr_reader new_name: Node
    attr_reader :new_name

    # attr_reader old_name: Node
    attr_reader :old_name

    # attr_reader keyword_loc: Location
    attr_reader :keyword_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (new_name: Node, old_name: Node, keyword_loc: Location, location: Location) -> void
    def initialize(new_name, old_name, keyword_loc, location)
      @new_name = new_name
      @old_name = old_name
      @keyword_loc = keyword_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_alias_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [new_name, old_name]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { new_name: new_name, old_name: old_name, keyword_loc: keyword_loc, location: location }
    end
  end

  # Represents an alternation pattern in pattern matching.
  # 
  #     foo => bar | baz
  #            ^^^^^^^^^
  class AlternationPatternNode < Node
    # attr_reader left: Node
    attr_reader :left

    # attr_reader right: Node
    attr_reader :right

    # attr_reader operator_loc: Location
    attr_reader :operator_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (left: Node, right: Node, operator_loc: Location, location: Location) -> void
    def initialize(left, right, operator_loc, location)
      @left = left
      @right = right
      @operator_loc = operator_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_alternation_pattern_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [left, right]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { left: left, right: right, operator_loc: operator_loc, location: location }
    end
  end

  # Represents the use of the `&&` operator or the `and` keyword.
  # 
  #     left and right
  #     ^^^^^^^^^^^^^^
  class AndNode < Node
    # attr_reader left: Node
    attr_reader :left

    # attr_reader right: Node
    attr_reader :right

    # attr_reader operator: Token
    attr_reader :operator

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (left: Node, right: Node, operator: Token, location: Location) -> void
    def initialize(left, right, operator, location)
      @left = left
      @right = right
      @operator = operator
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_and_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [left, right]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { left: left, right: right, operator: operator, location: location }
    end
  end

  # Represents a set of arguments to a method or a keyword.
  # 
  #     return foo, bar, baz
  #            ^^^^^^^^^^^^^
  class ArgumentsNode < Node
    # attr_reader arguments: Array[Node]
    attr_reader :arguments

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (arguments: Array[Node], location: Location) -> void
    def initialize(arguments, location)
      @arguments = arguments
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_arguments_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [*arguments]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { arguments: arguments, location: location }
    end
  end

  # Represents an array literal. This can be a regular array using brackets or
  # a special array using % like %w or %i.
  # 
  #     [1, 2, 3]
  #     ^^^^^^^^^
  class ArrayNode < Node
    # attr_reader elements: Array[Node]
    attr_reader :elements

    # attr_reader opening: Token?
    attr_reader :opening

    # attr_reader closing: Token?
    attr_reader :closing

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (elements: Array[Node], opening: Token?, closing: Token?, location: Location) -> void
    def initialize(elements, opening, closing, location)
      @elements = elements
      @opening = opening
      @closing = closing
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_array_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [*elements]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { elements: elements, opening: opening, closing: closing, location: location }
    end
  end

  # Represents an array pattern in pattern matching.
  # 
  #     foo in 1, 2
  #     ^^^^^^^^^^^
  # 
  #     foo in [1, 2]
  #     ^^^^^^^^^^^^^
  # 
  #     foo in *1
  #     ^^^^^^^^^
  # 
  #     foo in Bar[]
  #     ^^^^^^^^^^^^
  # 
  #     foo in Bar[1, 2, 3]
  #     ^^^^^^^^^^^^^^^^^^^
  class ArrayPatternNode < Node
    # attr_reader constant: Node?
    attr_reader :constant

    # attr_reader requireds: Array[Node]
    attr_reader :requireds

    # attr_reader rest: Node?
    attr_reader :rest

    # attr_reader posts: Array[Node]
    attr_reader :posts

    # attr_reader opening_loc: Location?
    attr_reader :opening_loc

    # attr_reader closing_loc: Location?
    attr_reader :closing_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (constant: Node?, requireds: Array[Node], rest: Node?, posts: Array[Node], opening_loc: Location?, closing_loc: Location?, location: Location) -> void
    def initialize(constant, requireds, rest, posts, opening_loc, closing_loc, location)
      @constant = constant
      @requireds = requireds
      @rest = rest
      @posts = posts
      @opening_loc = opening_loc
      @closing_loc = closing_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_array_pattern_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [constant, *requireds, rest, *posts]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { constant: constant, requireds: requireds, rest: rest, posts: posts, opening_loc: opening_loc, closing_loc: closing_loc, location: location }
    end
  end

  # Represents a hash key/value pair.
  # 
  #     { a => b }
  #       ^^^^^^
  class AssocNode < Node
    # attr_reader key: Node
    attr_reader :key

    # attr_reader value: Node?
    attr_reader :value

    # attr_reader operator: Token?
    attr_reader :operator

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (key: Node, value: Node?, operator: Token?, location: Location) -> void
    def initialize(key, value, operator, location)
      @key = key
      @value = value
      @operator = operator
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_assoc_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [key, value]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { key: key, value: value, operator: operator, location: location }
    end
  end

  # Represents a splat in a hash literal.
  # 
  #     { **foo }
  #       ^^^^^
  class AssocSplatNode < Node
    # attr_reader value: Node?
    attr_reader :value

    # attr_reader operator_loc: Location
    attr_reader :operator_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (value: Node?, operator_loc: Location, location: Location) -> void
    def initialize(value, operator_loc, location)
      @value = value
      @operator_loc = operator_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_assoc_splat_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [value]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { value: value, operator_loc: operator_loc, location: location }
    end
  end

  # Represents a begin statement.
  # 
  #     begin
  #       foo
  #     end
  #     ^^^^^
  class BeginNode < Node
    # attr_reader begin_keyword: Token?
    attr_reader :begin_keyword

    # attr_reader statements: Node?
    attr_reader :statements

    # attr_reader rescue_clause: Node?
    attr_reader :rescue_clause

    # attr_reader else_clause: Node?
    attr_reader :else_clause

    # attr_reader ensure_clause: Node?
    attr_reader :ensure_clause

    # attr_reader end_keyword: Token?
    attr_reader :end_keyword

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (begin_keyword: Token?, statements: Node?, rescue_clause: Node?, else_clause: Node?, ensure_clause: Node?, end_keyword: Token?, location: Location) -> void
    def initialize(begin_keyword, statements, rescue_clause, else_clause, ensure_clause, end_keyword, location)
      @begin_keyword = begin_keyword
      @statements = statements
      @rescue_clause = rescue_clause
      @else_clause = else_clause
      @ensure_clause = ensure_clause
      @end_keyword = end_keyword
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_begin_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [statements, rescue_clause, else_clause, ensure_clause]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { begin_keyword: begin_keyword, statements: statements, rescue_clause: rescue_clause, else_clause: else_clause, ensure_clause: ensure_clause, end_keyword: end_keyword, location: location }
    end
  end

  # Represents block method arguments.
  # 
  #     bar(&args)
  #     ^^^^^^^^^^
  class BlockArgumentNode < Node
    # attr_reader expression: Node?
    attr_reader :expression

    # attr_reader operator_loc: Location
    attr_reader :operator_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (expression: Node?, operator_loc: Location, location: Location) -> void
    def initialize(expression, operator_loc, location)
      @expression = expression
      @operator_loc = operator_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_block_argument_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [expression]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { expression: expression, operator_loc: operator_loc, location: location }
    end
  end

  # Represents a block of ruby code.
  # 
  # [1, 2, 3].each { |i| puts x }
  #                ^^^^^^^^^^^^^^
  class BlockNode < Node
    # attr_reader scope: Node
    attr_reader :scope

    # attr_reader parameters: Node?
    attr_reader :parameters

    # attr_reader statements: Node?
    attr_reader :statements

    # attr_reader opening_loc: Location
    attr_reader :opening_loc

    # attr_reader closing_loc: Location
    attr_reader :closing_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (scope: Node, parameters: Node?, statements: Node?, opening_loc: Location, closing_loc: Location, location: Location) -> void
    def initialize(scope, parameters, statements, opening_loc, closing_loc, location)
      @scope = scope
      @parameters = parameters
      @statements = statements
      @opening_loc = opening_loc
      @closing_loc = closing_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_block_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [scope, parameters, statements]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { scope: scope, parameters: parameters, statements: statements, opening_loc: opening_loc, closing_loc: closing_loc, location: location }
    end
  end

  # Represents a block parameter to a method, block, or lambda definition.
  # 
  #     def a(&b)
  #           ^^
  #     end
  class BlockParameterNode < Node
    # attr_reader name: Token?
    attr_reader :name

    # attr_reader operator_loc: Location
    attr_reader :operator_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (name: Token?, operator_loc: Location, location: Location) -> void
    def initialize(name, operator_loc, location)
      @name = name
      @operator_loc = operator_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_block_parameter_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      []
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { name: name, operator_loc: operator_loc, location: location }
    end
  end

  # Represents a block's parameters declaration.
  # 
  #     -> (a, b = 1; local) { }
  #        ^^^^^^^^^^^^^^^^^
  # 
  #     foo do |a, b = 1; local|
  #            ^^^^^^^^^^^^^^^^^
  #     end
  class BlockParametersNode < Node
    # attr_reader parameters: Node?
    attr_reader :parameters

    # attr_reader locals: Array[Token]
    attr_reader :locals

    # attr_reader opening_loc: Location?
    attr_reader :opening_loc

    # attr_reader closing_loc: Location?
    attr_reader :closing_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (parameters: Node?, locals: Array[Token], opening_loc: Location?, closing_loc: Location?, location: Location) -> void
    def initialize(parameters, locals, opening_loc, closing_loc, location)
      @parameters = parameters
      @locals = locals
      @opening_loc = opening_loc
      @closing_loc = closing_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_block_parameters_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [parameters]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { parameters: parameters, locals: locals, opening_loc: opening_loc, closing_loc: closing_loc, location: location }
    end
  end

  # Represents the use of the `break` keyword.
  # 
  #     break foo
  #     ^^^^^^^^^
  class BreakNode < Node
    # attr_reader arguments: Node?
    attr_reader :arguments

    # attr_reader keyword_loc: Location
    attr_reader :keyword_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (arguments: Node?, keyword_loc: Location, location: Location) -> void
    def initialize(arguments, keyword_loc, location)
      @arguments = arguments
      @keyword_loc = keyword_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_break_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [arguments]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { arguments: arguments, keyword_loc: keyword_loc, location: location }
    end
  end

  # Represents a method call, in all of the various forms that can take.
  # 
  #     foo
  #     ^^^
  # 
  #     foo()
  #     ^^^^^
  # 
  #     +foo
  #     ^^^^
  # 
  #     foo + bar
  #     ^^^^^^^^^
  # 
  #     foo.bar
  #     ^^^^^^^
  # 
  #     foo&.bar
  #     ^^^^^^^^
  class CallNode < Node
    # attr_reader receiver: Node?
    attr_reader :receiver

    # attr_reader call_operator: Token?
    attr_reader :call_operator

    # attr_reader message: Token?
    attr_reader :message

    # attr_reader opening: Token?
    attr_reader :opening

    # attr_reader arguments: Node?
    attr_reader :arguments

    # attr_reader closing: Token?
    attr_reader :closing

    # attr_reader block: Node?
    attr_reader :block

    # attr_reader name: String
    attr_reader :name

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (receiver: Node?, call_operator: Token?, message: Token?, opening: Token?, arguments: Node?, closing: Token?, block: Node?, name: String, location: Location) -> void
    def initialize(receiver, call_operator, message, opening, arguments, closing, block, name, location)
      @receiver = receiver
      @call_operator = call_operator
      @message = message
      @opening = opening
      @arguments = arguments
      @closing = closing
      @block = block
      @name = name
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_call_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [receiver, arguments, block]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { receiver: receiver, call_operator: call_operator, message: message, opening: opening, arguments: arguments, closing: closing, block: block, name: name, location: location }
    end
  end

  # Represents assigning to a local variable in pattern matching.
  # 
  #     foo => [bar => baz]
  #            ^^^^^^^^^^^^
  class CapturePatternNode < Node
    # attr_reader value: Node
    attr_reader :value

    # attr_reader target: Node
    attr_reader :target

    # attr_reader operator_loc: Location
    attr_reader :operator_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (value: Node, target: Node, operator_loc: Location, location: Location) -> void
    def initialize(value, target, operator_loc, location)
      @value = value
      @target = target
      @operator_loc = operator_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_capture_pattern_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [value, target]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { value: value, target: target, operator_loc: operator_loc, location: location }
    end
  end

  # Represents the use of a case statement.
  # 
  # case true
  # ^^^^^^^^^
  # when false
  # end
  class CaseNode < Node
    # attr_reader predicate: Node?
    attr_reader :predicate

    # attr_reader conditions: Array[Node]
    attr_reader :conditions

    # attr_reader consequent: Node?
    attr_reader :consequent

    # attr_reader case_keyword_loc: Location
    attr_reader :case_keyword_loc

    # attr_reader end_keyword_loc: Location
    attr_reader :end_keyword_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (predicate: Node?, conditions: Array[Node], consequent: Node?, case_keyword_loc: Location, end_keyword_loc: Location, location: Location) -> void
    def initialize(predicate, conditions, consequent, case_keyword_loc, end_keyword_loc, location)
      @predicate = predicate
      @conditions = conditions
      @consequent = consequent
      @case_keyword_loc = case_keyword_loc
      @end_keyword_loc = end_keyword_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_case_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [predicate, *conditions, consequent]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { predicate: predicate, conditions: conditions, consequent: consequent, case_keyword_loc: case_keyword_loc, end_keyword_loc: end_keyword_loc, location: location }
    end
  end

  # Represents a class declaration involving the `class` keyword.
  # 
  #     class Foo end
  #     ^^^^^^^^^^^^^
  class ClassNode < Node
    # attr_reader scope: Node
    attr_reader :scope

    # attr_reader class_keyword: Token
    attr_reader :class_keyword

    # attr_reader constant_path: Node
    attr_reader :constant_path

    # attr_reader inheritance_operator: Token?
    attr_reader :inheritance_operator

    # attr_reader superclass: Node?
    attr_reader :superclass

    # attr_reader statements: Node?
    attr_reader :statements

    # attr_reader end_keyword: Token
    attr_reader :end_keyword

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (scope: Node, class_keyword: Token, constant_path: Node, inheritance_operator: Token?, superclass: Node?, statements: Node?, end_keyword: Token, location: Location) -> void
    def initialize(scope, class_keyword, constant_path, inheritance_operator, superclass, statements, end_keyword, location)
      @scope = scope
      @class_keyword = class_keyword
      @constant_path = constant_path
      @inheritance_operator = inheritance_operator
      @superclass = superclass
      @statements = statements
      @end_keyword = end_keyword
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_class_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [scope, constant_path, superclass, statements]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { scope: scope, class_keyword: class_keyword, constant_path: constant_path, inheritance_operator: inheritance_operator, superclass: superclass, statements: statements, end_keyword: end_keyword, location: location }
    end
  end

  # Represents referencing a class variable.
  # 
  #     @@foo
  #     ^^^^^
  class ClassVariableReadNode < Node
    # attr_reader location: Location
    attr_reader :location

    # def initialize: (location: Location) -> void
    def initialize(location)
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_class_variable_read_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      []
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { location: location }
    end
  end

  # Represents writing to a class variable.
  # 
  #     @@foo = 1
  #     ^^^^^^^^^
  class ClassVariableWriteNode < Node
    # attr_reader name_loc: Location
    attr_reader :name_loc

    # attr_reader value: Node?
    attr_reader :value

    # attr_reader operator_loc: Location?
    attr_reader :operator_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (name_loc: Location, value: Node?, operator_loc: Location?, location: Location) -> void
    def initialize(name_loc, value, operator_loc, location)
      @name_loc = name_loc
      @value = value
      @operator_loc = operator_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_class_variable_write_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [value]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { name_loc: name_loc, value: value, operator_loc: operator_loc, location: location }
    end
  end

  # Represents accessing a constant through a path of `::` operators.
  # 
  #     Foo::Bar
  #     ^^^^^^^^
  class ConstantPathNode < Node
    # attr_reader parent: Node?
    attr_reader :parent

    # attr_reader child: Node
    attr_reader :child

    # attr_reader delimiter_loc: Location
    attr_reader :delimiter_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (parent: Node?, child: Node, delimiter_loc: Location, location: Location) -> void
    def initialize(parent, child, delimiter_loc, location)
      @parent = parent
      @child = child
      @delimiter_loc = delimiter_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_constant_path_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [parent, child]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { parent: parent, child: child, delimiter_loc: delimiter_loc, location: location }
    end
  end

  # Represents writing to a constant.
  # 
  #     Foo = 1
  #     ^^^^^^^
  # 
  #     Foo::Bar = 1
  #     ^^^^^^^^^^^^
  class ConstantPathWriteNode < Node
    # attr_reader target: Node
    attr_reader :target

    # attr_reader operator: Token?
    attr_reader :operator

    # attr_reader value: Node?
    attr_reader :value

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (target: Node, operator: Token?, value: Node?, location: Location) -> void
    def initialize(target, operator, value, location)
      @target = target
      @operator = operator
      @value = value
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_constant_path_write_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [target, value]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { target: target, operator: operator, value: value, location: location }
    end
  end

  # Represents referencing a constant.
  # 
  #     Foo
  #     ^^^
  class ConstantReadNode < Node
    # attr_reader location: Location
    attr_reader :location

    # def initialize: (location: Location) -> void
    def initialize(location)
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_constant_read_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      []
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { location: location }
    end
  end

  # Represents a method definition.
  # 
  #     def method
  #     end
  #     ^^^^^^^^^^
  class DefNode < Node
    # attr_reader name: Token
    attr_reader :name

    # attr_reader receiver: Node?
    attr_reader :receiver

    # attr_reader parameters: Node?
    attr_reader :parameters

    # attr_reader statements: Node?
    attr_reader :statements

    # attr_reader scope: Node
    attr_reader :scope

    # attr_reader def_keyword_loc: Location
    attr_reader :def_keyword_loc

    # attr_reader operator_loc: Location?
    attr_reader :operator_loc

    # attr_reader lparen_loc: Location?
    attr_reader :lparen_loc

    # attr_reader rparen_loc: Location?
    attr_reader :rparen_loc

    # attr_reader equal_loc: Location?
    attr_reader :equal_loc

    # attr_reader end_keyword_loc: Location?
    attr_reader :end_keyword_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (name: Token, receiver: Node?, parameters: Node?, statements: Node?, scope: Node, def_keyword_loc: Location, operator_loc: Location?, lparen_loc: Location?, rparen_loc: Location?, equal_loc: Location?, end_keyword_loc: Location?, location: Location) -> void
    def initialize(name, receiver, parameters, statements, scope, def_keyword_loc, operator_loc, lparen_loc, rparen_loc, equal_loc, end_keyword_loc, location)
      @name = name
      @receiver = receiver
      @parameters = parameters
      @statements = statements
      @scope = scope
      @def_keyword_loc = def_keyword_loc
      @operator_loc = operator_loc
      @lparen_loc = lparen_loc
      @rparen_loc = rparen_loc
      @equal_loc = equal_loc
      @end_keyword_loc = end_keyword_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_def_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [receiver, parameters, statements, scope]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { name: name, receiver: receiver, parameters: parameters, statements: statements, scope: scope, def_keyword_loc: def_keyword_loc, operator_loc: operator_loc, lparen_loc: lparen_loc, rparen_loc: rparen_loc, equal_loc: equal_loc, end_keyword_loc: end_keyword_loc, location: location }
    end
  end

  # Represents the use of the `defined?` keyword.
  # 
  #     defined?(a)
  #     ^^^^^^^^^^^
  class DefinedNode < Node
    # attr_reader lparen: Token?
    attr_reader :lparen

    # attr_reader value: Node
    attr_reader :value

    # attr_reader rparen: Token?
    attr_reader :rparen

    # attr_reader keyword_loc: Location
    attr_reader :keyword_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (lparen: Token?, value: Node, rparen: Token?, keyword_loc: Location, location: Location) -> void
    def initialize(lparen, value, rparen, keyword_loc, location)
      @lparen = lparen
      @value = value
      @rparen = rparen
      @keyword_loc = keyword_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_defined_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [value]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { lparen: lparen, value: value, rparen: rparen, keyword_loc: keyword_loc, location: location }
    end
  end

  # Represents an `else` clause in a `case`, `if`, or `unless` statement.
  # 
  #     if a then b else c end
  #                 ^^^^^^^^^^
  class ElseNode < Node
    # attr_reader else_keyword: Token
    attr_reader :else_keyword

    # attr_reader statements: Node?
    attr_reader :statements

    # attr_reader end_keyword: Token?
    attr_reader :end_keyword

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (else_keyword: Token, statements: Node?, end_keyword: Token?, location: Location) -> void
    def initialize(else_keyword, statements, end_keyword, location)
      @else_keyword = else_keyword
      @statements = statements
      @end_keyword = end_keyword
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_else_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [statements]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { else_keyword: else_keyword, statements: statements, end_keyword: end_keyword, location: location }
    end
  end

  # Represents an `ensure` clause in a `begin` statement.
  # 
  #     begin
  #       foo
  #     ensure
  #     ^^^^^^
  #       bar
  #     end
  class EnsureNode < Node
    # attr_reader ensure_keyword: Token
    attr_reader :ensure_keyword

    # attr_reader statements: Node?
    attr_reader :statements

    # attr_reader end_keyword: Token
    attr_reader :end_keyword

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (ensure_keyword: Token, statements: Node?, end_keyword: Token, location: Location) -> void
    def initialize(ensure_keyword, statements, end_keyword, location)
      @ensure_keyword = ensure_keyword
      @statements = statements
      @end_keyword = end_keyword
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_ensure_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [statements]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { ensure_keyword: ensure_keyword, statements: statements, end_keyword: end_keyword, location: location }
    end
  end

  # Represents the use of the literal `false` keyword.
  # 
  #     false
  #     ^^^^^
  class FalseNode < Node
    # attr_reader location: Location
    attr_reader :location

    # def initialize: (location: Location) -> void
    def initialize(location)
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_false_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      []
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { location: location }
    end
  end

  # Represents a find pattern in pattern matching.
  # 
  #     foo in *bar, baz, *qux
  #     ^^^^^^^^^^^^^^^^^^^^^^
  # 
  #     foo in [*bar, baz, *qux]
  #     ^^^^^^^^^^^^^^^^^^^^^^^^
  # 
  #     foo in Foo(*bar, baz, *qux)
  #     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  class FindPatternNode < Node
    # attr_reader constant: Node?
    attr_reader :constant

    # attr_reader left: Node
    attr_reader :left

    # attr_reader requireds: Array[Node]
    attr_reader :requireds

    # attr_reader right: Node
    attr_reader :right

    # attr_reader opening_loc: Location?
    attr_reader :opening_loc

    # attr_reader closing_loc: Location?
    attr_reader :closing_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (constant: Node?, left: Node, requireds: Array[Node], right: Node, opening_loc: Location?, closing_loc: Location?, location: Location) -> void
    def initialize(constant, left, requireds, right, opening_loc, closing_loc, location)
      @constant = constant
      @left = left
      @requireds = requireds
      @right = right
      @opening_loc = opening_loc
      @closing_loc = closing_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_find_pattern_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [constant, left, *requireds, right]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { constant: constant, left: left, requireds: requireds, right: right, opening_loc: opening_loc, closing_loc: closing_loc, location: location }
    end
  end

  # Represents a floating point number literal.
  # 
  #     1.0
  #     ^^^
  class FloatNode < Node
    # attr_reader location: Location
    attr_reader :location

    # def initialize: (location: Location) -> void
    def initialize(location)
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_float_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      []
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { location: location }
    end
  end

  # Represents the use of the `for` keyword.
  # 
  #     for i in a end
  #     ^^^^^^^^^^^^^^
  class ForNode < Node
    # attr_reader index: Node
    attr_reader :index

    # attr_reader collection: Node
    attr_reader :collection

    # attr_reader statements: Node?
    attr_reader :statements

    # attr_reader for_keyword_loc: Location
    attr_reader :for_keyword_loc

    # attr_reader in_keyword_loc: Location
    attr_reader :in_keyword_loc

    # attr_reader do_keyword_loc: Location?
    attr_reader :do_keyword_loc

    # attr_reader end_keyword_loc: Location
    attr_reader :end_keyword_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (index: Node, collection: Node, statements: Node?, for_keyword_loc: Location, in_keyword_loc: Location, do_keyword_loc: Location?, end_keyword_loc: Location, location: Location) -> void
    def initialize(index, collection, statements, for_keyword_loc, in_keyword_loc, do_keyword_loc, end_keyword_loc, location)
      @index = index
      @collection = collection
      @statements = statements
      @for_keyword_loc = for_keyword_loc
      @in_keyword_loc = in_keyword_loc
      @do_keyword_loc = do_keyword_loc
      @end_keyword_loc = end_keyword_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_for_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [index, collection, statements]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { index: index, collection: collection, statements: statements, for_keyword_loc: for_keyword_loc, in_keyword_loc: in_keyword_loc, do_keyword_loc: do_keyword_loc, end_keyword_loc: end_keyword_loc, location: location }
    end
  end

  # Represents forwarding all arguments to this method to another method.
  # 
  #     def foo(...)
  #       bar(...)
  #       ^^^^^^^^
  #     end
  class ForwardingArgumentsNode < Node
    # attr_reader location: Location
    attr_reader :location

    # def initialize: (location: Location) -> void
    def initialize(location)
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_forwarding_arguments_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      []
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { location: location }
    end
  end

  # Represents the use of the forwarding parameter in a method, block, or lambda declaration.
  # 
  #     def foo(...)
  #             ^^^
  #     end
  class ForwardingParameterNode < Node
    # attr_reader location: Location
    attr_reader :location

    # def initialize: (location: Location) -> void
    def initialize(location)
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_forwarding_parameter_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      []
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { location: location }
    end
  end

  # Represents the use of the `super` keyword without parentheses or arguments.
  # 
  #     super
  #     ^^^^^
  class ForwardingSuperNode < Node
    # attr_reader block: Node?
    attr_reader :block

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (block: Node?, location: Location) -> void
    def initialize(block, location)
      @block = block
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_forwarding_super_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [block]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { block: block, location: location }
    end
  end

  # Represents referencing a global variable.
  # 
  #     $foo
  #     ^^^^
  class GlobalVariableReadNode < Node
    # attr_reader name: Token
    attr_reader :name

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (name: Token, location: Location) -> void
    def initialize(name, location)
      @name = name
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_global_variable_read_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      []
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { name: name, location: location }
    end
  end

  # Represents writing to a global variable.
  # 
  #     $foo = 1
  #     ^^^^^^^^
  class GlobalVariableWriteNode < Node
    # attr_reader name: Token
    attr_reader :name

    # attr_reader operator: Token?
    attr_reader :operator

    # attr_reader value: Node?
    attr_reader :value

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (name: Token, operator: Token?, value: Node?, location: Location) -> void
    def initialize(name, operator, value, location)
      @name = name
      @operator = operator
      @value = value
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_global_variable_write_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [value]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { name: name, operator: operator, value: value, location: location }
    end
  end

  # Represents a hash literal.
  # 
  #     { a => b }
  #     ^^^^^^^^^^
  class HashNode < Node
    # attr_reader opening: Token?
    attr_reader :opening

    # attr_reader elements: Array[Node]
    attr_reader :elements

    # attr_reader closing: Token?
    attr_reader :closing

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (opening: Token?, elements: Array[Node], closing: Token?, location: Location) -> void
    def initialize(opening, elements, closing, location)
      @opening = opening
      @elements = elements
      @closing = closing
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_hash_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [*elements]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { opening: opening, elements: elements, closing: closing, location: location }
    end
  end

  # Represents a hash pattern in pattern matching.
  # 
  #     foo => { a: 1, b: 2 }
  #            ^^^^^^^^^^^^^^
  # 
  #     foo => { a: 1, b: 2, **c }
  #            ^^^^^^^^^^^^^^^^^^^
  class HashPatternNode < Node
    # attr_reader constant: Node?
    attr_reader :constant

    # attr_reader assocs: Array[Node]
    attr_reader :assocs

    # attr_reader kwrest: Node?
    attr_reader :kwrest

    # attr_reader opening_loc: Location?
    attr_reader :opening_loc

    # attr_reader closing_loc: Location?
    attr_reader :closing_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (constant: Node?, assocs: Array[Node], kwrest: Node?, opening_loc: Location?, closing_loc: Location?, location: Location) -> void
    def initialize(constant, assocs, kwrest, opening_loc, closing_loc, location)
      @constant = constant
      @assocs = assocs
      @kwrest = kwrest
      @opening_loc = opening_loc
      @closing_loc = closing_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_hash_pattern_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [constant, *assocs, kwrest]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { constant: constant, assocs: assocs, kwrest: kwrest, opening_loc: opening_loc, closing_loc: closing_loc, location: location }
    end
  end

  # Represents the use of the `if` keyword, either in the block form or the modifier form.
  # 
  #     bar if foo
  #     ^^^^^^^^^^
  # 
  #     if foo then bar end
  #     ^^^^^^^^^^^^^^^^^^^
  class IfNode < Node
    # attr_reader if_keyword: Token
    attr_reader :if_keyword

    # attr_reader predicate: Node
    attr_reader :predicate

    # attr_reader statements: Node?
    attr_reader :statements

    # attr_reader consequent: Node?
    attr_reader :consequent

    # attr_reader end_keyword: Token?
    attr_reader :end_keyword

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (if_keyword: Token, predicate: Node, statements: Node?, consequent: Node?, end_keyword: Token?, location: Location) -> void
    def initialize(if_keyword, predicate, statements, consequent, end_keyword, location)
      @if_keyword = if_keyword
      @predicate = predicate
      @statements = statements
      @consequent = consequent
      @end_keyword = end_keyword
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_if_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [predicate, statements, consequent]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { if_keyword: if_keyword, predicate: predicate, statements: statements, consequent: consequent, end_keyword: end_keyword, location: location }
    end
  end

  # Represents an imaginary number literal.
  # 
  #     1.0i
  #     ^^^^
  class ImaginaryNode < Node
    # attr_reader numeric: Node
    attr_reader :numeric

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (numeric: Node, location: Location) -> void
    def initialize(numeric, location)
      @numeric = numeric
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_imaginary_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [numeric]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { numeric: numeric, location: location }
    end
  end

  # Represents the use of the `in` keyword in a case statement.
  # 
  #     case a; in b then c end
  #             ^^^^^^^^^^^
  class InNode < Node
    # attr_reader pattern: Node
    attr_reader :pattern

    # attr_reader statements: Node?
    attr_reader :statements

    # attr_reader in_loc: Location
    attr_reader :in_loc

    # attr_reader then_loc: Location?
    attr_reader :then_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (pattern: Node, statements: Node?, in_loc: Location, then_loc: Location?, location: Location) -> void
    def initialize(pattern, statements, in_loc, then_loc, location)
      @pattern = pattern
      @statements = statements
      @in_loc = in_loc
      @then_loc = then_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_in_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [pattern, statements]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { pattern: pattern, statements: statements, in_loc: in_loc, then_loc: then_loc, location: location }
    end
  end

  # Represents referencing an instance variable.
  # 
  #     @foo
  #     ^^^^
  class InstanceVariableReadNode < Node
    # attr_reader location: Location
    attr_reader :location

    # def initialize: (location: Location) -> void
    def initialize(location)
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_instance_variable_read_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      []
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { location: location }
    end
  end

  # Represents writing to an instance variable.
  # 
  #     @foo = 1
  #     ^^^^^^^^
  class InstanceVariableWriteNode < Node
    # attr_reader name_loc: Location
    attr_reader :name_loc

    # attr_reader value: Node?
    attr_reader :value

    # attr_reader operator_loc: Location?
    attr_reader :operator_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (name_loc: Location, value: Node?, operator_loc: Location?, location: Location) -> void
    def initialize(name_loc, value, operator_loc, location)
      @name_loc = name_loc
      @value = value
      @operator_loc = operator_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_instance_variable_write_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [value]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { name_loc: name_loc, value: value, operator_loc: operator_loc, location: location }
    end
  end

  # Represents an integer number literal.
  # 
  #     1
  #     ^
  class IntegerNode < Node
    # attr_reader location: Location
    attr_reader :location

    # def initialize: (location: Location) -> void
    def initialize(location)
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_integer_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      []
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { location: location }
    end
  end

  # Represents a regular expression literal that contains interpolation.
  # 
  #     /foo #{bar} baz/
  #     ^^^^^^^^^^^^^^^^
  class InterpolatedRegularExpressionNode < Node
    # attr_reader opening: Token
    attr_reader :opening

    # attr_reader parts: Array[Node]
    attr_reader :parts

    # attr_reader closing: Token
    attr_reader :closing

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (opening: Token, parts: Array[Node], closing: Token, location: Location) -> void
    def initialize(opening, parts, closing, location)
      @opening = opening
      @parts = parts
      @closing = closing
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_interpolated_regular_expression_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [*parts]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { opening: opening, parts: parts, closing: closing, location: location }
    end
  end

  # Represents a string literal that contains interpolation.
  # 
  #     "foo #{bar} baz"
  #     ^^^^^^^^^^^^^^^^
  class InterpolatedStringNode < Node
    # attr_reader opening: Token?
    attr_reader :opening

    # attr_reader parts: Array[Node]
    attr_reader :parts

    # attr_reader closing: Token?
    attr_reader :closing

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (opening: Token?, parts: Array[Node], closing: Token?, location: Location) -> void
    def initialize(opening, parts, closing, location)
      @opening = opening
      @parts = parts
      @closing = closing
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_interpolated_string_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [*parts]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { opening: opening, parts: parts, closing: closing, location: location }
    end
  end

  # Represents a symbol literal that contains interpolation.
  # 
  #     :"foo #{bar} baz"
  #     ^^^^^^^^^^^^^^^^^
  class InterpolatedSymbolNode < Node
    # attr_reader opening: Token?
    attr_reader :opening

    # attr_reader parts: Array[Node]
    attr_reader :parts

    # attr_reader closing: Token?
    attr_reader :closing

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (opening: Token?, parts: Array[Node], closing: Token?, location: Location) -> void
    def initialize(opening, parts, closing, location)
      @opening = opening
      @parts = parts
      @closing = closing
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_interpolated_symbol_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [*parts]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { opening: opening, parts: parts, closing: closing, location: location }
    end
  end

  # Represents an xstring literal that contains interpolation.
  # 
  #     `foo #{bar} baz`
  #     ^^^^^^^^^^^^^^^^
  class InterpolatedXStringNode < Node
    # attr_reader opening: Token
    attr_reader :opening

    # attr_reader parts: Array[Node]
    attr_reader :parts

    # attr_reader closing: Token
    attr_reader :closing

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (opening: Token, parts: Array[Node], closing: Token, location: Location) -> void
    def initialize(opening, parts, closing, location)
      @opening = opening
      @parts = parts
      @closing = closing
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_interpolated_x_string_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [*parts]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { opening: opening, parts: parts, closing: closing, location: location }
    end
  end

  # Represents a keyword parameter to a method, block, or lambda definition.
  # 
  #     def a(b:)
  #           ^^
  #     end
  # 
  #     def a(b: 1)
  #           ^^^^
  #     end
  class KeywordParameterNode < Node
    # attr_reader name: Token
    attr_reader :name

    # attr_reader value: Node?
    attr_reader :value

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (name: Token, value: Node?, location: Location) -> void
    def initialize(name, value, location)
      @name = name
      @value = value
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_keyword_parameter_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [value]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { name: name, value: value, location: location }
    end
  end

  # Represents a keyword rest parameter to a method, block, or lambda definition.
  # 
  #     def a(**b)
  #           ^^^
  #     end
  class KeywordRestParameterNode < Node
    # attr_reader operator: Token
    attr_reader :operator

    # attr_reader name: Token?
    attr_reader :name

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (operator: Token, name: Token?, location: Location) -> void
    def initialize(operator, name, location)
      @operator = operator
      @name = name
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_keyword_rest_parameter_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      []
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { operator: operator, name: name, location: location }
    end
  end

  # Represents using a lambda literal (not the lambda method call).
  # 
  #     ->(value) { value * 2 }
  #     ^^^^^^^^^^^^^^^^^^^^^^^
  class LambdaNode < Node
    # attr_reader scope: Node
    attr_reader :scope

    # attr_reader opening: Token
    attr_reader :opening

    # attr_reader parameters: Node?
    attr_reader :parameters

    # attr_reader statements: Node?
    attr_reader :statements

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (scope: Node, opening: Token, parameters: Node?, statements: Node?, location: Location) -> void
    def initialize(scope, opening, parameters, statements, location)
      @scope = scope
      @opening = opening
      @parameters = parameters
      @statements = statements
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_lambda_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [scope, parameters, statements]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { scope: scope, opening: opening, parameters: parameters, statements: statements, location: location }
    end
  end

  # Represents reading a local variable. Note that this requires that a local
  # variable of the same name has already been written to in the same scope,
  # otherwise it is parsed as a method call.
  # 
  #     foo
  #     ^^^
  class LocalVariableReadNode < Node
    # attr_reader depth: Integer
    attr_reader :depth

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (depth: Integer, location: Location) -> void
    def initialize(depth, location)
      @depth = depth
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_local_variable_read_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      []
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { depth: depth, location: location }
    end
  end

  # Represents writing to a local variable.
  # 
  #     foo = 1
  #     ^^^^^^^
  class LocalVariableWriteNode < Node
    # attr_reader name_loc: Location
    attr_reader :name_loc

    # attr_reader value: Node?
    attr_reader :value

    # attr_reader operator_loc: Location?
    attr_reader :operator_loc

    # attr_reader depth: Integer
    attr_reader :depth

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (name_loc: Location, value: Node?, operator_loc: Location?, depth: Integer, location: Location) -> void
    def initialize(name_loc, value, operator_loc, depth, location)
      @name_loc = name_loc
      @value = value
      @operator_loc = operator_loc
      @depth = depth
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_local_variable_write_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [value]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { name_loc: name_loc, value: value, operator_loc: operator_loc, depth: depth, location: location }
    end
  end

  # Represents the use of the modifier `in` operator.
  # 
  #     foo in bar
  #     ^^^^^^^^^^
  class MatchPredicateNode < Node
    # attr_reader value: Node
    attr_reader :value

    # attr_reader pattern: Node
    attr_reader :pattern

    # attr_reader operator_loc: Location
    attr_reader :operator_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (value: Node, pattern: Node, operator_loc: Location, location: Location) -> void
    def initialize(value, pattern, operator_loc, location)
      @value = value
      @pattern = pattern
      @operator_loc = operator_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_match_predicate_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [value, pattern]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { value: value, pattern: pattern, operator_loc: operator_loc, location: location }
    end
  end

  # Represents the use of the `=>` operator.
  # 
  #     foo => bar
  #     ^^^^^^^^^^
  class MatchRequiredNode < Node
    # attr_reader value: Node
    attr_reader :value

    # attr_reader pattern: Node
    attr_reader :pattern

    # attr_reader operator_loc: Location
    attr_reader :operator_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (value: Node, pattern: Node, operator_loc: Location, location: Location) -> void
    def initialize(value, pattern, operator_loc, location)
      @value = value
      @pattern = pattern
      @operator_loc = operator_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_match_required_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [value, pattern]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { value: value, pattern: pattern, operator_loc: operator_loc, location: location }
    end
  end

  # Represents a node that is missing from the source and results in a syntax
  # error.
  class MissingNode < Node
    # attr_reader location: Location
    attr_reader :location

    # def initialize: (location: Location) -> void
    def initialize(location)
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_missing_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      []
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { location: location }
    end
  end

  # Represents a module declaration involving the `module` keyword.
  # 
  #     module Foo end
  #     ^^^^^^^^^^^^^^
  class ModuleNode < Node
    # attr_reader scope: Node
    attr_reader :scope

    # attr_reader module_keyword: Token
    attr_reader :module_keyword

    # attr_reader constant_path: Node
    attr_reader :constant_path

    # attr_reader statements: Node?
    attr_reader :statements

    # attr_reader end_keyword: Token
    attr_reader :end_keyword

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (scope: Node, module_keyword: Token, constant_path: Node, statements: Node?, end_keyword: Token, location: Location) -> void
    def initialize(scope, module_keyword, constant_path, statements, end_keyword, location)
      @scope = scope
      @module_keyword = module_keyword
      @constant_path = constant_path
      @statements = statements
      @end_keyword = end_keyword
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_module_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [scope, constant_path, statements]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { scope: scope, module_keyword: module_keyword, constant_path: constant_path, statements: statements, end_keyword: end_keyword, location: location }
    end
  end

  # Represents a multi-target expression.
  # 
  #     a, b, c = 1, 2, 3
  #     ^^^^^^^^^^^^^^^^^
  class MultiWriteNode < Node
    # attr_reader targets: Array[Node]
    attr_reader :targets

    # attr_reader operator: Token?
    attr_reader :operator

    # attr_reader value: Node?
    attr_reader :value

    # attr_reader lparen_loc: Location?
    attr_reader :lparen_loc

    # attr_reader rparen_loc: Location?
    attr_reader :rparen_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (targets: Array[Node], operator: Token?, value: Node?, lparen_loc: Location?, rparen_loc: Location?, location: Location) -> void
    def initialize(targets, operator, value, lparen_loc, rparen_loc, location)
      @targets = targets
      @operator = operator
      @value = value
      @lparen_loc = lparen_loc
      @rparen_loc = rparen_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_multi_write_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [*targets, value]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { targets: targets, operator: operator, value: value, lparen_loc: lparen_loc, rparen_loc: rparen_loc, location: location }
    end
  end

  # Represents the use of the `next` keyword.
  # 
  #     next 1
  #     ^^^^^^
  class NextNode < Node
    # attr_reader arguments: Node?
    attr_reader :arguments

    # attr_reader keyword_loc: Location
    attr_reader :keyword_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (arguments: Node?, keyword_loc: Location, location: Location) -> void
    def initialize(arguments, keyword_loc, location)
      @arguments = arguments
      @keyword_loc = keyword_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_next_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [arguments]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { arguments: arguments, keyword_loc: keyword_loc, location: location }
    end
  end

  # Represents the use of the `nil` keyword.
  # 
  #     nil
  #     ^^^
  class NilNode < Node
    # attr_reader location: Location
    attr_reader :location

    # def initialize: (location: Location) -> void
    def initialize(location)
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_nil_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      []
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { location: location }
    end
  end

  # Represents the use of `**nil` inside method arguments.
  # 
  #     def a(**nil)
  #           ^^^^^
  #     end
  class NoKeywordsParameterNode < Node
    # attr_reader operator_loc: Location
    attr_reader :operator_loc

    # attr_reader keyword_loc: Location
    attr_reader :keyword_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (operator_loc: Location, keyword_loc: Location, location: Location) -> void
    def initialize(operator_loc, keyword_loc, location)
      @operator_loc = operator_loc
      @keyword_loc = keyword_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_no_keywords_parameter_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      []
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { operator_loc: operator_loc, keyword_loc: keyword_loc, location: location }
    end
  end

  # Represents the use of the `&&=` operator for assignment.
  # 
  #     target &&= value
  #     ^^^^^^^^^^^^^^^^
  class OperatorAndAssignmentNode < Node
    # attr_reader target: Node
    attr_reader :target

    # attr_reader value: Node
    attr_reader :value

    # attr_reader operator_loc: Location
    attr_reader :operator_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (target: Node, value: Node, operator_loc: Location, location: Location) -> void
    def initialize(target, value, operator_loc, location)
      @target = target
      @value = value
      @operator_loc = operator_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_operator_and_assignment_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [target, value]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { target: target, value: value, operator_loc: operator_loc, location: location }
    end
  end

  # Represents assigning to a value using an operator that isn't `=`.
  # 
  #     foo += bar
  #     ^^^^^^^^^^
  class OperatorAssignmentNode < Node
    # attr_reader target: Node
    attr_reader :target

    # attr_reader operator: Token
    attr_reader :operator

    # attr_reader value: Node
    attr_reader :value

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (target: Node, operator: Token, value: Node, location: Location) -> void
    def initialize(target, operator, value, location)
      @target = target
      @operator = operator
      @value = value
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_operator_assignment_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [target, value]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { target: target, operator: operator, value: value, location: location }
    end
  end

  # Represents the use of the `||=` operator for assignment.
  # 
  #     target ||= value
  #     ^^^^^^^^^^^^^^^^
  class OperatorOrAssignmentNode < Node
    # attr_reader target: Node
    attr_reader :target

    # attr_reader value: Node
    attr_reader :value

    # attr_reader operator_loc: Location
    attr_reader :operator_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (target: Node, value: Node, operator_loc: Location, location: Location) -> void
    def initialize(target, value, operator_loc, location)
      @target = target
      @value = value
      @operator_loc = operator_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_operator_or_assignment_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [target, value]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { target: target, value: value, operator_loc: operator_loc, location: location }
    end
  end

  # Represents an optional parameter to a method, block, or lambda definition.
  # 
  #     def a(b = 1)
  #           ^^^^^
  #     end
  class OptionalParameterNode < Node
    # attr_reader name: Token
    attr_reader :name

    # attr_reader equal_operator: Token
    attr_reader :equal_operator

    # attr_reader value: Node
    attr_reader :value

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (name: Token, equal_operator: Token, value: Node, location: Location) -> void
    def initialize(name, equal_operator, value, location)
      @name = name
      @equal_operator = equal_operator
      @value = value
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_optional_parameter_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [value]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { name: name, equal_operator: equal_operator, value: value, location: location }
    end
  end

  # Represents the use of the `||` operator or the `or` keyword.
  # 
  #     left or right
  #     ^^^^^^^^^^^^^
  class OrNode < Node
    # attr_reader left: Node
    attr_reader :left

    # attr_reader right: Node
    attr_reader :right

    # attr_reader operator_loc: Location
    attr_reader :operator_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (left: Node, right: Node, operator_loc: Location, location: Location) -> void
    def initialize(left, right, operator_loc, location)
      @left = left
      @right = right
      @operator_loc = operator_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_or_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [left, right]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { left: left, right: right, operator_loc: operator_loc, location: location }
    end
  end

  # Represents the list of parameters on a method, block, or lambda definition.
  # 
  #     def a(b, c, d)
  #           ^^^^^^^
  #     end
  class ParametersNode < Node
    # attr_reader requireds: Array[Node]
    attr_reader :requireds

    # attr_reader optionals: Array[Node]
    attr_reader :optionals

    # attr_reader posts: Array[Node]
    attr_reader :posts

    # attr_reader rest: Node?
    attr_reader :rest

    # attr_reader keywords: Array[Node]
    attr_reader :keywords

    # attr_reader keyword_rest: Node?
    attr_reader :keyword_rest

    # attr_reader block: Node?
    attr_reader :block

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (requireds: Array[Node], optionals: Array[Node], posts: Array[Node], rest: Node?, keywords: Array[Node], keyword_rest: Node?, block: Node?, location: Location) -> void
    def initialize(requireds, optionals, posts, rest, keywords, keyword_rest, block, location)
      @requireds = requireds
      @optionals = optionals
      @posts = posts
      @rest = rest
      @keywords = keywords
      @keyword_rest = keyword_rest
      @block = block
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_parameters_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [*requireds, *optionals, *posts, rest, *keywords, keyword_rest, block]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { requireds: requireds, optionals: optionals, posts: posts, rest: rest, keywords: keywords, keyword_rest: keyword_rest, block: block, location: location }
    end
  end

  # Represents a parentesized expression
  # 
  #     (10 + 34)
  #     ^^^^^^^^^
  class ParenthesesNode < Node
    # attr_reader statements: Node?
    attr_reader :statements

    # attr_reader opening_loc: Location
    attr_reader :opening_loc

    # attr_reader closing_loc: Location
    attr_reader :closing_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (statements: Node?, opening_loc: Location, closing_loc: Location, location: Location) -> void
    def initialize(statements, opening_loc, closing_loc, location)
      @statements = statements
      @opening_loc = opening_loc
      @closing_loc = closing_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_parentheses_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [statements]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { statements: statements, opening_loc: opening_loc, closing_loc: closing_loc, location: location }
    end
  end

  # Represents the use of the `^` operator for pinning an expression in a
  # pattern matching expression.
  # 
  #     foo in ^(bar)
  #            ^^^^^^
  class PinnedExpressionNode < Node
    # attr_reader expression: Node
    attr_reader :expression

    # attr_reader operator_loc: Location
    attr_reader :operator_loc

    # attr_reader lparen_loc: Location
    attr_reader :lparen_loc

    # attr_reader rparen_loc: Location
    attr_reader :rparen_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (expression: Node, operator_loc: Location, lparen_loc: Location, rparen_loc: Location, location: Location) -> void
    def initialize(expression, operator_loc, lparen_loc, rparen_loc, location)
      @expression = expression
      @operator_loc = operator_loc
      @lparen_loc = lparen_loc
      @rparen_loc = rparen_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_pinned_expression_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [expression]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { expression: expression, operator_loc: operator_loc, lparen_loc: lparen_loc, rparen_loc: rparen_loc, location: location }
    end
  end

  # Represents the use of the `^` operator for pinning a variable in a pattern
  # matching expression.
  # 
  #     foo in ^bar
  #            ^^^^
  class PinnedVariableNode < Node
    # attr_reader variable: Node
    attr_reader :variable

    # attr_reader operator_loc: Location
    attr_reader :operator_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (variable: Node, operator_loc: Location, location: Location) -> void
    def initialize(variable, operator_loc, location)
      @variable = variable
      @operator_loc = operator_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_pinned_variable_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [variable]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { variable: variable, operator_loc: operator_loc, location: location }
    end
  end

  # Represents the use of the `END` keyword.
  # 
  #     END { foo }
  #     ^^^^^^^^^^^
  class PostExecutionNode < Node
    # attr_reader statements: Node
    attr_reader :statements

    # attr_reader keyword_loc: Location
    attr_reader :keyword_loc

    # attr_reader opening_loc: Location
    attr_reader :opening_loc

    # attr_reader closing_loc: Location
    attr_reader :closing_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (statements: Node, keyword_loc: Location, opening_loc: Location, closing_loc: Location, location: Location) -> void
    def initialize(statements, keyword_loc, opening_loc, closing_loc, location)
      @statements = statements
      @keyword_loc = keyword_loc
      @opening_loc = opening_loc
      @closing_loc = closing_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_post_execution_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [statements]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { statements: statements, keyword_loc: keyword_loc, opening_loc: opening_loc, closing_loc: closing_loc, location: location }
    end
  end

  # Represents the use of the `BEGIN` keyword.
  # 
  #     BEGIN { foo }
  #     ^^^^^^^^^^^^^
  class PreExecutionNode < Node
    # attr_reader statements: Node
    attr_reader :statements

    # attr_reader keyword_loc: Location
    attr_reader :keyword_loc

    # attr_reader opening_loc: Location
    attr_reader :opening_loc

    # attr_reader closing_loc: Location
    attr_reader :closing_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (statements: Node, keyword_loc: Location, opening_loc: Location, closing_loc: Location, location: Location) -> void
    def initialize(statements, keyword_loc, opening_loc, closing_loc, location)
      @statements = statements
      @keyword_loc = keyword_loc
      @opening_loc = opening_loc
      @closing_loc = closing_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_pre_execution_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [statements]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { statements: statements, keyword_loc: keyword_loc, opening_loc: opening_loc, closing_loc: closing_loc, location: location }
    end
  end

  # The top level node of any parse tree.
  class ProgramNode < Node
    # attr_reader scope: Node
    attr_reader :scope

    # attr_reader statements: Node
    attr_reader :statements

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (scope: Node, statements: Node, location: Location) -> void
    def initialize(scope, statements, location)
      @scope = scope
      @statements = statements
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_program_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [scope, statements]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { scope: scope, statements: statements, location: location }
    end
  end

  # Represents the use of the `..` or `...` operators.
  # 
  #     1..2
  #     ^^^^
  # 
  #     c if a =~ /left/ ... b =~ /right/
  #          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  class RangeNode < Node
    # attr_reader left: Node?
    attr_reader :left

    # attr_reader right: Node?
    attr_reader :right

    # attr_reader operator_loc: Location
    attr_reader :operator_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (left: Node?, right: Node?, operator_loc: Location, location: Location) -> void
    def initialize(left, right, operator_loc, location)
      @left = left
      @right = right
      @operator_loc = operator_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_range_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [left, right]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { left: left, right: right, operator_loc: operator_loc, location: location }
    end
  end

  # Represents a rational number literal.
  # 
  #     1.0r
  #     ^^^^
  class RationalNode < Node
    # attr_reader numeric: Node
    attr_reader :numeric

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (numeric: Node, location: Location) -> void
    def initialize(numeric, location)
      @numeric = numeric
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_rational_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [numeric]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { numeric: numeric, location: location }
    end
  end

  # Represents the use of the `redo` keyword.
  # 
  #     redo
  #     ^^^^
  class RedoNode < Node
    # attr_reader location: Location
    attr_reader :location

    # def initialize: (location: Location) -> void
    def initialize(location)
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_redo_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      []
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { location: location }
    end
  end

  # Represents a regular expression literal with no interpolation.
  # 
  #     /foo/i
  #     ^^^^^^
  class RegularExpressionNode < Node
    # attr_reader opening: Token
    attr_reader :opening

    # attr_reader content: Token
    attr_reader :content

    # attr_reader closing: Token
    attr_reader :closing

    # attr_reader unescaped: String
    attr_reader :unescaped

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (opening: Token, content: Token, closing: Token, unescaped: String, location: Location) -> void
    def initialize(opening, content, closing, unescaped, location)
      @opening = opening
      @content = content
      @closing = closing
      @unescaped = unescaped
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_regular_expression_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      []
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { opening: opening, content: content, closing: closing, unescaped: unescaped, location: location }
    end
  end

  # Represents a destructured required parameter node.
  # 
  #     def foo((bar, baz))
  #             ^^^^^^^^^^
  #     end
  class RequiredDestructuredParameterNode < Node
    # attr_reader parameters: Array[Node]
    attr_reader :parameters

    # attr_reader opening: Token
    attr_reader :opening

    # attr_reader closing: Token
    attr_reader :closing

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (parameters: Array[Node], opening: Token, closing: Token, location: Location) -> void
    def initialize(parameters, opening, closing, location)
      @parameters = parameters
      @opening = opening
      @closing = closing
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_required_destructured_parameter_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [*parameters]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { parameters: parameters, opening: opening, closing: closing, location: location }
    end
  end

  # Represents a required parameter to a method, block, or lambda definition.
  # 
  #     def a(b)
  #           ^
  #     end
  class RequiredParameterNode < Node
    # attr_reader location: Location
    attr_reader :location

    # def initialize: (location: Location) -> void
    def initialize(location)
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_required_parameter_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      []
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { location: location }
    end
  end

  # Represents an expression modified with a rescue.
  # 
  #   foo rescue nil
  #   ^^^^^^^^^^^^^^
  class RescueModifierNode < Node
    # attr_reader expression: Node
    attr_reader :expression

    # attr_reader rescue_keyword: Token
    attr_reader :rescue_keyword

    # attr_reader rescue_expression: Node
    attr_reader :rescue_expression

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (expression: Node, rescue_keyword: Token, rescue_expression: Node, location: Location) -> void
    def initialize(expression, rescue_keyword, rescue_expression, location)
      @expression = expression
      @rescue_keyword = rescue_keyword
      @rescue_expression = rescue_expression
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_rescue_modifier_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [expression, rescue_expression]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { expression: expression, rescue_keyword: rescue_keyword, rescue_expression: rescue_expression, location: location }
    end
  end

  # Represents a rescue statement.
  # 
  #     begin
  #     rescue
  #       foo
  #     ^^^^^^
  #     end
  class RescueNode < Node
    # attr_reader rescue_keyword: Token
    attr_reader :rescue_keyword

    # attr_reader exceptions: Array[Node]
    attr_reader :exceptions

    # attr_reader equal_greater: Token?
    attr_reader :equal_greater

    # attr_reader exception: Node?
    attr_reader :exception

    # attr_reader statements: Node?
    attr_reader :statements

    # attr_reader consequent: Node?
    attr_reader :consequent

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (rescue_keyword: Token, exceptions: Array[Node], equal_greater: Token?, exception: Node?, statements: Node?, consequent: Node?, location: Location) -> void
    def initialize(rescue_keyword, exceptions, equal_greater, exception, statements, consequent, location)
      @rescue_keyword = rescue_keyword
      @exceptions = exceptions
      @equal_greater = equal_greater
      @exception = exception
      @statements = statements
      @consequent = consequent
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_rescue_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [*exceptions, exception, statements, consequent]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { rescue_keyword: rescue_keyword, exceptions: exceptions, equal_greater: equal_greater, exception: exception, statements: statements, consequent: consequent, location: location }
    end
  end

  # Represents a rest parameter to a method, block, or lambda definition.
  # 
  #     def a(*b)
  #           ^^
  #     end
  class RestParameterNode < Node
    # attr_reader operator: Token
    attr_reader :operator

    # attr_reader name: Token?
    attr_reader :name

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (operator: Token, name: Token?, location: Location) -> void
    def initialize(operator, name, location)
      @operator = operator
      @name = name
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_rest_parameter_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      []
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { operator: operator, name: name, location: location }
    end
  end

  # Represents the use of the `retry` keyword.
  # 
  #     retry
  #     ^^^^^
  class RetryNode < Node
    # attr_reader location: Location
    attr_reader :location

    # def initialize: (location: Location) -> void
    def initialize(location)
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_retry_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      []
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { location: location }
    end
  end

  # Represents the use of the `return` keyword.
  # 
  #     return 1
  #     ^^^^^^^^
  class ReturnNode < Node
    # attr_reader keyword: Token
    attr_reader :keyword

    # attr_reader arguments: Node?
    attr_reader :arguments

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (keyword: Token, arguments: Node?, location: Location) -> void
    def initialize(keyword, arguments, location)
      @keyword = keyword
      @arguments = arguments
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_return_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [arguments]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { keyword: keyword, arguments: arguments, location: location }
    end
  end

  # Represents the local variables within a given lexical scope. These are
  # attached to nodes where a new scope is created.
  class ScopeNode < Node
    # attr_reader locals: Array[Token]
    attr_reader :locals

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (locals: Array[Token], location: Location) -> void
    def initialize(locals, location)
      @locals = locals
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_scope_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      []
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { locals: locals, location: location }
    end
  end

  # Represents the `self` keyword.
  # 
  #     self
  #     ^^^^
  class SelfNode < Node
    # attr_reader location: Location
    attr_reader :location

    # def initialize: (location: Location) -> void
    def initialize(location)
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_self_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      []
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { location: location }
    end
  end

  # Represents a singleton class declaration involving the `class` keyword.
  # 
  #     class << self end
  #     ^^^^^^^^^^^^^^^^^
  class SingletonClassNode < Node
    # attr_reader scope: Node
    attr_reader :scope

    # attr_reader class_keyword: Token
    attr_reader :class_keyword

    # attr_reader operator: Token
    attr_reader :operator

    # attr_reader expression: Node
    attr_reader :expression

    # attr_reader statements: Node?
    attr_reader :statements

    # attr_reader end_keyword: Token
    attr_reader :end_keyword

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (scope: Node, class_keyword: Token, operator: Token, expression: Node, statements: Node?, end_keyword: Token, location: Location) -> void
    def initialize(scope, class_keyword, operator, expression, statements, end_keyword, location)
      @scope = scope
      @class_keyword = class_keyword
      @operator = operator
      @expression = expression
      @statements = statements
      @end_keyword = end_keyword
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_singleton_class_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [scope, expression, statements]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { scope: scope, class_keyword: class_keyword, operator: operator, expression: expression, statements: statements, end_keyword: end_keyword, location: location }
    end
  end

  # Represents the use of the `__ENCODING__` keyword.
  # 
  #     __ENCODING__
  #     ^^^^^^^^^^^^
  class SourceEncodingNode < Node
    # attr_reader location: Location
    attr_reader :location

    # def initialize: (location: Location) -> void
    def initialize(location)
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_source_encoding_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      []
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { location: location }
    end
  end

  # Represents the use of the `__FILE__` keyword.
  # 
  #     __FILE__
  #     ^^^^^^^^
  class SourceFileNode < Node
    # attr_reader filepath: String
    attr_reader :filepath

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (filepath: String, location: Location) -> void
    def initialize(filepath, location)
      @filepath = filepath
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_source_file_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      []
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { filepath: filepath, location: location }
    end
  end

  # Represents the use of the `__LINE__` keyword.
  # 
  #     __LINE__
  #     ^^^^^^^^
  class SourceLineNode < Node
    # attr_reader location: Location
    attr_reader :location

    # def initialize: (location: Location) -> void
    def initialize(location)
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_source_line_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      []
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { location: location }
    end
  end

  # Represents the use of the splat operator.
  # 
  #     [*a]
  #      ^^
  class SplatNode < Node
    # attr_reader operator: Token
    attr_reader :operator

    # attr_reader expression: Node?
    attr_reader :expression

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (operator: Token, expression: Node?, location: Location) -> void
    def initialize(operator, expression, location)
      @operator = operator
      @expression = expression
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_splat_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [expression]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { operator: operator, expression: expression, location: location }
    end
  end

  # Represents a set of statements contained within some scope.
  # 
  #     foo; bar; baz
  #     ^^^^^^^^^^^^^
  class StatementsNode < Node
    # attr_reader body: Array[Node]
    attr_reader :body

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (body: Array[Node], location: Location) -> void
    def initialize(body, location)
      @body = body
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_statements_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [*body]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { body: body, location: location }
    end
  end

  # Represents the use of compile-time string concatenation.
  # 
  #     "foo" "bar"
  #     ^^^^^^^^^^^
  class StringConcatNode < Node
    # attr_reader left: Node
    attr_reader :left

    # attr_reader right: Node
    attr_reader :right

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (left: Node, right: Node, location: Location) -> void
    def initialize(left, right, location)
      @left = left
      @right = right
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_string_concat_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [left, right]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { left: left, right: right, location: location }
    end
  end

  # Represents an interpolated set of statements within a string.
  # 
  #     "foo #{bar}"
  #          ^^^^^^
  class StringInterpolatedNode < Node
    # attr_reader opening: Token
    attr_reader :opening

    # attr_reader statements: Node?
    attr_reader :statements

    # attr_reader closing: Token
    attr_reader :closing

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (opening: Token, statements: Node?, closing: Token, location: Location) -> void
    def initialize(opening, statements, closing, location)
      @opening = opening
      @statements = statements
      @closing = closing
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_string_interpolated_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [statements]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { opening: opening, statements: statements, closing: closing, location: location }
    end
  end

  # Represents a string literal, a string contained within a `%w` list, or
  # plain string content within an interpolated string.
  # 
  #     "foo"
  #     ^^^^^
  # 
  #     %w[foo]
  #        ^^^
  # 
  #     "foo #{bar} baz"
  #      ^^^^      ^^^^
  class StringNode < Node
    # attr_reader opening: Token?
    attr_reader :opening

    # attr_reader content: Token
    attr_reader :content

    # attr_reader closing: Token?
    attr_reader :closing

    # attr_reader unescaped: String
    attr_reader :unescaped

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (opening: Token?, content: Token, closing: Token?, unescaped: String, location: Location) -> void
    def initialize(opening, content, closing, unescaped, location)
      @opening = opening
      @content = content
      @closing = closing
      @unescaped = unescaped
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_string_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      []
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { opening: opening, content: content, closing: closing, unescaped: unescaped, location: location }
    end
  end

  # Represents the use of the `super` keyword with parentheses or arguments.
  # 
  #     super()
  #     ^^^^^^^
  # 
  #     super foo, bar
  #     ^^^^^^^^^^^^^^
  class SuperNode < Node
    # attr_reader keyword: Token
    attr_reader :keyword

    # attr_reader lparen: Token?
    attr_reader :lparen

    # attr_reader arguments: Node?
    attr_reader :arguments

    # attr_reader rparen: Token?
    attr_reader :rparen

    # attr_reader block: Node?
    attr_reader :block

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (keyword: Token, lparen: Token?, arguments: Node?, rparen: Token?, block: Node?, location: Location) -> void
    def initialize(keyword, lparen, arguments, rparen, block, location)
      @keyword = keyword
      @lparen = lparen
      @arguments = arguments
      @rparen = rparen
      @block = block
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_super_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [arguments, block]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { keyword: keyword, lparen: lparen, arguments: arguments, rparen: rparen, block: block, location: location }
    end
  end

  # Represents a symbol literal or a symbol contained within a `%i` list.
  # 
  #     :foo
  #     ^^^^
  # 
  #     %i[foo]
  #        ^^^
  class SymbolNode < Node
    # attr_reader opening: Token?
    attr_reader :opening

    # attr_reader value: Token
    attr_reader :value

    # attr_reader closing: Token?
    attr_reader :closing

    # attr_reader unescaped: String
    attr_reader :unescaped

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (opening: Token?, value: Token, closing: Token?, unescaped: String, location: Location) -> void
    def initialize(opening, value, closing, unescaped, location)
      @opening = opening
      @value = value
      @closing = closing
      @unescaped = unescaped
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_symbol_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      []
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { opening: opening, value: value, closing: closing, unescaped: unescaped, location: location }
    end
  end

  # Represents the use of the literal `true` keyword.
  # 
  #     true
  #     ^^^^
  class TrueNode < Node
    # attr_reader location: Location
    attr_reader :location

    # def initialize: (location: Location) -> void
    def initialize(location)
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_true_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      []
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { location: location }
    end
  end

  # Represents the use of the `undef` keyword.
  # 
  #     undef :foo, :bar, :baz
  #     ^^^^^^^^^^^^^^^^^^^^^^
  class UndefNode < Node
    # attr_reader names: Array[Node]
    attr_reader :names

    # attr_reader keyword_loc: Location
    attr_reader :keyword_loc

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (names: Array[Node], keyword_loc: Location, location: Location) -> void
    def initialize(names, keyword_loc, location)
      @names = names
      @keyword_loc = keyword_loc
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_undef_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [*names]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { names: names, keyword_loc: keyword_loc, location: location }
    end
  end

  # Represents the use of the `unless` keyword, either in the block form or the modifier form.
  # 
  #     bar unless foo
  #     ^^^^^^^^^^^^^^
  # 
  #     unless foo then bar end
  #     ^^^^^^^^^^^^^^^^^^^^^^^
  class UnlessNode < Node
    # attr_reader keyword: Token
    attr_reader :keyword

    # attr_reader predicate: Node
    attr_reader :predicate

    # attr_reader statements: Node?
    attr_reader :statements

    # attr_reader consequent: Node?
    attr_reader :consequent

    # attr_reader end_keyword: Token?
    attr_reader :end_keyword

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (keyword: Token, predicate: Node, statements: Node?, consequent: Node?, end_keyword: Token?, location: Location) -> void
    def initialize(keyword, predicate, statements, consequent, end_keyword, location)
      @keyword = keyword
      @predicate = predicate
      @statements = statements
      @consequent = consequent
      @end_keyword = end_keyword
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_unless_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [predicate, statements, consequent]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { keyword: keyword, predicate: predicate, statements: statements, consequent: consequent, end_keyword: end_keyword, location: location }
    end
  end

  # Represents the use of the `until` keyword, either in the block form or the modifier form.
  # 
  #     bar until foo
  #     ^^^^^^^^^^^^^
  # 
  #     until foo do bar end
  #     ^^^^^^^^^^^^^^^^^^^^
  class UntilNode < Node
    # attr_reader keyword: Token
    attr_reader :keyword

    # attr_reader predicate: Node
    attr_reader :predicate

    # attr_reader statements: Node?
    attr_reader :statements

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (keyword: Token, predicate: Node, statements: Node?, location: Location) -> void
    def initialize(keyword, predicate, statements, location)
      @keyword = keyword
      @predicate = predicate
      @statements = statements
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_until_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [predicate, statements]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { keyword: keyword, predicate: predicate, statements: statements, location: location }
    end
  end

  # case true
  # when true
  # ^^^^^^^^^
  # end
  class WhenNode < Node
    # attr_reader when_keyword: Token
    attr_reader :when_keyword

    # attr_reader conditions: Array[Node]
    attr_reader :conditions

    # attr_reader statements: Node?
    attr_reader :statements

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (when_keyword: Token, conditions: Array[Node], statements: Node?, location: Location) -> void
    def initialize(when_keyword, conditions, statements, location)
      @when_keyword = when_keyword
      @conditions = conditions
      @statements = statements
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_when_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [*conditions, statements]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { when_keyword: when_keyword, conditions: conditions, statements: statements, location: location }
    end
  end

  # Represents the use of the `while` keyword, either in the block form or the modifier form.
  # 
  #     bar while foo
  #     ^^^^^^^^^^^^^
  # 
  #     while foo do bar end
  #     ^^^^^^^^^^^^^^^^^^^^
  class WhileNode < Node
    # attr_reader keyword: Token
    attr_reader :keyword

    # attr_reader predicate: Node
    attr_reader :predicate

    # attr_reader statements: Node?
    attr_reader :statements

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (keyword: Token, predicate: Node, statements: Node?, location: Location) -> void
    def initialize(keyword, predicate, statements, location)
      @keyword = keyword
      @predicate = predicate
      @statements = statements
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_while_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [predicate, statements]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { keyword: keyword, predicate: predicate, statements: statements, location: location }
    end
  end

  # Represents an xstring literal with no interpolation.
  # 
  #     `foo`
  #     ^^^^^
  class XStringNode < Node
    # attr_reader opening: Token
    attr_reader :opening

    # attr_reader content: Token
    attr_reader :content

    # attr_reader closing: Token
    attr_reader :closing

    # attr_reader unescaped: String
    attr_reader :unescaped

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (opening: Token, content: Token, closing: Token, unescaped: String, location: Location) -> void
    def initialize(opening, content, closing, unescaped, location)
      @opening = opening
      @content = content
      @closing = closing
      @unescaped = unescaped
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_x_string_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      []
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { opening: opening, content: content, closing: closing, unescaped: unescaped, location: location }
    end
  end

  # Represents the use of the `yield` keyword.
  # 
  #     yield 1
  #     ^^^^^^^
  class YieldNode < Node
    # attr_reader keyword: Token
    attr_reader :keyword

    # attr_reader lparen: Token?
    attr_reader :lparen

    # attr_reader arguments: Node?
    attr_reader :arguments

    # attr_reader rparen: Token?
    attr_reader :rparen

    # attr_reader location: Location
    attr_reader :location

    # def initialize: (keyword: Token, lparen: Token?, arguments: Node?, rparen: Token?, location: Location) -> void
    def initialize(keyword, lparen, arguments, rparen, location)
      @keyword = keyword
      @lparen = lparen
      @arguments = arguments
      @rparen = rparen
      @location = location
    end

    # def accept: (visitor: Visitor) -> void
    def accept(visitor)
      visitor.visit_yield_node(self)
    end

    # def child_nodes: () -> Array[nil | Node]
    def child_nodes
      [arguments]
    end

    # def deconstruct: () -> Array[nil | Node]
    alias deconstruct child_nodes

    # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
    def deconstruct_keys(keys)
      { keyword: keyword, lparen: lparen, arguments: arguments, rparen: rparen, location: location }
    end
  end

  class Visitor < BasicVisitor
    # Visit a AliasNode node
    alias visit_alias_node visit_child_nodes

    # Visit a AlternationPatternNode node
    alias visit_alternation_pattern_node visit_child_nodes

    # Visit a AndNode node
    alias visit_and_node visit_child_nodes

    # Visit a ArgumentsNode node
    alias visit_arguments_node visit_child_nodes

    # Visit a ArrayNode node
    alias visit_array_node visit_child_nodes

    # Visit a ArrayPatternNode node
    alias visit_array_pattern_node visit_child_nodes

    # Visit a AssocNode node
    alias visit_assoc_node visit_child_nodes

    # Visit a AssocSplatNode node
    alias visit_assoc_splat_node visit_child_nodes

    # Visit a BeginNode node
    alias visit_begin_node visit_child_nodes

    # Visit a BlockArgumentNode node
    alias visit_block_argument_node visit_child_nodes

    # Visit a BlockNode node
    alias visit_block_node visit_child_nodes

    # Visit a BlockParameterNode node
    alias visit_block_parameter_node visit_child_nodes

    # Visit a BlockParametersNode node
    alias visit_block_parameters_node visit_child_nodes

    # Visit a BreakNode node
    alias visit_break_node visit_child_nodes

    # Visit a CallNode node
    alias visit_call_node visit_child_nodes

    # Visit a CapturePatternNode node
    alias visit_capture_pattern_node visit_child_nodes

    # Visit a CaseNode node
    alias visit_case_node visit_child_nodes

    # Visit a ClassNode node
    alias visit_class_node visit_child_nodes

    # Visit a ClassVariableReadNode node
    alias visit_class_variable_read_node visit_child_nodes

    # Visit a ClassVariableWriteNode node
    alias visit_class_variable_write_node visit_child_nodes

    # Visit a ConstantPathNode node
    alias visit_constant_path_node visit_child_nodes

    # Visit a ConstantPathWriteNode node
    alias visit_constant_path_write_node visit_child_nodes

    # Visit a ConstantReadNode node
    alias visit_constant_read_node visit_child_nodes

    # Visit a DefNode node
    alias visit_def_node visit_child_nodes

    # Visit a DefinedNode node
    alias visit_defined_node visit_child_nodes

    # Visit a ElseNode node
    alias visit_else_node visit_child_nodes

    # Visit a EnsureNode node
    alias visit_ensure_node visit_child_nodes

    # Visit a FalseNode node
    alias visit_false_node visit_child_nodes

    # Visit a FindPatternNode node
    alias visit_find_pattern_node visit_child_nodes

    # Visit a FloatNode node
    alias visit_float_node visit_child_nodes

    # Visit a ForNode node
    alias visit_for_node visit_child_nodes

    # Visit a ForwardingArgumentsNode node
    alias visit_forwarding_arguments_node visit_child_nodes

    # Visit a ForwardingParameterNode node
    alias visit_forwarding_parameter_node visit_child_nodes

    # Visit a ForwardingSuperNode node
    alias visit_forwarding_super_node visit_child_nodes

    # Visit a GlobalVariableReadNode node
    alias visit_global_variable_read_node visit_child_nodes

    # Visit a GlobalVariableWriteNode node
    alias visit_global_variable_write_node visit_child_nodes

    # Visit a HashNode node
    alias visit_hash_node visit_child_nodes

    # Visit a HashPatternNode node
    alias visit_hash_pattern_node visit_child_nodes

    # Visit a IfNode node
    alias visit_if_node visit_child_nodes

    # Visit a ImaginaryNode node
    alias visit_imaginary_node visit_child_nodes

    # Visit a InNode node
    alias visit_in_node visit_child_nodes

    # Visit a InstanceVariableReadNode node
    alias visit_instance_variable_read_node visit_child_nodes

    # Visit a InstanceVariableWriteNode node
    alias visit_instance_variable_write_node visit_child_nodes

    # Visit a IntegerNode node
    alias visit_integer_node visit_child_nodes

    # Visit a InterpolatedRegularExpressionNode node
    alias visit_interpolated_regular_expression_node visit_child_nodes

    # Visit a InterpolatedStringNode node
    alias visit_interpolated_string_node visit_child_nodes

    # Visit a InterpolatedSymbolNode node
    alias visit_interpolated_symbol_node visit_child_nodes

    # Visit a InterpolatedXStringNode node
    alias visit_interpolated_x_string_node visit_child_nodes

    # Visit a KeywordParameterNode node
    alias visit_keyword_parameter_node visit_child_nodes

    # Visit a KeywordRestParameterNode node
    alias visit_keyword_rest_parameter_node visit_child_nodes

    # Visit a LambdaNode node
    alias visit_lambda_node visit_child_nodes

    # Visit a LocalVariableReadNode node
    alias visit_local_variable_read_node visit_child_nodes

    # Visit a LocalVariableWriteNode node
    alias visit_local_variable_write_node visit_child_nodes

    # Visit a MatchPredicateNode node
    alias visit_match_predicate_node visit_child_nodes

    # Visit a MatchRequiredNode node
    alias visit_match_required_node visit_child_nodes

    # Visit a MissingNode node
    alias visit_missing_node visit_child_nodes

    # Visit a ModuleNode node
    alias visit_module_node visit_child_nodes

    # Visit a MultiWriteNode node
    alias visit_multi_write_node visit_child_nodes

    # Visit a NextNode node
    alias visit_next_node visit_child_nodes

    # Visit a NilNode node
    alias visit_nil_node visit_child_nodes

    # Visit a NoKeywordsParameterNode node
    alias visit_no_keywords_parameter_node visit_child_nodes

    # Visit a OperatorAndAssignmentNode node
    alias visit_operator_and_assignment_node visit_child_nodes

    # Visit a OperatorAssignmentNode node
    alias visit_operator_assignment_node visit_child_nodes

    # Visit a OperatorOrAssignmentNode node
    alias visit_operator_or_assignment_node visit_child_nodes

    # Visit a OptionalParameterNode node
    alias visit_optional_parameter_node visit_child_nodes

    # Visit a OrNode node
    alias visit_or_node visit_child_nodes

    # Visit a ParametersNode node
    alias visit_parameters_node visit_child_nodes

    # Visit a ParenthesesNode node
    alias visit_parentheses_node visit_child_nodes

    # Visit a PinnedExpressionNode node
    alias visit_pinned_expression_node visit_child_nodes

    # Visit a PinnedVariableNode node
    alias visit_pinned_variable_node visit_child_nodes

    # Visit a PostExecutionNode node
    alias visit_post_execution_node visit_child_nodes

    # Visit a PreExecutionNode node
    alias visit_pre_execution_node visit_child_nodes

    # Visit a ProgramNode node
    alias visit_program_node visit_child_nodes

    # Visit a RangeNode node
    alias visit_range_node visit_child_nodes

    # Visit a RationalNode node
    alias visit_rational_node visit_child_nodes

    # Visit a RedoNode node
    alias visit_redo_node visit_child_nodes

    # Visit a RegularExpressionNode node
    alias visit_regular_expression_node visit_child_nodes

    # Visit a RequiredDestructuredParameterNode node
    alias visit_required_destructured_parameter_node visit_child_nodes

    # Visit a RequiredParameterNode node
    alias visit_required_parameter_node visit_child_nodes

    # Visit a RescueModifierNode node
    alias visit_rescue_modifier_node visit_child_nodes

    # Visit a RescueNode node
    alias visit_rescue_node visit_child_nodes

    # Visit a RestParameterNode node
    alias visit_rest_parameter_node visit_child_nodes

    # Visit a RetryNode node
    alias visit_retry_node visit_child_nodes

    # Visit a ReturnNode node
    alias visit_return_node visit_child_nodes

    # Visit a ScopeNode node
    alias visit_scope_node visit_child_nodes

    # Visit a SelfNode node
    alias visit_self_node visit_child_nodes

    # Visit a SingletonClassNode node
    alias visit_singleton_class_node visit_child_nodes

    # Visit a SourceEncodingNode node
    alias visit_source_encoding_node visit_child_nodes

    # Visit a SourceFileNode node
    alias visit_source_file_node visit_child_nodes

    # Visit a SourceLineNode node
    alias visit_source_line_node visit_child_nodes

    # Visit a SplatNode node
    alias visit_splat_node visit_child_nodes

    # Visit a StatementsNode node
    alias visit_statements_node visit_child_nodes

    # Visit a StringConcatNode node
    alias visit_string_concat_node visit_child_nodes

    # Visit a StringInterpolatedNode node
    alias visit_string_interpolated_node visit_child_nodes

    # Visit a StringNode node
    alias visit_string_node visit_child_nodes

    # Visit a SuperNode node
    alias visit_super_node visit_child_nodes

    # Visit a SymbolNode node
    alias visit_symbol_node visit_child_nodes

    # Visit a TrueNode node
    alias visit_true_node visit_child_nodes

    # Visit a UndefNode node
    alias visit_undef_node visit_child_nodes

    # Visit a UnlessNode node
    alias visit_unless_node visit_child_nodes

    # Visit a UntilNode node
    alias visit_until_node visit_child_nodes

    # Visit a WhenNode node
    alias visit_when_node visit_child_nodes

    # Visit a WhileNode node
    alias visit_while_node visit_child_nodes

    # Visit a XStringNode node
    alias visit_x_string_node visit_child_nodes

    # Visit a YieldNode node
    alias visit_yield_node visit_child_nodes
  end

  module DSL
    private

    # Create a new Location object
    def Location(start_offset = 0, end_offset = 0)
      Location.new(start_offset, end_offset)
    end

    # Create a new AliasNode node
    def AliasNode(new_name, old_name, keyword_loc)
      AliasNode.new(new_name, old_name, keyword_loc, Location.null)
    end

    # Create a new AlternationPatternNode node
    def AlternationPatternNode(left, right, operator_loc)
      AlternationPatternNode.new(left, right, operator_loc, Location.null)
    end

    # Create a new AndNode node
    def AndNode(left, right, operator)
      AndNode.new(left, right, operator, Location.null)
    end

    # Create a new ArgumentsNode node
    def ArgumentsNode(arguments)
      ArgumentsNode.new(arguments, Location.null)
    end

    # Create a new ArrayNode node
    def ArrayNode(elements, opening, closing)
      ArrayNode.new(elements, opening, closing, Location.null)
    end

    # Create a new ArrayPatternNode node
    def ArrayPatternNode(constant, requireds, rest, posts, opening_loc, closing_loc)
      ArrayPatternNode.new(constant, requireds, rest, posts, opening_loc, closing_loc, Location.null)
    end

    # Create a new AssocNode node
    def AssocNode(key, value, operator)
      AssocNode.new(key, value, operator, Location.null)
    end

    # Create a new AssocSplatNode node
    def AssocSplatNode(value, operator_loc)
      AssocSplatNode.new(value, operator_loc, Location.null)
    end

    # Create a new BeginNode node
    def BeginNode(begin_keyword, statements, rescue_clause, else_clause, ensure_clause, end_keyword)
      BeginNode.new(begin_keyword, statements, rescue_clause, else_clause, ensure_clause, end_keyword, Location.null)
    end

    # Create a new BlockArgumentNode node
    def BlockArgumentNode(expression, operator_loc)
      BlockArgumentNode.new(expression, operator_loc, Location.null)
    end

    # Create a new BlockNode node
    def BlockNode(scope, parameters, statements, opening_loc, closing_loc)
      BlockNode.new(scope, parameters, statements, opening_loc, closing_loc, Location.null)
    end

    # Create a new BlockParameterNode node
    def BlockParameterNode(name, operator_loc)
      BlockParameterNode.new(name, operator_loc, Location.null)
    end

    # Create a new BlockParametersNode node
    def BlockParametersNode(parameters, locals, opening_loc, closing_loc)
      BlockParametersNode.new(parameters, locals, opening_loc, closing_loc, Location.null)
    end

    # Create a new BreakNode node
    def BreakNode(arguments, keyword_loc)
      BreakNode.new(arguments, keyword_loc, Location.null)
    end

    # Create a new CallNode node
    def CallNode(receiver, call_operator, message, opening, arguments, closing, block, name)
      CallNode.new(receiver, call_operator, message, opening, arguments, closing, block, name, Location.null)
    end

    # Create a new CapturePatternNode node
    def CapturePatternNode(value, target, operator_loc)
      CapturePatternNode.new(value, target, operator_loc, Location.null)
    end

    # Create a new CaseNode node
    def CaseNode(predicate, conditions, consequent, case_keyword_loc, end_keyword_loc)
      CaseNode.new(predicate, conditions, consequent, case_keyword_loc, end_keyword_loc, Location.null)
    end

    # Create a new ClassNode node
    def ClassNode(scope, class_keyword, constant_path, inheritance_operator, superclass, statements, end_keyword)
      ClassNode.new(scope, class_keyword, constant_path, inheritance_operator, superclass, statements, end_keyword, Location.null)
    end

    # Create a new ClassVariableReadNode node
    def ClassVariableReadNode()
      ClassVariableReadNode.new(Location.null)
    end

    # Create a new ClassVariableWriteNode node
    def ClassVariableWriteNode(name_loc, value, operator_loc)
      ClassVariableWriteNode.new(name_loc, value, operator_loc, Location.null)
    end

    # Create a new ConstantPathNode node
    def ConstantPathNode(parent, child, delimiter_loc)
      ConstantPathNode.new(parent, child, delimiter_loc, Location.null)
    end

    # Create a new ConstantPathWriteNode node
    def ConstantPathWriteNode(target, operator, value)
      ConstantPathWriteNode.new(target, operator, value, Location.null)
    end

    # Create a new ConstantReadNode node
    def ConstantReadNode()
      ConstantReadNode.new(Location.null)
    end

    # Create a new DefNode node
    def DefNode(name, receiver, parameters, statements, scope, def_keyword_loc, operator_loc, lparen_loc, rparen_loc, equal_loc, end_keyword_loc)
      DefNode.new(name, receiver, parameters, statements, scope, def_keyword_loc, operator_loc, lparen_loc, rparen_loc, equal_loc, end_keyword_loc, Location.null)
    end

    # Create a new DefinedNode node
    def DefinedNode(lparen, value, rparen, keyword_loc)
      DefinedNode.new(lparen, value, rparen, keyword_loc, Location.null)
    end

    # Create a new ElseNode node
    def ElseNode(else_keyword, statements, end_keyword)
      ElseNode.new(else_keyword, statements, end_keyword, Location.null)
    end

    # Create a new EnsureNode node
    def EnsureNode(ensure_keyword, statements, end_keyword)
      EnsureNode.new(ensure_keyword, statements, end_keyword, Location.null)
    end

    # Create a new FalseNode node
    def FalseNode()
      FalseNode.new(Location.null)
    end

    # Create a new FindPatternNode node
    def FindPatternNode(constant, left, requireds, right, opening_loc, closing_loc)
      FindPatternNode.new(constant, left, requireds, right, opening_loc, closing_loc, Location.null)
    end

    # Create a new FloatNode node
    def FloatNode()
      FloatNode.new(Location.null)
    end

    # Create a new ForNode node
    def ForNode(index, collection, statements, for_keyword_loc, in_keyword_loc, do_keyword_loc, end_keyword_loc)
      ForNode.new(index, collection, statements, for_keyword_loc, in_keyword_loc, do_keyword_loc, end_keyword_loc, Location.null)
    end

    # Create a new ForwardingArgumentsNode node
    def ForwardingArgumentsNode()
      ForwardingArgumentsNode.new(Location.null)
    end

    # Create a new ForwardingParameterNode node
    def ForwardingParameterNode()
      ForwardingParameterNode.new(Location.null)
    end

    # Create a new ForwardingSuperNode node
    def ForwardingSuperNode(block)
      ForwardingSuperNode.new(block, Location.null)
    end

    # Create a new GlobalVariableReadNode node
    def GlobalVariableReadNode(name)
      GlobalVariableReadNode.new(name, Location.null)
    end

    # Create a new GlobalVariableWriteNode node
    def GlobalVariableWriteNode(name, operator, value)
      GlobalVariableWriteNode.new(name, operator, value, Location.null)
    end

    # Create a new HashNode node
    def HashNode(opening, elements, closing)
      HashNode.new(opening, elements, closing, Location.null)
    end

    # Create a new HashPatternNode node
    def HashPatternNode(constant, assocs, kwrest, opening_loc, closing_loc)
      HashPatternNode.new(constant, assocs, kwrest, opening_loc, closing_loc, Location.null)
    end

    # Create a new IfNode node
    def IfNode(if_keyword, predicate, statements, consequent, end_keyword)
      IfNode.new(if_keyword, predicate, statements, consequent, end_keyword, Location.null)
    end

    # Create a new ImaginaryNode node
    def ImaginaryNode(numeric)
      ImaginaryNode.new(numeric, Location.null)
    end

    # Create a new InNode node
    def InNode(pattern, statements, in_loc, then_loc)
      InNode.new(pattern, statements, in_loc, then_loc, Location.null)
    end

    # Create a new InstanceVariableReadNode node
    def InstanceVariableReadNode()
      InstanceVariableReadNode.new(Location.null)
    end

    # Create a new InstanceVariableWriteNode node
    def InstanceVariableWriteNode(name_loc, value, operator_loc)
      InstanceVariableWriteNode.new(name_loc, value, operator_loc, Location.null)
    end

    # Create a new IntegerNode node
    def IntegerNode()
      IntegerNode.new(Location.null)
    end

    # Create a new InterpolatedRegularExpressionNode node
    def InterpolatedRegularExpressionNode(opening, parts, closing)
      InterpolatedRegularExpressionNode.new(opening, parts, closing, Location.null)
    end

    # Create a new InterpolatedStringNode node
    def InterpolatedStringNode(opening, parts, closing)
      InterpolatedStringNode.new(opening, parts, closing, Location.null)
    end

    # Create a new InterpolatedSymbolNode node
    def InterpolatedSymbolNode(opening, parts, closing)
      InterpolatedSymbolNode.new(opening, parts, closing, Location.null)
    end

    # Create a new InterpolatedXStringNode node
    def InterpolatedXStringNode(opening, parts, closing)
      InterpolatedXStringNode.new(opening, parts, closing, Location.null)
    end

    # Create a new KeywordParameterNode node
    def KeywordParameterNode(name, value)
      KeywordParameterNode.new(name, value, Location.null)
    end

    # Create a new KeywordRestParameterNode node
    def KeywordRestParameterNode(operator, name)
      KeywordRestParameterNode.new(operator, name, Location.null)
    end

    # Create a new LambdaNode node
    def LambdaNode(scope, opening, parameters, statements)
      LambdaNode.new(scope, opening, parameters, statements, Location.null)
    end

    # Create a new LocalVariableReadNode node
    def LocalVariableReadNode(depth)
      LocalVariableReadNode.new(depth, Location.null)
    end

    # Create a new LocalVariableWriteNode node
    def LocalVariableWriteNode(name_loc, value, operator_loc, depth)
      LocalVariableWriteNode.new(name_loc, value, operator_loc, depth, Location.null)
    end

    # Create a new MatchPredicateNode node
    def MatchPredicateNode(value, pattern, operator_loc)
      MatchPredicateNode.new(value, pattern, operator_loc, Location.null)
    end

    # Create a new MatchRequiredNode node
    def MatchRequiredNode(value, pattern, operator_loc)
      MatchRequiredNode.new(value, pattern, operator_loc, Location.null)
    end

    # Create a new MissingNode node
    def MissingNode()
      MissingNode.new(Location.null)
    end

    # Create a new ModuleNode node
    def ModuleNode(scope, module_keyword, constant_path, statements, end_keyword)
      ModuleNode.new(scope, module_keyword, constant_path, statements, end_keyword, Location.null)
    end

    # Create a new MultiWriteNode node
    def MultiWriteNode(targets, operator, value, lparen_loc, rparen_loc)
      MultiWriteNode.new(targets, operator, value, lparen_loc, rparen_loc, Location.null)
    end

    # Create a new NextNode node
    def NextNode(arguments, keyword_loc)
      NextNode.new(arguments, keyword_loc, Location.null)
    end

    # Create a new NilNode node
    def NilNode()
      NilNode.new(Location.null)
    end

    # Create a new NoKeywordsParameterNode node
    def NoKeywordsParameterNode(operator_loc, keyword_loc)
      NoKeywordsParameterNode.new(operator_loc, keyword_loc, Location.null)
    end

    # Create a new OperatorAndAssignmentNode node
    def OperatorAndAssignmentNode(target, value, operator_loc)
      OperatorAndAssignmentNode.new(target, value, operator_loc, Location.null)
    end

    # Create a new OperatorAssignmentNode node
    def OperatorAssignmentNode(target, operator, value)
      OperatorAssignmentNode.new(target, operator, value, Location.null)
    end

    # Create a new OperatorOrAssignmentNode node
    def OperatorOrAssignmentNode(target, value, operator_loc)
      OperatorOrAssignmentNode.new(target, value, operator_loc, Location.null)
    end

    # Create a new OptionalParameterNode node
    def OptionalParameterNode(name, equal_operator, value)
      OptionalParameterNode.new(name, equal_operator, value, Location.null)
    end

    # Create a new OrNode node
    def OrNode(left, right, operator_loc)
      OrNode.new(left, right, operator_loc, Location.null)
    end

    # Create a new ParametersNode node
    def ParametersNode(requireds, optionals, posts, rest, keywords, keyword_rest, block)
      ParametersNode.new(requireds, optionals, posts, rest, keywords, keyword_rest, block, Location.null)
    end

    # Create a new ParenthesesNode node
    def ParenthesesNode(statements, opening_loc, closing_loc)
      ParenthesesNode.new(statements, opening_loc, closing_loc, Location.null)
    end

    # Create a new PinnedExpressionNode node
    def PinnedExpressionNode(expression, operator_loc, lparen_loc, rparen_loc)
      PinnedExpressionNode.new(expression, operator_loc, lparen_loc, rparen_loc, Location.null)
    end

    # Create a new PinnedVariableNode node
    def PinnedVariableNode(variable, operator_loc)
      PinnedVariableNode.new(variable, operator_loc, Location.null)
    end

    # Create a new PostExecutionNode node
    def PostExecutionNode(statements, keyword_loc, opening_loc, closing_loc)
      PostExecutionNode.new(statements, keyword_loc, opening_loc, closing_loc, Location.null)
    end

    # Create a new PreExecutionNode node
    def PreExecutionNode(statements, keyword_loc, opening_loc, closing_loc)
      PreExecutionNode.new(statements, keyword_loc, opening_loc, closing_loc, Location.null)
    end

    # Create a new ProgramNode node
    def ProgramNode(scope, statements)
      ProgramNode.new(scope, statements, Location.null)
    end

    # Create a new RangeNode node
    def RangeNode(left, right, operator_loc)
      RangeNode.new(left, right, operator_loc, Location.null)
    end

    # Create a new RationalNode node
    def RationalNode(numeric)
      RationalNode.new(numeric, Location.null)
    end

    # Create a new RedoNode node
    def RedoNode()
      RedoNode.new(Location.null)
    end

    # Create a new RegularExpressionNode node
    def RegularExpressionNode(opening, content, closing, unescaped)
      RegularExpressionNode.new(opening, content, closing, unescaped, Location.null)
    end

    # Create a new RequiredDestructuredParameterNode node
    def RequiredDestructuredParameterNode(parameters, opening, closing)
      RequiredDestructuredParameterNode.new(parameters, opening, closing, Location.null)
    end

    # Create a new RequiredParameterNode node
    def RequiredParameterNode()
      RequiredParameterNode.new(Location.null)
    end

    # Create a new RescueModifierNode node
    def RescueModifierNode(expression, rescue_keyword, rescue_expression)
      RescueModifierNode.new(expression, rescue_keyword, rescue_expression, Location.null)
    end

    # Create a new RescueNode node
    def RescueNode(rescue_keyword, exceptions, equal_greater, exception, statements, consequent)
      RescueNode.new(rescue_keyword, exceptions, equal_greater, exception, statements, consequent, Location.null)
    end

    # Create a new RestParameterNode node
    def RestParameterNode(operator, name)
      RestParameterNode.new(operator, name, Location.null)
    end

    # Create a new RetryNode node
    def RetryNode()
      RetryNode.new(Location.null)
    end

    # Create a new ReturnNode node
    def ReturnNode(keyword, arguments)
      ReturnNode.new(keyword, arguments, Location.null)
    end

    # Create a new ScopeNode node
    def ScopeNode(locals)
      ScopeNode.new(locals, Location.null)
    end

    # Create a new SelfNode node
    def SelfNode()
      SelfNode.new(Location.null)
    end

    # Create a new SingletonClassNode node
    def SingletonClassNode(scope, class_keyword, operator, expression, statements, end_keyword)
      SingletonClassNode.new(scope, class_keyword, operator, expression, statements, end_keyword, Location.null)
    end

    # Create a new SourceEncodingNode node
    def SourceEncodingNode()
      SourceEncodingNode.new(Location.null)
    end

    # Create a new SourceFileNode node
    def SourceFileNode(filepath)
      SourceFileNode.new(filepath, Location.null)
    end

    # Create a new SourceLineNode node
    def SourceLineNode()
      SourceLineNode.new(Location.null)
    end

    # Create a new SplatNode node
    def SplatNode(operator, expression)
      SplatNode.new(operator, expression, Location.null)
    end

    # Create a new StatementsNode node
    def StatementsNode(body)
      StatementsNode.new(body, Location.null)
    end

    # Create a new StringConcatNode node
    def StringConcatNode(left, right)
      StringConcatNode.new(left, right, Location.null)
    end

    # Create a new StringInterpolatedNode node
    def StringInterpolatedNode(opening, statements, closing)
      StringInterpolatedNode.new(opening, statements, closing, Location.null)
    end

    # Create a new StringNode node
    def StringNode(opening, content, closing, unescaped)
      StringNode.new(opening, content, closing, unescaped, Location.null)
    end

    # Create a new SuperNode node
    def SuperNode(keyword, lparen, arguments, rparen, block)
      SuperNode.new(keyword, lparen, arguments, rparen, block, Location.null)
    end

    # Create a new SymbolNode node
    def SymbolNode(opening, value, closing, unescaped)
      SymbolNode.new(opening, value, closing, unescaped, Location.null)
    end

    # Create a new TrueNode node
    def TrueNode()
      TrueNode.new(Location.null)
    end

    # Create a new UndefNode node
    def UndefNode(names, keyword_loc)
      UndefNode.new(names, keyword_loc, Location.null)
    end

    # Create a new UnlessNode node
    def UnlessNode(keyword, predicate, statements, consequent, end_keyword)
      UnlessNode.new(keyword, predicate, statements, consequent, end_keyword, Location.null)
    end

    # Create a new UntilNode node
    def UntilNode(keyword, predicate, statements)
      UntilNode.new(keyword, predicate, statements, Location.null)
    end

    # Create a new WhenNode node
    def WhenNode(when_keyword, conditions, statements)
      WhenNode.new(when_keyword, conditions, statements, Location.null)
    end

    # Create a new WhileNode node
    def WhileNode(keyword, predicate, statements)
      WhileNode.new(keyword, predicate, statements, Location.null)
    end

    # Create a new XStringNode node
    def XStringNode(opening, content, closing, unescaped)
      XStringNode.new(opening, content, closing, unescaped, Location.null)
    end

    # Create a new YieldNode node
    def YieldNode(keyword, lparen, arguments, rparen)
      YieldNode.new(keyword, lparen, arguments, rparen, Location.null)
    end

    # Create a new EOF token
    def EOF(value, location = Location.null)
      Token.new(:EOF, value, location)
    end

    # Create a new MISSING token
    def MISSING(value, location = Location.null)
      Token.new(:MISSING, value, location)
    end

    # Create a new NOT_PROVIDED token
    def NOT_PROVIDED(value, location = Location.null)
      Token.new(:NOT_PROVIDED, value, location)
    end

    # Create a new AMPERSAND token
    def AMPERSAND(value, location = Location.null)
      Token.new(:AMPERSAND, value, location)
    end

    # Create a new AMPERSAND_AMPERSAND token
    def AMPERSAND_AMPERSAND(value, location = Location.null)
      Token.new(:AMPERSAND_AMPERSAND, value, location)
    end

    # Create a new AMPERSAND_AMPERSAND_EQUAL token
    def AMPERSAND_AMPERSAND_EQUAL(value, location = Location.null)
      Token.new(:AMPERSAND_AMPERSAND_EQUAL, value, location)
    end

    # Create a new AMPERSAND_DOT token
    def AMPERSAND_DOT(value, location = Location.null)
      Token.new(:AMPERSAND_DOT, value, location)
    end

    # Create a new AMPERSAND_EQUAL token
    def AMPERSAND_EQUAL(value, location = Location.null)
      Token.new(:AMPERSAND_EQUAL, value, location)
    end

    # Create a new BACKTICK token
    def BACKTICK(value, location = Location.null)
      Token.new(:BACKTICK, value, location)
    end

    # Create a new BACK_REFERENCE token
    def BACK_REFERENCE(value, location = Location.null)
      Token.new(:BACK_REFERENCE, value, location)
    end

    # Create a new BANG token
    def BANG(value, location = Location.null)
      Token.new(:BANG, value, location)
    end

    # Create a new BANG_EQUAL token
    def BANG_EQUAL(value, location = Location.null)
      Token.new(:BANG_EQUAL, value, location)
    end

    # Create a new BANG_TILDE token
    def BANG_TILDE(value, location = Location.null)
      Token.new(:BANG_TILDE, value, location)
    end

    # Create a new BRACE_LEFT token
    def BRACE_LEFT(value, location = Location.null)
      Token.new(:BRACE_LEFT, value, location)
    end

    # Create a new BRACE_RIGHT token
    def BRACE_RIGHT(value, location = Location.null)
      Token.new(:BRACE_RIGHT, value, location)
    end

    # Create a new BRACKET_LEFT token
    def BRACKET_LEFT(value, location = Location.null)
      Token.new(:BRACKET_LEFT, value, location)
    end

    # Create a new BRACKET_LEFT_ARRAY token
    def BRACKET_LEFT_ARRAY(value, location = Location.null)
      Token.new(:BRACKET_LEFT_ARRAY, value, location)
    end

    # Create a new BRACKET_LEFT_RIGHT token
    def BRACKET_LEFT_RIGHT(value, location = Location.null)
      Token.new(:BRACKET_LEFT_RIGHT, value, location)
    end

    # Create a new BRACKET_LEFT_RIGHT_EQUAL token
    def BRACKET_LEFT_RIGHT_EQUAL(value, location = Location.null)
      Token.new(:BRACKET_LEFT_RIGHT_EQUAL, value, location)
    end

    # Create a new BRACKET_RIGHT token
    def BRACKET_RIGHT(value, location = Location.null)
      Token.new(:BRACKET_RIGHT, value, location)
    end

    # Create a new CARET token
    def CARET(value, location = Location.null)
      Token.new(:CARET, value, location)
    end

    # Create a new CARET_EQUAL token
    def CARET_EQUAL(value, location = Location.null)
      Token.new(:CARET_EQUAL, value, location)
    end

    # Create a new CHARACTER_LITERAL token
    def CHARACTER_LITERAL(value, location = Location.null)
      Token.new(:CHARACTER_LITERAL, value, location)
    end

    # Create a new CLASS_VARIABLE token
    def CLASS_VARIABLE(value, location = Location.null)
      Token.new(:CLASS_VARIABLE, value, location)
    end

    # Create a new COLON token
    def COLON(value, location = Location.null)
      Token.new(:COLON, value, location)
    end

    # Create a new COLON_COLON token
    def COLON_COLON(value, location = Location.null)
      Token.new(:COLON_COLON, value, location)
    end

    # Create a new COMMA token
    def COMMA(value, location = Location.null)
      Token.new(:COMMA, value, location)
    end

    # Create a new COMMENT token
    def COMMENT(value, location = Location.null)
      Token.new(:COMMENT, value, location)
    end

    # Create a new CONSTANT token
    def CONSTANT(value, location = Location.null)
      Token.new(:CONSTANT, value, location)
    end

    # Create a new DOT token
    def DOT(value, location = Location.null)
      Token.new(:DOT, value, location)
    end

    # Create a new DOT_DOT token
    def DOT_DOT(value, location = Location.null)
      Token.new(:DOT_DOT, value, location)
    end

    # Create a new DOT_DOT_DOT token
    def DOT_DOT_DOT(value, location = Location.null)
      Token.new(:DOT_DOT_DOT, value, location)
    end

    # Create a new EMBDOC_BEGIN token
    def EMBDOC_BEGIN(value, location = Location.null)
      Token.new(:EMBDOC_BEGIN, value, location)
    end

    # Create a new EMBDOC_END token
    def EMBDOC_END(value, location = Location.null)
      Token.new(:EMBDOC_END, value, location)
    end

    # Create a new EMBDOC_LINE token
    def EMBDOC_LINE(value, location = Location.null)
      Token.new(:EMBDOC_LINE, value, location)
    end

    # Create a new EMBEXPR_BEGIN token
    def EMBEXPR_BEGIN(value, location = Location.null)
      Token.new(:EMBEXPR_BEGIN, value, location)
    end

    # Create a new EMBEXPR_END token
    def EMBEXPR_END(value, location = Location.null)
      Token.new(:EMBEXPR_END, value, location)
    end

    # Create a new EMBVAR token
    def EMBVAR(value, location = Location.null)
      Token.new(:EMBVAR, value, location)
    end

    # Create a new EQUAL token
    def EQUAL(value, location = Location.null)
      Token.new(:EQUAL, value, location)
    end

    # Create a new EQUAL_EQUAL token
    def EQUAL_EQUAL(value, location = Location.null)
      Token.new(:EQUAL_EQUAL, value, location)
    end

    # Create a new EQUAL_EQUAL_EQUAL token
    def EQUAL_EQUAL_EQUAL(value, location = Location.null)
      Token.new(:EQUAL_EQUAL_EQUAL, value, location)
    end

    # Create a new EQUAL_GREATER token
    def EQUAL_GREATER(value, location = Location.null)
      Token.new(:EQUAL_GREATER, value, location)
    end

    # Create a new EQUAL_TILDE token
    def EQUAL_TILDE(value, location = Location.null)
      Token.new(:EQUAL_TILDE, value, location)
    end

    # Create a new FLOAT token
    def FLOAT(value, location = Location.null)
      Token.new(:FLOAT, value, location)
    end

    # Create a new GLOBAL_VARIABLE token
    def GLOBAL_VARIABLE(value, location = Location.null)
      Token.new(:GLOBAL_VARIABLE, value, location)
    end

    # Create a new GREATER token
    def GREATER(value, location = Location.null)
      Token.new(:GREATER, value, location)
    end

    # Create a new GREATER_EQUAL token
    def GREATER_EQUAL(value, location = Location.null)
      Token.new(:GREATER_EQUAL, value, location)
    end

    # Create a new GREATER_GREATER token
    def GREATER_GREATER(value, location = Location.null)
      Token.new(:GREATER_GREATER, value, location)
    end

    # Create a new GREATER_GREATER_EQUAL token
    def GREATER_GREATER_EQUAL(value, location = Location.null)
      Token.new(:GREATER_GREATER_EQUAL, value, location)
    end

    # Create a new HEREDOC_END token
    def HEREDOC_END(value, location = Location.null)
      Token.new(:HEREDOC_END, value, location)
    end

    # Create a new HEREDOC_START token
    def HEREDOC_START(value, location = Location.null)
      Token.new(:HEREDOC_START, value, location)
    end

    # Create a new IDENTIFIER token
    def IDENTIFIER(value, location = Location.null)
      Token.new(:IDENTIFIER, value, location)
    end

    # Create a new IGNORED_NEWLINE token
    def IGNORED_NEWLINE(value, location = Location.null)
      Token.new(:IGNORED_NEWLINE, value, location)
    end

    # Create a new IMAGINARY_NUMBER token
    def IMAGINARY_NUMBER(value, location = Location.null)
      Token.new(:IMAGINARY_NUMBER, value, location)
    end

    # Create a new INSTANCE_VARIABLE token
    def INSTANCE_VARIABLE(value, location = Location.null)
      Token.new(:INSTANCE_VARIABLE, value, location)
    end

    # Create a new INTEGER token
    def INTEGER(value, location = Location.null)
      Token.new(:INTEGER, value, location)
    end

    # Create a new KEYWORD_ALIAS token
    def KEYWORD_ALIAS(value, location = Location.null)
      Token.new(:KEYWORD_ALIAS, value, location)
    end

    # Create a new KEYWORD_AND token
    def KEYWORD_AND(value, location = Location.null)
      Token.new(:KEYWORD_AND, value, location)
    end

    # Create a new KEYWORD_BEGIN token
    def KEYWORD_BEGIN(value, location = Location.null)
      Token.new(:KEYWORD_BEGIN, value, location)
    end

    # Create a new KEYWORD_BEGIN_UPCASE token
    def KEYWORD_BEGIN_UPCASE(value, location = Location.null)
      Token.new(:KEYWORD_BEGIN_UPCASE, value, location)
    end

    # Create a new KEYWORD_BREAK token
    def KEYWORD_BREAK(value, location = Location.null)
      Token.new(:KEYWORD_BREAK, value, location)
    end

    # Create a new KEYWORD_CASE token
    def KEYWORD_CASE(value, location = Location.null)
      Token.new(:KEYWORD_CASE, value, location)
    end

    # Create a new KEYWORD_CLASS token
    def KEYWORD_CLASS(value, location = Location.null)
      Token.new(:KEYWORD_CLASS, value, location)
    end

    # Create a new KEYWORD_DEF token
    def KEYWORD_DEF(value, location = Location.null)
      Token.new(:KEYWORD_DEF, value, location)
    end

    # Create a new KEYWORD_DEFINED token
    def KEYWORD_DEFINED(value, location = Location.null)
      Token.new(:KEYWORD_DEFINED, value, location)
    end

    # Create a new KEYWORD_DO token
    def KEYWORD_DO(value, location = Location.null)
      Token.new(:KEYWORD_DO, value, location)
    end

    # Create a new KEYWORD_DO_LOOP token
    def KEYWORD_DO_LOOP(value, location = Location.null)
      Token.new(:KEYWORD_DO_LOOP, value, location)
    end

    # Create a new KEYWORD_ELSE token
    def KEYWORD_ELSE(value, location = Location.null)
      Token.new(:KEYWORD_ELSE, value, location)
    end

    # Create a new KEYWORD_ELSIF token
    def KEYWORD_ELSIF(value, location = Location.null)
      Token.new(:KEYWORD_ELSIF, value, location)
    end

    # Create a new KEYWORD_END token
    def KEYWORD_END(value, location = Location.null)
      Token.new(:KEYWORD_END, value, location)
    end

    # Create a new KEYWORD_END_UPCASE token
    def KEYWORD_END_UPCASE(value, location = Location.null)
      Token.new(:KEYWORD_END_UPCASE, value, location)
    end

    # Create a new KEYWORD_ENSURE token
    def KEYWORD_ENSURE(value, location = Location.null)
      Token.new(:KEYWORD_ENSURE, value, location)
    end

    # Create a new KEYWORD_FALSE token
    def KEYWORD_FALSE(value, location = Location.null)
      Token.new(:KEYWORD_FALSE, value, location)
    end

    # Create a new KEYWORD_FOR token
    def KEYWORD_FOR(value, location = Location.null)
      Token.new(:KEYWORD_FOR, value, location)
    end

    # Create a new KEYWORD_IF token
    def KEYWORD_IF(value, location = Location.null)
      Token.new(:KEYWORD_IF, value, location)
    end

    # Create a new KEYWORD_IF_MODIFIER token
    def KEYWORD_IF_MODIFIER(value, location = Location.null)
      Token.new(:KEYWORD_IF_MODIFIER, value, location)
    end

    # Create a new KEYWORD_IN token
    def KEYWORD_IN(value, location = Location.null)
      Token.new(:KEYWORD_IN, value, location)
    end

    # Create a new KEYWORD_MODULE token
    def KEYWORD_MODULE(value, location = Location.null)
      Token.new(:KEYWORD_MODULE, value, location)
    end

    # Create a new KEYWORD_NEXT token
    def KEYWORD_NEXT(value, location = Location.null)
      Token.new(:KEYWORD_NEXT, value, location)
    end

    # Create a new KEYWORD_NIL token
    def KEYWORD_NIL(value, location = Location.null)
      Token.new(:KEYWORD_NIL, value, location)
    end

    # Create a new KEYWORD_NOT token
    def KEYWORD_NOT(value, location = Location.null)
      Token.new(:KEYWORD_NOT, value, location)
    end

    # Create a new KEYWORD_OR token
    def KEYWORD_OR(value, location = Location.null)
      Token.new(:KEYWORD_OR, value, location)
    end

    # Create a new KEYWORD_REDO token
    def KEYWORD_REDO(value, location = Location.null)
      Token.new(:KEYWORD_REDO, value, location)
    end

    # Create a new KEYWORD_RESCUE token
    def KEYWORD_RESCUE(value, location = Location.null)
      Token.new(:KEYWORD_RESCUE, value, location)
    end

    # Create a new KEYWORD_RESCUE_MODIFIER token
    def KEYWORD_RESCUE_MODIFIER(value, location = Location.null)
      Token.new(:KEYWORD_RESCUE_MODIFIER, value, location)
    end

    # Create a new KEYWORD_RETRY token
    def KEYWORD_RETRY(value, location = Location.null)
      Token.new(:KEYWORD_RETRY, value, location)
    end

    # Create a new KEYWORD_RETURN token
    def KEYWORD_RETURN(value, location = Location.null)
      Token.new(:KEYWORD_RETURN, value, location)
    end

    # Create a new KEYWORD_SELF token
    def KEYWORD_SELF(value, location = Location.null)
      Token.new(:KEYWORD_SELF, value, location)
    end

    # Create a new KEYWORD_SUPER token
    def KEYWORD_SUPER(value, location = Location.null)
      Token.new(:KEYWORD_SUPER, value, location)
    end

    # Create a new KEYWORD_THEN token
    def KEYWORD_THEN(value, location = Location.null)
      Token.new(:KEYWORD_THEN, value, location)
    end

    # Create a new KEYWORD_TRUE token
    def KEYWORD_TRUE(value, location = Location.null)
      Token.new(:KEYWORD_TRUE, value, location)
    end

    # Create a new KEYWORD_UNDEF token
    def KEYWORD_UNDEF(value, location = Location.null)
      Token.new(:KEYWORD_UNDEF, value, location)
    end

    # Create a new KEYWORD_UNLESS token
    def KEYWORD_UNLESS(value, location = Location.null)
      Token.new(:KEYWORD_UNLESS, value, location)
    end

    # Create a new KEYWORD_UNLESS_MODIFIER token
    def KEYWORD_UNLESS_MODIFIER(value, location = Location.null)
      Token.new(:KEYWORD_UNLESS_MODIFIER, value, location)
    end

    # Create a new KEYWORD_UNTIL token
    def KEYWORD_UNTIL(value, location = Location.null)
      Token.new(:KEYWORD_UNTIL, value, location)
    end

    # Create a new KEYWORD_UNTIL_MODIFIER token
    def KEYWORD_UNTIL_MODIFIER(value, location = Location.null)
      Token.new(:KEYWORD_UNTIL_MODIFIER, value, location)
    end

    # Create a new KEYWORD_WHEN token
    def KEYWORD_WHEN(value, location = Location.null)
      Token.new(:KEYWORD_WHEN, value, location)
    end

    # Create a new KEYWORD_WHILE token
    def KEYWORD_WHILE(value, location = Location.null)
      Token.new(:KEYWORD_WHILE, value, location)
    end

    # Create a new KEYWORD_WHILE_MODIFIER token
    def KEYWORD_WHILE_MODIFIER(value, location = Location.null)
      Token.new(:KEYWORD_WHILE_MODIFIER, value, location)
    end

    # Create a new KEYWORD_YIELD token
    def KEYWORD_YIELD(value, location = Location.null)
      Token.new(:KEYWORD_YIELD, value, location)
    end

    # Create a new KEYWORD___ENCODING__ token
    def KEYWORD___ENCODING__(value, location = Location.null)
      Token.new(:KEYWORD___ENCODING__, value, location)
    end

    # Create a new KEYWORD___FILE__ token
    def KEYWORD___FILE__(value, location = Location.null)
      Token.new(:KEYWORD___FILE__, value, location)
    end

    # Create a new KEYWORD___LINE__ token
    def KEYWORD___LINE__(value, location = Location.null)
      Token.new(:KEYWORD___LINE__, value, location)
    end

    # Create a new LABEL token
    def LABEL(value, location = Location.null)
      Token.new(:LABEL, value, location)
    end

    # Create a new LABEL_END token
    def LABEL_END(value, location = Location.null)
      Token.new(:LABEL_END, value, location)
    end

    # Create a new LAMBDA_BEGIN token
    def LAMBDA_BEGIN(value, location = Location.null)
      Token.new(:LAMBDA_BEGIN, value, location)
    end

    # Create a new LESS token
    def LESS(value, location = Location.null)
      Token.new(:LESS, value, location)
    end

    # Create a new LESS_EQUAL token
    def LESS_EQUAL(value, location = Location.null)
      Token.new(:LESS_EQUAL, value, location)
    end

    # Create a new LESS_EQUAL_GREATER token
    def LESS_EQUAL_GREATER(value, location = Location.null)
      Token.new(:LESS_EQUAL_GREATER, value, location)
    end

    # Create a new LESS_LESS token
    def LESS_LESS(value, location = Location.null)
      Token.new(:LESS_LESS, value, location)
    end

    # Create a new LESS_LESS_EQUAL token
    def LESS_LESS_EQUAL(value, location = Location.null)
      Token.new(:LESS_LESS_EQUAL, value, location)
    end

    # Create a new MINUS token
    def MINUS(value, location = Location.null)
      Token.new(:MINUS, value, location)
    end

    # Create a new MINUS_EQUAL token
    def MINUS_EQUAL(value, location = Location.null)
      Token.new(:MINUS_EQUAL, value, location)
    end

    # Create a new MINUS_GREATER token
    def MINUS_GREATER(value, location = Location.null)
      Token.new(:MINUS_GREATER, value, location)
    end

    # Create a new NEWLINE token
    def NEWLINE(value, location = Location.null)
      Token.new(:NEWLINE, value, location)
    end

    # Create a new NTH_REFERENCE token
    def NTH_REFERENCE(value, location = Location.null)
      Token.new(:NTH_REFERENCE, value, location)
    end

    # Create a new PARENTHESIS_LEFT token
    def PARENTHESIS_LEFT(value, location = Location.null)
      Token.new(:PARENTHESIS_LEFT, value, location)
    end

    # Create a new PARENTHESIS_LEFT_PARENTHESES token
    def PARENTHESIS_LEFT_PARENTHESES(value, location = Location.null)
      Token.new(:PARENTHESIS_LEFT_PARENTHESES, value, location)
    end

    # Create a new PARENTHESIS_RIGHT token
    def PARENTHESIS_RIGHT(value, location = Location.null)
      Token.new(:PARENTHESIS_RIGHT, value, location)
    end

    # Create a new PERCENT token
    def PERCENT(value, location = Location.null)
      Token.new(:PERCENT, value, location)
    end

    # Create a new PERCENT_EQUAL token
    def PERCENT_EQUAL(value, location = Location.null)
      Token.new(:PERCENT_EQUAL, value, location)
    end

    # Create a new PERCENT_LOWER_I token
    def PERCENT_LOWER_I(value, location = Location.null)
      Token.new(:PERCENT_LOWER_I, value, location)
    end

    # Create a new PERCENT_LOWER_W token
    def PERCENT_LOWER_W(value, location = Location.null)
      Token.new(:PERCENT_LOWER_W, value, location)
    end

    # Create a new PERCENT_LOWER_X token
    def PERCENT_LOWER_X(value, location = Location.null)
      Token.new(:PERCENT_LOWER_X, value, location)
    end

    # Create a new PERCENT_UPPER_I token
    def PERCENT_UPPER_I(value, location = Location.null)
      Token.new(:PERCENT_UPPER_I, value, location)
    end

    # Create a new PERCENT_UPPER_W token
    def PERCENT_UPPER_W(value, location = Location.null)
      Token.new(:PERCENT_UPPER_W, value, location)
    end

    # Create a new PIPE token
    def PIPE(value, location = Location.null)
      Token.new(:PIPE, value, location)
    end

    # Create a new PIPE_EQUAL token
    def PIPE_EQUAL(value, location = Location.null)
      Token.new(:PIPE_EQUAL, value, location)
    end

    # Create a new PIPE_PIPE token
    def PIPE_PIPE(value, location = Location.null)
      Token.new(:PIPE_PIPE, value, location)
    end

    # Create a new PIPE_PIPE_EQUAL token
    def PIPE_PIPE_EQUAL(value, location = Location.null)
      Token.new(:PIPE_PIPE_EQUAL, value, location)
    end

    # Create a new PLUS token
    def PLUS(value, location = Location.null)
      Token.new(:PLUS, value, location)
    end

    # Create a new PLUS_EQUAL token
    def PLUS_EQUAL(value, location = Location.null)
      Token.new(:PLUS_EQUAL, value, location)
    end

    # Create a new QUESTION_MARK token
    def QUESTION_MARK(value, location = Location.null)
      Token.new(:QUESTION_MARK, value, location)
    end

    # Create a new RATIONAL_NUMBER token
    def RATIONAL_NUMBER(value, location = Location.null)
      Token.new(:RATIONAL_NUMBER, value, location)
    end

    # Create a new REGEXP_BEGIN token
    def REGEXP_BEGIN(value, location = Location.null)
      Token.new(:REGEXP_BEGIN, value, location)
    end

    # Create a new REGEXP_END token
    def REGEXP_END(value, location = Location.null)
      Token.new(:REGEXP_END, value, location)
    end

    # Create a new SEMICOLON token
    def SEMICOLON(value, location = Location.null)
      Token.new(:SEMICOLON, value, location)
    end

    # Create a new SLASH token
    def SLASH(value, location = Location.null)
      Token.new(:SLASH, value, location)
    end

    # Create a new SLASH_EQUAL token
    def SLASH_EQUAL(value, location = Location.null)
      Token.new(:SLASH_EQUAL, value, location)
    end

    # Create a new STAR token
    def STAR(value, location = Location.null)
      Token.new(:STAR, value, location)
    end

    # Create a new STAR_EQUAL token
    def STAR_EQUAL(value, location = Location.null)
      Token.new(:STAR_EQUAL, value, location)
    end

    # Create a new STAR_STAR token
    def STAR_STAR(value, location = Location.null)
      Token.new(:STAR_STAR, value, location)
    end

    # Create a new STAR_STAR_EQUAL token
    def STAR_STAR_EQUAL(value, location = Location.null)
      Token.new(:STAR_STAR_EQUAL, value, location)
    end

    # Create a new STRING_BEGIN token
    def STRING_BEGIN(value, location = Location.null)
      Token.new(:STRING_BEGIN, value, location)
    end

    # Create a new STRING_CONTENT token
    def STRING_CONTENT(value, location = Location.null)
      Token.new(:STRING_CONTENT, value, location)
    end

    # Create a new STRING_END token
    def STRING_END(value, location = Location.null)
      Token.new(:STRING_END, value, location)
    end

    # Create a new SYMBOL_BEGIN token
    def SYMBOL_BEGIN(value, location = Location.null)
      Token.new(:SYMBOL_BEGIN, value, location)
    end

    # Create a new TILDE token
    def TILDE(value, location = Location.null)
      Token.new(:TILDE, value, location)
    end

    # Create a new UCOLON_COLON token
    def UCOLON_COLON(value, location = Location.null)
      Token.new(:UCOLON_COLON, value, location)
    end

    # Create a new UDOT_DOT token
    def UDOT_DOT(value, location = Location.null)
      Token.new(:UDOT_DOT, value, location)
    end

    # Create a new UDOT_DOT_DOT token
    def UDOT_DOT_DOT(value, location = Location.null)
      Token.new(:UDOT_DOT_DOT, value, location)
    end

    # Create a new UMINUS token
    def UMINUS(value, location = Location.null)
      Token.new(:UMINUS, value, location)
    end

    # Create a new UMINUS_NUM token
    def UMINUS_NUM(value, location = Location.null)
      Token.new(:UMINUS_NUM, value, location)
    end

    # Create a new UPLUS token
    def UPLUS(value, location = Location.null)
      Token.new(:UPLUS, value, location)
    end

    # Create a new USTAR token
    def USTAR(value, location = Location.null)
      Token.new(:USTAR, value, location)
    end

    # Create a new USTAR_STAR token
    def USTAR_STAR(value, location = Location.null)
      Token.new(:USTAR_STAR, value, location)
    end

    # Create a new WORDS_SEP token
    def WORDS_SEP(value, location = Location.null)
      Token.new(:WORDS_SEP, value, location)
    end

    # Create a new __END__ token
    def __END__(value, location = Location.null)
      Token.new(:__END__, value, location)
    end
  end
end
