/******************************************************************************/
/* This file is generated by the bin/template script and should not be        */
/* modified manually. See                                                     */
/* bin/templates/ext/yarp/node.c.erb                                          */
/* if you are looking to modify the                                           */
/* template                                                                   */
/******************************************************************************/
#include "extension.h"

extern VALUE rb_cYARP;
extern VALUE rb_cYARPToken;
extern VALUE rb_cYARPLocation;

static VALUE
location_new(yp_parser_t *parser, const char *start, const char *end) {
  VALUE argv[] = { LONG2FIX(start - parser->start), LONG2FIX(end - parser->start) };
  return rb_class_new_instance(2, argv, rb_cYARPLocation);
}

static VALUE
yp_string_new(yp_string_t *string, rb_encoding *encoding) {
  return rb_enc_str_new(yp_string_source(string), yp_string_length(string), encoding);
}

VALUE
yp_token_new(yp_parser_t *parser, yp_token_t *token, rb_encoding *encoding) {
  VALUE argv[] = {
    ID2SYM(rb_intern(yp_token_type_to_str(token->type))),
    rb_enc_str_new(token->start, token->end - token->start, encoding),
    location_new(parser, token->start, token->end)
  };

  return rb_class_new_instance(3, argv, rb_cYARPToken);
}

VALUE
yp_node_new(yp_parser_t *parser, yp_node_t *node, rb_encoding *encoding) {
  switch (node->type) {
    case YP_NODE_ALIAS_NODE: {
      VALUE argv[4];

      // new_name
      argv[0] = yp_node_new(parser, (yp_node_t *)((yp_alias_node_t *)node)->new_name, encoding);

      // old_name
      argv[1] = yp_node_new(parser, (yp_node_t *)((yp_alias_node_t *)node)->old_name, encoding);

      // keyword_loc
      argv[2] = location_new(parser, ((yp_alias_node_t *)node)->keyword_loc.start, ((yp_alias_node_t *)node)->keyword_loc.end);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("AliasNode")));
    }
    case YP_NODE_ALTERNATION_PATTERN_NODE: {
      VALUE argv[4];

      // left
      argv[0] = yp_node_new(parser, (yp_node_t *)((yp_alternation_pattern_node_t *)node)->left, encoding);

      // right
      argv[1] = yp_node_new(parser, (yp_node_t *)((yp_alternation_pattern_node_t *)node)->right, encoding);

      // operator_loc
      argv[2] = location_new(parser, ((yp_alternation_pattern_node_t *)node)->operator_loc.start, ((yp_alternation_pattern_node_t *)node)->operator_loc.end);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("AlternationPatternNode")));
    }
    case YP_NODE_AND_NODE: {
      VALUE argv[4];

      // left
      argv[0] = yp_node_new(parser, (yp_node_t *)((yp_and_node_t *)node)->left, encoding);

      // right
      argv[1] = yp_node_new(parser, (yp_node_t *)((yp_and_node_t *)node)->right, encoding);

      // operator
      argv[2] = yp_token_new(parser, &((yp_and_node_t *)node)->operator, encoding);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("AndNode")));
    }
    case YP_NODE_ARGUMENTS_NODE: {
      VALUE argv[2];

      // arguments
      argv[0] = rb_ary_new();
      for (size_t index = 0; index < ((yp_arguments_node_t *)node)->arguments.size; index++) {
        rb_ary_push(argv[0], yp_node_new(parser, ((yp_arguments_node_t *)node)->arguments.nodes[index], encoding));
      }

      // location
      argv[1] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(2, argv, rb_const_get_at(rb_cYARP, rb_intern("ArgumentsNode")));
    }
    case YP_NODE_ARRAY_NODE: {
      VALUE argv[4];

      // elements
      argv[0] = rb_ary_new();
      for (size_t index = 0; index < ((yp_array_node_t *)node)->elements.size; index++) {
        rb_ary_push(argv[0], yp_node_new(parser, ((yp_array_node_t *)node)->elements.nodes[index], encoding));
      }

      // opening
      argv[1] = ((yp_array_node_t *)node)->opening.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_array_node_t *)node)->opening, encoding);

      // closing
      argv[2] = ((yp_array_node_t *)node)->closing.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_array_node_t *)node)->closing, encoding);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("ArrayNode")));
    }
    case YP_NODE_ARRAY_PATTERN_NODE: {
      VALUE argv[7];

      // constant
      argv[0] = ((yp_array_pattern_node_t *)node)->constant == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_array_pattern_node_t *)node)->constant, encoding);

      // requireds
      argv[1] = rb_ary_new();
      for (size_t index = 0; index < ((yp_array_pattern_node_t *)node)->requireds.size; index++) {
        rb_ary_push(argv[1], yp_node_new(parser, ((yp_array_pattern_node_t *)node)->requireds.nodes[index], encoding));
      }

      // rest
      argv[2] = ((yp_array_pattern_node_t *)node)->rest == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_array_pattern_node_t *)node)->rest, encoding);

      // posts
      argv[3] = rb_ary_new();
      for (size_t index = 0; index < ((yp_array_pattern_node_t *)node)->posts.size; index++) {
        rb_ary_push(argv[3], yp_node_new(parser, ((yp_array_pattern_node_t *)node)->posts.nodes[index], encoding));
      }

      // opening_loc
      argv[4] = ((yp_array_pattern_node_t *)node)->opening_loc.start == NULL ? Qnil : location_new(parser, ((yp_array_pattern_node_t *)node)->opening_loc.start, ((yp_array_pattern_node_t *)node)->opening_loc.end);

      // closing_loc
      argv[5] = ((yp_array_pattern_node_t *)node)->closing_loc.start == NULL ? Qnil : location_new(parser, ((yp_array_pattern_node_t *)node)->closing_loc.start, ((yp_array_pattern_node_t *)node)->closing_loc.end);

      // location
      argv[6] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(7, argv, rb_const_get_at(rb_cYARP, rb_intern("ArrayPatternNode")));
    }
    case YP_NODE_ASSOC_NODE: {
      VALUE argv[4];

      // key
      argv[0] = yp_node_new(parser, (yp_node_t *)((yp_assoc_node_t *)node)->key, encoding);

      // value
      argv[1] = ((yp_assoc_node_t *)node)->value == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_assoc_node_t *)node)->value, encoding);

      // operator
      argv[2] = ((yp_assoc_node_t *)node)->operator.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_assoc_node_t *)node)->operator, encoding);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("AssocNode")));
    }
    case YP_NODE_ASSOC_SPLAT_NODE: {
      VALUE argv[3];

      // value
      argv[0] = ((yp_assoc_splat_node_t *)node)->value == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_assoc_splat_node_t *)node)->value, encoding);

      // operator_loc
      argv[1] = location_new(parser, ((yp_assoc_splat_node_t *)node)->operator_loc.start, ((yp_assoc_splat_node_t *)node)->operator_loc.end);

      // location
      argv[2] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(3, argv, rb_const_get_at(rb_cYARP, rb_intern("AssocSplatNode")));
    }
    case YP_NODE_BEGIN_NODE: {
      VALUE argv[7];

      // begin_keyword
      argv[0] = ((yp_begin_node_t *)node)->begin_keyword.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_begin_node_t *)node)->begin_keyword, encoding);

      // statements
      argv[1] = ((yp_begin_node_t *)node)->statements == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_begin_node_t *)node)->statements, encoding);

      // rescue_clause
      argv[2] = ((yp_begin_node_t *)node)->rescue_clause == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_begin_node_t *)node)->rescue_clause, encoding);

      // else_clause
      argv[3] = ((yp_begin_node_t *)node)->else_clause == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_begin_node_t *)node)->else_clause, encoding);

      // ensure_clause
      argv[4] = ((yp_begin_node_t *)node)->ensure_clause == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_begin_node_t *)node)->ensure_clause, encoding);

      // end_keyword
      argv[5] = ((yp_begin_node_t *)node)->end_keyword.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_begin_node_t *)node)->end_keyword, encoding);

      // location
      argv[6] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(7, argv, rb_const_get_at(rb_cYARP, rb_intern("BeginNode")));
    }
    case YP_NODE_BLOCK_ARGUMENT_NODE: {
      VALUE argv[3];

      // expression
      argv[0] = ((yp_block_argument_node_t *)node)->expression == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_block_argument_node_t *)node)->expression, encoding);

      // operator_loc
      argv[1] = location_new(parser, ((yp_block_argument_node_t *)node)->operator_loc.start, ((yp_block_argument_node_t *)node)->operator_loc.end);

      // location
      argv[2] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(3, argv, rb_const_get_at(rb_cYARP, rb_intern("BlockArgumentNode")));
    }
    case YP_NODE_BLOCK_NODE: {
      VALUE argv[6];

      // scope
      argv[0] = yp_node_new(parser, (yp_node_t *)((yp_block_node_t *)node)->scope, encoding);

      // parameters
      argv[1] = ((yp_block_node_t *)node)->parameters == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_block_node_t *)node)->parameters, encoding);

      // statements
      argv[2] = ((yp_block_node_t *)node)->statements == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_block_node_t *)node)->statements, encoding);

      // opening_loc
      argv[3] = location_new(parser, ((yp_block_node_t *)node)->opening_loc.start, ((yp_block_node_t *)node)->opening_loc.end);

      // closing_loc
      argv[4] = location_new(parser, ((yp_block_node_t *)node)->closing_loc.start, ((yp_block_node_t *)node)->closing_loc.end);

      // location
      argv[5] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(6, argv, rb_const_get_at(rb_cYARP, rb_intern("BlockNode")));
    }
    case YP_NODE_BLOCK_PARAMETER_NODE: {
      VALUE argv[3];

      // name
      argv[0] = ((yp_block_parameter_node_t *)node)->name.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_block_parameter_node_t *)node)->name, encoding);

      // operator_loc
      argv[1] = location_new(parser, ((yp_block_parameter_node_t *)node)->operator_loc.start, ((yp_block_parameter_node_t *)node)->operator_loc.end);

      // location
      argv[2] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(3, argv, rb_const_get_at(rb_cYARP, rb_intern("BlockParameterNode")));
    }
    case YP_NODE_BLOCK_PARAMETERS_NODE: {
      VALUE argv[5];

      // parameters
      argv[0] = ((yp_block_parameters_node_t *)node)->parameters == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_block_parameters_node_t *)node)->parameters, encoding);

      // locals
      argv[1] = rb_ary_new();
      for (size_t index = 0; index < ((yp_block_parameters_node_t *)node)->locals.size; index++) {
        rb_ary_push(argv[1], yp_token_new(parser, &((yp_block_parameters_node_t *)node)->locals.tokens[index], encoding));
      }

      // opening_loc
      argv[2] = ((yp_block_parameters_node_t *)node)->opening_loc.start == NULL ? Qnil : location_new(parser, ((yp_block_parameters_node_t *)node)->opening_loc.start, ((yp_block_parameters_node_t *)node)->opening_loc.end);

      // closing_loc
      argv[3] = ((yp_block_parameters_node_t *)node)->closing_loc.start == NULL ? Qnil : location_new(parser, ((yp_block_parameters_node_t *)node)->closing_loc.start, ((yp_block_parameters_node_t *)node)->closing_loc.end);

      // location
      argv[4] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(5, argv, rb_const_get_at(rb_cYARP, rb_intern("BlockParametersNode")));
    }
    case YP_NODE_BREAK_NODE: {
      VALUE argv[3];

      // arguments
      argv[0] = ((yp_break_node_t *)node)->arguments == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_break_node_t *)node)->arguments, encoding);

      // keyword_loc
      argv[1] = location_new(parser, ((yp_break_node_t *)node)->keyword_loc.start, ((yp_break_node_t *)node)->keyword_loc.end);

      // location
      argv[2] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(3, argv, rb_const_get_at(rb_cYARP, rb_intern("BreakNode")));
    }
    case YP_NODE_CALL_NODE: {
      VALUE argv[9];

      // receiver
      argv[0] = ((yp_call_node_t *)node)->receiver == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_call_node_t *)node)->receiver, encoding);

      // call_operator
      argv[1] = ((yp_call_node_t *)node)->call_operator.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_call_node_t *)node)->call_operator, encoding);

      // message
      argv[2] = ((yp_call_node_t *)node)->message.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_call_node_t *)node)->message, encoding);

      // opening
      argv[3] = ((yp_call_node_t *)node)->opening.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_call_node_t *)node)->opening, encoding);

      // arguments
      argv[4] = ((yp_call_node_t *)node)->arguments == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_call_node_t *)node)->arguments, encoding);

      // closing
      argv[5] = ((yp_call_node_t *)node)->closing.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_call_node_t *)node)->closing, encoding);

      // block
      argv[6] = ((yp_call_node_t *)node)->block == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_call_node_t *)node)->block, encoding);

      // name
      argv[7] = yp_string_new(&((yp_call_node_t *)node)->name, encoding);

      // location
      argv[8] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(9, argv, rb_const_get_at(rb_cYARP, rb_intern("CallNode")));
    }
    case YP_NODE_CAPTURE_PATTERN_NODE: {
      VALUE argv[4];

      // value
      argv[0] = yp_node_new(parser, (yp_node_t *)((yp_capture_pattern_node_t *)node)->value, encoding);

      // target
      argv[1] = yp_node_new(parser, (yp_node_t *)((yp_capture_pattern_node_t *)node)->target, encoding);

      // operator_loc
      argv[2] = location_new(parser, ((yp_capture_pattern_node_t *)node)->operator_loc.start, ((yp_capture_pattern_node_t *)node)->operator_loc.end);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("CapturePatternNode")));
    }
    case YP_NODE_CASE_NODE: {
      VALUE argv[6];

      // predicate
      argv[0] = ((yp_case_node_t *)node)->predicate == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_case_node_t *)node)->predicate, encoding);

      // conditions
      argv[1] = rb_ary_new();
      for (size_t index = 0; index < ((yp_case_node_t *)node)->conditions.size; index++) {
        rb_ary_push(argv[1], yp_node_new(parser, ((yp_case_node_t *)node)->conditions.nodes[index], encoding));
      }

      // consequent
      argv[2] = ((yp_case_node_t *)node)->consequent == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_case_node_t *)node)->consequent, encoding);

      // case_keyword_loc
      argv[3] = location_new(parser, ((yp_case_node_t *)node)->case_keyword_loc.start, ((yp_case_node_t *)node)->case_keyword_loc.end);

      // end_keyword_loc
      argv[4] = location_new(parser, ((yp_case_node_t *)node)->end_keyword_loc.start, ((yp_case_node_t *)node)->end_keyword_loc.end);

      // location
      argv[5] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(6, argv, rb_const_get_at(rb_cYARP, rb_intern("CaseNode")));
    }
    case YP_NODE_CLASS_NODE: {
      VALUE argv[8];

      // scope
      argv[0] = yp_node_new(parser, (yp_node_t *)((yp_class_node_t *)node)->scope, encoding);

      // class_keyword
      argv[1] = yp_token_new(parser, &((yp_class_node_t *)node)->class_keyword, encoding);

      // constant_path
      argv[2] = yp_node_new(parser, (yp_node_t *)((yp_class_node_t *)node)->constant_path, encoding);

      // inheritance_operator
      argv[3] = ((yp_class_node_t *)node)->inheritance_operator.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_class_node_t *)node)->inheritance_operator, encoding);

      // superclass
      argv[4] = ((yp_class_node_t *)node)->superclass == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_class_node_t *)node)->superclass, encoding);

      // statements
      argv[5] = ((yp_class_node_t *)node)->statements == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_class_node_t *)node)->statements, encoding);

      // end_keyword
      argv[6] = yp_token_new(parser, &((yp_class_node_t *)node)->end_keyword, encoding);

      // location
      argv[7] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(8, argv, rb_const_get_at(rb_cYARP, rb_intern("ClassNode")));
    }
    case YP_NODE_CLASS_VARIABLE_READ_NODE: {
      VALUE argv[1];

      // location
      argv[0] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(1, argv, rb_const_get_at(rb_cYARP, rb_intern("ClassVariableReadNode")));
    }
    case YP_NODE_CLASS_VARIABLE_WRITE_NODE: {
      VALUE argv[4];

      // name_loc
      argv[0] = location_new(parser, ((yp_class_variable_write_node_t *)node)->name_loc.start, ((yp_class_variable_write_node_t *)node)->name_loc.end);

      // value
      argv[1] = ((yp_class_variable_write_node_t *)node)->value == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_class_variable_write_node_t *)node)->value, encoding);

      // operator_loc
      argv[2] = ((yp_class_variable_write_node_t *)node)->operator_loc.start == NULL ? Qnil : location_new(parser, ((yp_class_variable_write_node_t *)node)->operator_loc.start, ((yp_class_variable_write_node_t *)node)->operator_loc.end);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("ClassVariableWriteNode")));
    }
    case YP_NODE_CONSTANT_PATH_NODE: {
      VALUE argv[4];

      // parent
      argv[0] = ((yp_constant_path_node_t *)node)->parent == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_constant_path_node_t *)node)->parent, encoding);

      // child
      argv[1] = yp_node_new(parser, (yp_node_t *)((yp_constant_path_node_t *)node)->child, encoding);

      // delimiter_loc
      argv[2] = location_new(parser, ((yp_constant_path_node_t *)node)->delimiter_loc.start, ((yp_constant_path_node_t *)node)->delimiter_loc.end);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("ConstantPathNode")));
    }
    case YP_NODE_CONSTANT_PATH_WRITE_NODE: {
      VALUE argv[4];

      // target
      argv[0] = yp_node_new(parser, (yp_node_t *)((yp_constant_path_write_node_t *)node)->target, encoding);

      // operator
      argv[1] = ((yp_constant_path_write_node_t *)node)->operator.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_constant_path_write_node_t *)node)->operator, encoding);

      // value
      argv[2] = ((yp_constant_path_write_node_t *)node)->value == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_constant_path_write_node_t *)node)->value, encoding);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("ConstantPathWriteNode")));
    }
    case YP_NODE_CONSTANT_READ_NODE: {
      VALUE argv[1];

      // location
      argv[0] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(1, argv, rb_const_get_at(rb_cYARP, rb_intern("ConstantReadNode")));
    }
    case YP_NODE_DEF_NODE: {
      VALUE argv[12];

      // name
      argv[0] = yp_token_new(parser, &((yp_def_node_t *)node)->name, encoding);

      // receiver
      argv[1] = ((yp_def_node_t *)node)->receiver == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_def_node_t *)node)->receiver, encoding);

      // parameters
      argv[2] = ((yp_def_node_t *)node)->parameters == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_def_node_t *)node)->parameters, encoding);

      // statements
      argv[3] = ((yp_def_node_t *)node)->statements == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_def_node_t *)node)->statements, encoding);

      // scope
      argv[4] = yp_node_new(parser, (yp_node_t *)((yp_def_node_t *)node)->scope, encoding);

      // def_keyword_loc
      argv[5] = location_new(parser, ((yp_def_node_t *)node)->def_keyword_loc.start, ((yp_def_node_t *)node)->def_keyword_loc.end);

      // operator_loc
      argv[6] = ((yp_def_node_t *)node)->operator_loc.start == NULL ? Qnil : location_new(parser, ((yp_def_node_t *)node)->operator_loc.start, ((yp_def_node_t *)node)->operator_loc.end);

      // lparen_loc
      argv[7] = ((yp_def_node_t *)node)->lparen_loc.start == NULL ? Qnil : location_new(parser, ((yp_def_node_t *)node)->lparen_loc.start, ((yp_def_node_t *)node)->lparen_loc.end);

      // rparen_loc
      argv[8] = ((yp_def_node_t *)node)->rparen_loc.start == NULL ? Qnil : location_new(parser, ((yp_def_node_t *)node)->rparen_loc.start, ((yp_def_node_t *)node)->rparen_loc.end);

      // equal_loc
      argv[9] = ((yp_def_node_t *)node)->equal_loc.start == NULL ? Qnil : location_new(parser, ((yp_def_node_t *)node)->equal_loc.start, ((yp_def_node_t *)node)->equal_loc.end);

      // end_keyword_loc
      argv[10] = ((yp_def_node_t *)node)->end_keyword_loc.start == NULL ? Qnil : location_new(parser, ((yp_def_node_t *)node)->end_keyword_loc.start, ((yp_def_node_t *)node)->end_keyword_loc.end);

      // location
      argv[11] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(12, argv, rb_const_get_at(rb_cYARP, rb_intern("DefNode")));
    }
    case YP_NODE_DEFINED_NODE: {
      VALUE argv[5];

      // lparen
      argv[0] = ((yp_defined_node_t *)node)->lparen.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_defined_node_t *)node)->lparen, encoding);

      // value
      argv[1] = yp_node_new(parser, (yp_node_t *)((yp_defined_node_t *)node)->value, encoding);

      // rparen
      argv[2] = ((yp_defined_node_t *)node)->rparen.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_defined_node_t *)node)->rparen, encoding);

      // keyword_loc
      argv[3] = location_new(parser, ((yp_defined_node_t *)node)->keyword_loc.start, ((yp_defined_node_t *)node)->keyword_loc.end);

      // location
      argv[4] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(5, argv, rb_const_get_at(rb_cYARP, rb_intern("DefinedNode")));
    }
    case YP_NODE_ELSE_NODE: {
      VALUE argv[4];

      // else_keyword
      argv[0] = yp_token_new(parser, &((yp_else_node_t *)node)->else_keyword, encoding);

      // statements
      argv[1] = ((yp_else_node_t *)node)->statements == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_else_node_t *)node)->statements, encoding);

      // end_keyword
      argv[2] = ((yp_else_node_t *)node)->end_keyword.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_else_node_t *)node)->end_keyword, encoding);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("ElseNode")));
    }
    case YP_NODE_ENSURE_NODE: {
      VALUE argv[4];

      // ensure_keyword
      argv[0] = yp_token_new(parser, &((yp_ensure_node_t *)node)->ensure_keyword, encoding);

      // statements
      argv[1] = ((yp_ensure_node_t *)node)->statements == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_ensure_node_t *)node)->statements, encoding);

      // end_keyword
      argv[2] = yp_token_new(parser, &((yp_ensure_node_t *)node)->end_keyword, encoding);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("EnsureNode")));
    }
    case YP_NODE_FALSE_NODE: {
      VALUE argv[1];

      // location
      argv[0] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(1, argv, rb_const_get_at(rb_cYARP, rb_intern("FalseNode")));
    }
    case YP_NODE_FIND_PATTERN_NODE: {
      VALUE argv[7];

      // constant
      argv[0] = ((yp_find_pattern_node_t *)node)->constant == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_find_pattern_node_t *)node)->constant, encoding);

      // left
      argv[1] = yp_node_new(parser, (yp_node_t *)((yp_find_pattern_node_t *)node)->left, encoding);

      // requireds
      argv[2] = rb_ary_new();
      for (size_t index = 0; index < ((yp_find_pattern_node_t *)node)->requireds.size; index++) {
        rb_ary_push(argv[2], yp_node_new(parser, ((yp_find_pattern_node_t *)node)->requireds.nodes[index], encoding));
      }

      // right
      argv[3] = yp_node_new(parser, (yp_node_t *)((yp_find_pattern_node_t *)node)->right, encoding);

      // opening_loc
      argv[4] = ((yp_find_pattern_node_t *)node)->opening_loc.start == NULL ? Qnil : location_new(parser, ((yp_find_pattern_node_t *)node)->opening_loc.start, ((yp_find_pattern_node_t *)node)->opening_loc.end);

      // closing_loc
      argv[5] = ((yp_find_pattern_node_t *)node)->closing_loc.start == NULL ? Qnil : location_new(parser, ((yp_find_pattern_node_t *)node)->closing_loc.start, ((yp_find_pattern_node_t *)node)->closing_loc.end);

      // location
      argv[6] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(7, argv, rb_const_get_at(rb_cYARP, rb_intern("FindPatternNode")));
    }
    case YP_NODE_FLOAT_NODE: {
      VALUE argv[1];

      // location
      argv[0] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(1, argv, rb_const_get_at(rb_cYARP, rb_intern("FloatNode")));
    }
    case YP_NODE_FOR_NODE: {
      VALUE argv[8];

      // index
      argv[0] = yp_node_new(parser, (yp_node_t *)((yp_for_node_t *)node)->index, encoding);

      // collection
      argv[1] = yp_node_new(parser, (yp_node_t *)((yp_for_node_t *)node)->collection, encoding);

      // statements
      argv[2] = ((yp_for_node_t *)node)->statements == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_for_node_t *)node)->statements, encoding);

      // for_keyword_loc
      argv[3] = location_new(parser, ((yp_for_node_t *)node)->for_keyword_loc.start, ((yp_for_node_t *)node)->for_keyword_loc.end);

      // in_keyword_loc
      argv[4] = location_new(parser, ((yp_for_node_t *)node)->in_keyword_loc.start, ((yp_for_node_t *)node)->in_keyword_loc.end);

      // do_keyword_loc
      argv[5] = ((yp_for_node_t *)node)->do_keyword_loc.start == NULL ? Qnil : location_new(parser, ((yp_for_node_t *)node)->do_keyword_loc.start, ((yp_for_node_t *)node)->do_keyword_loc.end);

      // end_keyword_loc
      argv[6] = location_new(parser, ((yp_for_node_t *)node)->end_keyword_loc.start, ((yp_for_node_t *)node)->end_keyword_loc.end);

      // location
      argv[7] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(8, argv, rb_const_get_at(rb_cYARP, rb_intern("ForNode")));
    }
    case YP_NODE_FORWARDING_ARGUMENTS_NODE: {
      VALUE argv[1];

      // location
      argv[0] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(1, argv, rb_const_get_at(rb_cYARP, rb_intern("ForwardingArgumentsNode")));
    }
    case YP_NODE_FORWARDING_PARAMETER_NODE: {
      VALUE argv[1];

      // location
      argv[0] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(1, argv, rb_const_get_at(rb_cYARP, rb_intern("ForwardingParameterNode")));
    }
    case YP_NODE_FORWARDING_SUPER_NODE: {
      VALUE argv[2];

      // block
      argv[0] = ((yp_forwarding_super_node_t *)node)->block == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_forwarding_super_node_t *)node)->block, encoding);

      // location
      argv[1] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(2, argv, rb_const_get_at(rb_cYARP, rb_intern("ForwardingSuperNode")));
    }
    case YP_NODE_GLOBAL_VARIABLE_READ_NODE: {
      VALUE argv[2];

      // name
      argv[0] = yp_token_new(parser, &((yp_global_variable_read_node_t *)node)->name, encoding);

      // location
      argv[1] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(2, argv, rb_const_get_at(rb_cYARP, rb_intern("GlobalVariableReadNode")));
    }
    case YP_NODE_GLOBAL_VARIABLE_WRITE_NODE: {
      VALUE argv[4];

      // name
      argv[0] = yp_token_new(parser, &((yp_global_variable_write_node_t *)node)->name, encoding);

      // operator
      argv[1] = ((yp_global_variable_write_node_t *)node)->operator.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_global_variable_write_node_t *)node)->operator, encoding);

      // value
      argv[2] = ((yp_global_variable_write_node_t *)node)->value == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_global_variable_write_node_t *)node)->value, encoding);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("GlobalVariableWriteNode")));
    }
    case YP_NODE_HASH_NODE: {
      VALUE argv[4];

      // opening
      argv[0] = ((yp_hash_node_t *)node)->opening.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_hash_node_t *)node)->opening, encoding);

      // elements
      argv[1] = rb_ary_new();
      for (size_t index = 0; index < ((yp_hash_node_t *)node)->elements.size; index++) {
        rb_ary_push(argv[1], yp_node_new(parser, ((yp_hash_node_t *)node)->elements.nodes[index], encoding));
      }

      // closing
      argv[2] = ((yp_hash_node_t *)node)->closing.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_hash_node_t *)node)->closing, encoding);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("HashNode")));
    }
    case YP_NODE_HASH_PATTERN_NODE: {
      VALUE argv[6];

      // constant
      argv[0] = ((yp_hash_pattern_node_t *)node)->constant == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_hash_pattern_node_t *)node)->constant, encoding);

      // assocs
      argv[1] = rb_ary_new();
      for (size_t index = 0; index < ((yp_hash_pattern_node_t *)node)->assocs.size; index++) {
        rb_ary_push(argv[1], yp_node_new(parser, ((yp_hash_pattern_node_t *)node)->assocs.nodes[index], encoding));
      }

      // kwrest
      argv[2] = ((yp_hash_pattern_node_t *)node)->kwrest == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_hash_pattern_node_t *)node)->kwrest, encoding);

      // opening_loc
      argv[3] = ((yp_hash_pattern_node_t *)node)->opening_loc.start == NULL ? Qnil : location_new(parser, ((yp_hash_pattern_node_t *)node)->opening_loc.start, ((yp_hash_pattern_node_t *)node)->opening_loc.end);

      // closing_loc
      argv[4] = ((yp_hash_pattern_node_t *)node)->closing_loc.start == NULL ? Qnil : location_new(parser, ((yp_hash_pattern_node_t *)node)->closing_loc.start, ((yp_hash_pattern_node_t *)node)->closing_loc.end);

      // location
      argv[5] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(6, argv, rb_const_get_at(rb_cYARP, rb_intern("HashPatternNode")));
    }
    case YP_NODE_IF_NODE: {
      VALUE argv[6];

      // if_keyword
      argv[0] = yp_token_new(parser, &((yp_if_node_t *)node)->if_keyword, encoding);

      // predicate
      argv[1] = yp_node_new(parser, (yp_node_t *)((yp_if_node_t *)node)->predicate, encoding);

      // statements
      argv[2] = ((yp_if_node_t *)node)->statements == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_if_node_t *)node)->statements, encoding);

      // consequent
      argv[3] = ((yp_if_node_t *)node)->consequent == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_if_node_t *)node)->consequent, encoding);

      // end_keyword
      argv[4] = ((yp_if_node_t *)node)->end_keyword.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_if_node_t *)node)->end_keyword, encoding);

      // location
      argv[5] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(6, argv, rb_const_get_at(rb_cYARP, rb_intern("IfNode")));
    }
    case YP_NODE_IMAGINARY_NODE: {
      VALUE argv[2];

      // numeric
      argv[0] = yp_node_new(parser, (yp_node_t *)((yp_imaginary_node_t *)node)->numeric, encoding);

      // location
      argv[1] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(2, argv, rb_const_get_at(rb_cYARP, rb_intern("ImaginaryNode")));
    }
    case YP_NODE_IN_NODE: {
      VALUE argv[5];

      // pattern
      argv[0] = yp_node_new(parser, (yp_node_t *)((yp_in_node_t *)node)->pattern, encoding);

      // statements
      argv[1] = ((yp_in_node_t *)node)->statements == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_in_node_t *)node)->statements, encoding);

      // in_loc
      argv[2] = location_new(parser, ((yp_in_node_t *)node)->in_loc.start, ((yp_in_node_t *)node)->in_loc.end);

      // then_loc
      argv[3] = ((yp_in_node_t *)node)->then_loc.start == NULL ? Qnil : location_new(parser, ((yp_in_node_t *)node)->then_loc.start, ((yp_in_node_t *)node)->then_loc.end);

      // location
      argv[4] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(5, argv, rb_const_get_at(rb_cYARP, rb_intern("InNode")));
    }
    case YP_NODE_INSTANCE_VARIABLE_READ_NODE: {
      VALUE argv[1];

      // location
      argv[0] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(1, argv, rb_const_get_at(rb_cYARP, rb_intern("InstanceVariableReadNode")));
    }
    case YP_NODE_INSTANCE_VARIABLE_WRITE_NODE: {
      VALUE argv[4];

      // name_loc
      argv[0] = location_new(parser, ((yp_instance_variable_write_node_t *)node)->name_loc.start, ((yp_instance_variable_write_node_t *)node)->name_loc.end);

      // value
      argv[1] = ((yp_instance_variable_write_node_t *)node)->value == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_instance_variable_write_node_t *)node)->value, encoding);

      // operator_loc
      argv[2] = ((yp_instance_variable_write_node_t *)node)->operator_loc.start == NULL ? Qnil : location_new(parser, ((yp_instance_variable_write_node_t *)node)->operator_loc.start, ((yp_instance_variable_write_node_t *)node)->operator_loc.end);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("InstanceVariableWriteNode")));
    }
    case YP_NODE_INTEGER_NODE: {
      VALUE argv[1];

      // location
      argv[0] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(1, argv, rb_const_get_at(rb_cYARP, rb_intern("IntegerNode")));
    }
    case YP_NODE_INTERPOLATED_REGULAR_EXPRESSION_NODE: {
      VALUE argv[4];

      // opening
      argv[0] = yp_token_new(parser, &((yp_interpolated_regular_expression_node_t *)node)->opening, encoding);

      // parts
      argv[1] = rb_ary_new();
      for (size_t index = 0; index < ((yp_interpolated_regular_expression_node_t *)node)->parts.size; index++) {
        rb_ary_push(argv[1], yp_node_new(parser, ((yp_interpolated_regular_expression_node_t *)node)->parts.nodes[index], encoding));
      }

      // closing
      argv[2] = yp_token_new(parser, &((yp_interpolated_regular_expression_node_t *)node)->closing, encoding);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("InterpolatedRegularExpressionNode")));
    }
    case YP_NODE_INTERPOLATED_STRING_NODE: {
      VALUE argv[4];

      // opening
      argv[0] = ((yp_interpolated_string_node_t *)node)->opening.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_interpolated_string_node_t *)node)->opening, encoding);

      // parts
      argv[1] = rb_ary_new();
      for (size_t index = 0; index < ((yp_interpolated_string_node_t *)node)->parts.size; index++) {
        rb_ary_push(argv[1], yp_node_new(parser, ((yp_interpolated_string_node_t *)node)->parts.nodes[index], encoding));
      }

      // closing
      argv[2] = ((yp_interpolated_string_node_t *)node)->closing.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_interpolated_string_node_t *)node)->closing, encoding);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("InterpolatedStringNode")));
    }
    case YP_NODE_INTERPOLATED_SYMBOL_NODE: {
      VALUE argv[4];

      // opening
      argv[0] = ((yp_interpolated_symbol_node_t *)node)->opening.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_interpolated_symbol_node_t *)node)->opening, encoding);

      // parts
      argv[1] = rb_ary_new();
      for (size_t index = 0; index < ((yp_interpolated_symbol_node_t *)node)->parts.size; index++) {
        rb_ary_push(argv[1], yp_node_new(parser, ((yp_interpolated_symbol_node_t *)node)->parts.nodes[index], encoding));
      }

      // closing
      argv[2] = ((yp_interpolated_symbol_node_t *)node)->closing.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_interpolated_symbol_node_t *)node)->closing, encoding);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("InterpolatedSymbolNode")));
    }
    case YP_NODE_INTERPOLATED_X_STRING_NODE: {
      VALUE argv[4];

      // opening
      argv[0] = yp_token_new(parser, &((yp_interpolated_x_string_node_t *)node)->opening, encoding);

      // parts
      argv[1] = rb_ary_new();
      for (size_t index = 0; index < ((yp_interpolated_x_string_node_t *)node)->parts.size; index++) {
        rb_ary_push(argv[1], yp_node_new(parser, ((yp_interpolated_x_string_node_t *)node)->parts.nodes[index], encoding));
      }

      // closing
      argv[2] = yp_token_new(parser, &((yp_interpolated_x_string_node_t *)node)->closing, encoding);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("InterpolatedXStringNode")));
    }
    case YP_NODE_KEYWORD_PARAMETER_NODE: {
      VALUE argv[3];

      // name
      argv[0] = yp_token_new(parser, &((yp_keyword_parameter_node_t *)node)->name, encoding);

      // value
      argv[1] = ((yp_keyword_parameter_node_t *)node)->value == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_keyword_parameter_node_t *)node)->value, encoding);

      // location
      argv[2] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(3, argv, rb_const_get_at(rb_cYARP, rb_intern("KeywordParameterNode")));
    }
    case YP_NODE_KEYWORD_REST_PARAMETER_NODE: {
      VALUE argv[3];

      // operator
      argv[0] = yp_token_new(parser, &((yp_keyword_rest_parameter_node_t *)node)->operator, encoding);

      // name
      argv[1] = ((yp_keyword_rest_parameter_node_t *)node)->name.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_keyword_rest_parameter_node_t *)node)->name, encoding);

      // location
      argv[2] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(3, argv, rb_const_get_at(rb_cYARP, rb_intern("KeywordRestParameterNode")));
    }
    case YP_NODE_LAMBDA_NODE: {
      VALUE argv[5];

      // scope
      argv[0] = yp_node_new(parser, (yp_node_t *)((yp_lambda_node_t *)node)->scope, encoding);

      // opening
      argv[1] = yp_token_new(parser, &((yp_lambda_node_t *)node)->opening, encoding);

      // parameters
      argv[2] = ((yp_lambda_node_t *)node)->parameters == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_lambda_node_t *)node)->parameters, encoding);

      // statements
      argv[3] = ((yp_lambda_node_t *)node)->statements == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_lambda_node_t *)node)->statements, encoding);

      // location
      argv[4] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(5, argv, rb_const_get_at(rb_cYARP, rb_intern("LambdaNode")));
    }
    case YP_NODE_LOCAL_VARIABLE_READ_NODE: {
      VALUE argv[2];

      // depth
      argv[0] = INT2FIX(((yp_local_variable_read_node_t *)node)->depth);

      // location
      argv[1] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(2, argv, rb_const_get_at(rb_cYARP, rb_intern("LocalVariableReadNode")));
    }
    case YP_NODE_LOCAL_VARIABLE_WRITE_NODE: {
      VALUE argv[5];

      // name_loc
      argv[0] = location_new(parser, ((yp_local_variable_write_node_t *)node)->name_loc.start, ((yp_local_variable_write_node_t *)node)->name_loc.end);

      // value
      argv[1] = ((yp_local_variable_write_node_t *)node)->value == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_local_variable_write_node_t *)node)->value, encoding);

      // operator_loc
      argv[2] = ((yp_local_variable_write_node_t *)node)->operator_loc.start == NULL ? Qnil : location_new(parser, ((yp_local_variable_write_node_t *)node)->operator_loc.start, ((yp_local_variable_write_node_t *)node)->operator_loc.end);

      // depth
      argv[3] = INT2FIX(((yp_local_variable_write_node_t *)node)->depth);

      // location
      argv[4] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(5, argv, rb_const_get_at(rb_cYARP, rb_intern("LocalVariableWriteNode")));
    }
    case YP_NODE_MATCH_PREDICATE_NODE: {
      VALUE argv[4];

      // value
      argv[0] = yp_node_new(parser, (yp_node_t *)((yp_match_predicate_node_t *)node)->value, encoding);

      // pattern
      argv[1] = yp_node_new(parser, (yp_node_t *)((yp_match_predicate_node_t *)node)->pattern, encoding);

      // operator_loc
      argv[2] = location_new(parser, ((yp_match_predicate_node_t *)node)->operator_loc.start, ((yp_match_predicate_node_t *)node)->operator_loc.end);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("MatchPredicateNode")));
    }
    case YP_NODE_MATCH_REQUIRED_NODE: {
      VALUE argv[4];

      // value
      argv[0] = yp_node_new(parser, (yp_node_t *)((yp_match_required_node_t *)node)->value, encoding);

      // pattern
      argv[1] = yp_node_new(parser, (yp_node_t *)((yp_match_required_node_t *)node)->pattern, encoding);

      // operator_loc
      argv[2] = location_new(parser, ((yp_match_required_node_t *)node)->operator_loc.start, ((yp_match_required_node_t *)node)->operator_loc.end);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("MatchRequiredNode")));
    }
    case YP_NODE_MISSING_NODE: {
      VALUE argv[1];

      // location
      argv[0] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(1, argv, rb_const_get_at(rb_cYARP, rb_intern("MissingNode")));
    }
    case YP_NODE_MODULE_NODE: {
      VALUE argv[6];

      // scope
      argv[0] = yp_node_new(parser, (yp_node_t *)((yp_module_node_t *)node)->scope, encoding);

      // module_keyword
      argv[1] = yp_token_new(parser, &((yp_module_node_t *)node)->module_keyword, encoding);

      // constant_path
      argv[2] = yp_node_new(parser, (yp_node_t *)((yp_module_node_t *)node)->constant_path, encoding);

      // statements
      argv[3] = ((yp_module_node_t *)node)->statements == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_module_node_t *)node)->statements, encoding);

      // end_keyword
      argv[4] = yp_token_new(parser, &((yp_module_node_t *)node)->end_keyword, encoding);

      // location
      argv[5] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(6, argv, rb_const_get_at(rb_cYARP, rb_intern("ModuleNode")));
    }
    case YP_NODE_MULTI_WRITE_NODE: {
      VALUE argv[6];

      // targets
      argv[0] = rb_ary_new();
      for (size_t index = 0; index < ((yp_multi_write_node_t *)node)->targets.size; index++) {
        rb_ary_push(argv[0], yp_node_new(parser, ((yp_multi_write_node_t *)node)->targets.nodes[index], encoding));
      }

      // operator
      argv[1] = ((yp_multi_write_node_t *)node)->operator.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_multi_write_node_t *)node)->operator, encoding);

      // value
      argv[2] = ((yp_multi_write_node_t *)node)->value == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_multi_write_node_t *)node)->value, encoding);

      // lparen_loc
      argv[3] = ((yp_multi_write_node_t *)node)->lparen_loc.start == NULL ? Qnil : location_new(parser, ((yp_multi_write_node_t *)node)->lparen_loc.start, ((yp_multi_write_node_t *)node)->lparen_loc.end);

      // rparen_loc
      argv[4] = ((yp_multi_write_node_t *)node)->rparen_loc.start == NULL ? Qnil : location_new(parser, ((yp_multi_write_node_t *)node)->rparen_loc.start, ((yp_multi_write_node_t *)node)->rparen_loc.end);

      // location
      argv[5] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(6, argv, rb_const_get_at(rb_cYARP, rb_intern("MultiWriteNode")));
    }
    case YP_NODE_NEXT_NODE: {
      VALUE argv[3];

      // arguments
      argv[0] = ((yp_next_node_t *)node)->arguments == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_next_node_t *)node)->arguments, encoding);

      // keyword_loc
      argv[1] = location_new(parser, ((yp_next_node_t *)node)->keyword_loc.start, ((yp_next_node_t *)node)->keyword_loc.end);

      // location
      argv[2] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(3, argv, rb_const_get_at(rb_cYARP, rb_intern("NextNode")));
    }
    case YP_NODE_NIL_NODE: {
      VALUE argv[1];

      // location
      argv[0] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(1, argv, rb_const_get_at(rb_cYARP, rb_intern("NilNode")));
    }
    case YP_NODE_NO_KEYWORDS_PARAMETER_NODE: {
      VALUE argv[3];

      // operator_loc
      argv[0] = location_new(parser, ((yp_no_keywords_parameter_node_t *)node)->operator_loc.start, ((yp_no_keywords_parameter_node_t *)node)->operator_loc.end);

      // keyword_loc
      argv[1] = location_new(parser, ((yp_no_keywords_parameter_node_t *)node)->keyword_loc.start, ((yp_no_keywords_parameter_node_t *)node)->keyword_loc.end);

      // location
      argv[2] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(3, argv, rb_const_get_at(rb_cYARP, rb_intern("NoKeywordsParameterNode")));
    }
    case YP_NODE_OPERATOR_AND_ASSIGNMENT_NODE: {
      VALUE argv[4];

      // target
      argv[0] = yp_node_new(parser, (yp_node_t *)((yp_operator_and_assignment_node_t *)node)->target, encoding);

      // value
      argv[1] = yp_node_new(parser, (yp_node_t *)((yp_operator_and_assignment_node_t *)node)->value, encoding);

      // operator_loc
      argv[2] = location_new(parser, ((yp_operator_and_assignment_node_t *)node)->operator_loc.start, ((yp_operator_and_assignment_node_t *)node)->operator_loc.end);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("OperatorAndAssignmentNode")));
    }
    case YP_NODE_OPERATOR_ASSIGNMENT_NODE: {
      VALUE argv[4];

      // target
      argv[0] = yp_node_new(parser, (yp_node_t *)((yp_operator_assignment_node_t *)node)->target, encoding);

      // operator
      argv[1] = yp_token_new(parser, &((yp_operator_assignment_node_t *)node)->operator, encoding);

      // value
      argv[2] = yp_node_new(parser, (yp_node_t *)((yp_operator_assignment_node_t *)node)->value, encoding);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("OperatorAssignmentNode")));
    }
    case YP_NODE_OPERATOR_OR_ASSIGNMENT_NODE: {
      VALUE argv[4];

      // target
      argv[0] = yp_node_new(parser, (yp_node_t *)((yp_operator_or_assignment_node_t *)node)->target, encoding);

      // value
      argv[1] = yp_node_new(parser, (yp_node_t *)((yp_operator_or_assignment_node_t *)node)->value, encoding);

      // operator_loc
      argv[2] = location_new(parser, ((yp_operator_or_assignment_node_t *)node)->operator_loc.start, ((yp_operator_or_assignment_node_t *)node)->operator_loc.end);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("OperatorOrAssignmentNode")));
    }
    case YP_NODE_OPTIONAL_PARAMETER_NODE: {
      VALUE argv[4];

      // name
      argv[0] = yp_token_new(parser, &((yp_optional_parameter_node_t *)node)->name, encoding);

      // equal_operator
      argv[1] = yp_token_new(parser, &((yp_optional_parameter_node_t *)node)->equal_operator, encoding);

      // value
      argv[2] = yp_node_new(parser, (yp_node_t *)((yp_optional_parameter_node_t *)node)->value, encoding);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("OptionalParameterNode")));
    }
    case YP_NODE_OR_NODE: {
      VALUE argv[4];

      // left
      argv[0] = yp_node_new(parser, (yp_node_t *)((yp_or_node_t *)node)->left, encoding);

      // right
      argv[1] = yp_node_new(parser, (yp_node_t *)((yp_or_node_t *)node)->right, encoding);

      // operator_loc
      argv[2] = location_new(parser, ((yp_or_node_t *)node)->operator_loc.start, ((yp_or_node_t *)node)->operator_loc.end);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("OrNode")));
    }
    case YP_NODE_PARAMETERS_NODE: {
      VALUE argv[8];

      // requireds
      argv[0] = rb_ary_new();
      for (size_t index = 0; index < ((yp_parameters_node_t *)node)->requireds.size; index++) {
        rb_ary_push(argv[0], yp_node_new(parser, ((yp_parameters_node_t *)node)->requireds.nodes[index], encoding));
      }

      // optionals
      argv[1] = rb_ary_new();
      for (size_t index = 0; index < ((yp_parameters_node_t *)node)->optionals.size; index++) {
        rb_ary_push(argv[1], yp_node_new(parser, ((yp_parameters_node_t *)node)->optionals.nodes[index], encoding));
      }

      // posts
      argv[2] = rb_ary_new();
      for (size_t index = 0; index < ((yp_parameters_node_t *)node)->posts.size; index++) {
        rb_ary_push(argv[2], yp_node_new(parser, ((yp_parameters_node_t *)node)->posts.nodes[index], encoding));
      }

      // rest
      argv[3] = ((yp_parameters_node_t *)node)->rest == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_parameters_node_t *)node)->rest, encoding);

      // keywords
      argv[4] = rb_ary_new();
      for (size_t index = 0; index < ((yp_parameters_node_t *)node)->keywords.size; index++) {
        rb_ary_push(argv[4], yp_node_new(parser, ((yp_parameters_node_t *)node)->keywords.nodes[index], encoding));
      }

      // keyword_rest
      argv[5] = ((yp_parameters_node_t *)node)->keyword_rest == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_parameters_node_t *)node)->keyword_rest, encoding);

      // block
      argv[6] = ((yp_parameters_node_t *)node)->block == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_parameters_node_t *)node)->block, encoding);

      // location
      argv[7] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(8, argv, rb_const_get_at(rb_cYARP, rb_intern("ParametersNode")));
    }
    case YP_NODE_PARENTHESES_NODE: {
      VALUE argv[4];

      // statements
      argv[0] = ((yp_parentheses_node_t *)node)->statements == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_parentheses_node_t *)node)->statements, encoding);

      // opening_loc
      argv[1] = location_new(parser, ((yp_parentheses_node_t *)node)->opening_loc.start, ((yp_parentheses_node_t *)node)->opening_loc.end);

      // closing_loc
      argv[2] = location_new(parser, ((yp_parentheses_node_t *)node)->closing_loc.start, ((yp_parentheses_node_t *)node)->closing_loc.end);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("ParenthesesNode")));
    }
    case YP_NODE_PINNED_EXPRESSION_NODE: {
      VALUE argv[5];

      // expression
      argv[0] = yp_node_new(parser, (yp_node_t *)((yp_pinned_expression_node_t *)node)->expression, encoding);

      // operator_loc
      argv[1] = location_new(parser, ((yp_pinned_expression_node_t *)node)->operator_loc.start, ((yp_pinned_expression_node_t *)node)->operator_loc.end);

      // lparen_loc
      argv[2] = location_new(parser, ((yp_pinned_expression_node_t *)node)->lparen_loc.start, ((yp_pinned_expression_node_t *)node)->lparen_loc.end);

      // rparen_loc
      argv[3] = location_new(parser, ((yp_pinned_expression_node_t *)node)->rparen_loc.start, ((yp_pinned_expression_node_t *)node)->rparen_loc.end);

      // location
      argv[4] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(5, argv, rb_const_get_at(rb_cYARP, rb_intern("PinnedExpressionNode")));
    }
    case YP_NODE_PINNED_VARIABLE_NODE: {
      VALUE argv[3];

      // variable
      argv[0] = yp_node_new(parser, (yp_node_t *)((yp_pinned_variable_node_t *)node)->variable, encoding);

      // operator_loc
      argv[1] = location_new(parser, ((yp_pinned_variable_node_t *)node)->operator_loc.start, ((yp_pinned_variable_node_t *)node)->operator_loc.end);

      // location
      argv[2] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(3, argv, rb_const_get_at(rb_cYARP, rb_intern("PinnedVariableNode")));
    }
    case YP_NODE_POST_EXECUTION_NODE: {
      VALUE argv[5];

      // statements
      argv[0] = yp_node_new(parser, (yp_node_t *)((yp_post_execution_node_t *)node)->statements, encoding);

      // keyword_loc
      argv[1] = location_new(parser, ((yp_post_execution_node_t *)node)->keyword_loc.start, ((yp_post_execution_node_t *)node)->keyword_loc.end);

      // opening_loc
      argv[2] = location_new(parser, ((yp_post_execution_node_t *)node)->opening_loc.start, ((yp_post_execution_node_t *)node)->opening_loc.end);

      // closing_loc
      argv[3] = location_new(parser, ((yp_post_execution_node_t *)node)->closing_loc.start, ((yp_post_execution_node_t *)node)->closing_loc.end);

      // location
      argv[4] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(5, argv, rb_const_get_at(rb_cYARP, rb_intern("PostExecutionNode")));
    }
    case YP_NODE_PRE_EXECUTION_NODE: {
      VALUE argv[5];

      // statements
      argv[0] = yp_node_new(parser, (yp_node_t *)((yp_pre_execution_node_t *)node)->statements, encoding);

      // keyword_loc
      argv[1] = location_new(parser, ((yp_pre_execution_node_t *)node)->keyword_loc.start, ((yp_pre_execution_node_t *)node)->keyword_loc.end);

      // opening_loc
      argv[2] = location_new(parser, ((yp_pre_execution_node_t *)node)->opening_loc.start, ((yp_pre_execution_node_t *)node)->opening_loc.end);

      // closing_loc
      argv[3] = location_new(parser, ((yp_pre_execution_node_t *)node)->closing_loc.start, ((yp_pre_execution_node_t *)node)->closing_loc.end);

      // location
      argv[4] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(5, argv, rb_const_get_at(rb_cYARP, rb_intern("PreExecutionNode")));
    }
    case YP_NODE_PROGRAM_NODE: {
      VALUE argv[3];

      // scope
      argv[0] = yp_node_new(parser, (yp_node_t *)((yp_program_node_t *)node)->scope, encoding);

      // statements
      argv[1] = yp_node_new(parser, (yp_node_t *)((yp_program_node_t *)node)->statements, encoding);

      // location
      argv[2] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(3, argv, rb_const_get_at(rb_cYARP, rb_intern("ProgramNode")));
    }
    case YP_NODE_RANGE_NODE: {
      VALUE argv[4];

      // left
      argv[0] = ((yp_range_node_t *)node)->left == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_range_node_t *)node)->left, encoding);

      // right
      argv[1] = ((yp_range_node_t *)node)->right == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_range_node_t *)node)->right, encoding);

      // operator_loc
      argv[2] = location_new(parser, ((yp_range_node_t *)node)->operator_loc.start, ((yp_range_node_t *)node)->operator_loc.end);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("RangeNode")));
    }
    case YP_NODE_RATIONAL_NODE: {
      VALUE argv[2];

      // numeric
      argv[0] = yp_node_new(parser, (yp_node_t *)((yp_rational_node_t *)node)->numeric, encoding);

      // location
      argv[1] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(2, argv, rb_const_get_at(rb_cYARP, rb_intern("RationalNode")));
    }
    case YP_NODE_REDO_NODE: {
      VALUE argv[1];

      // location
      argv[0] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(1, argv, rb_const_get_at(rb_cYARP, rb_intern("RedoNode")));
    }
    case YP_NODE_REGULAR_EXPRESSION_NODE: {
      VALUE argv[5];

      // opening
      argv[0] = yp_token_new(parser, &((yp_regular_expression_node_t *)node)->opening, encoding);

      // content
      argv[1] = yp_token_new(parser, &((yp_regular_expression_node_t *)node)->content, encoding);

      // closing
      argv[2] = yp_token_new(parser, &((yp_regular_expression_node_t *)node)->closing, encoding);

      // unescaped
      argv[3] = yp_string_new(&((yp_regular_expression_node_t *)node)->unescaped, encoding);

      // location
      argv[4] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(5, argv, rb_const_get_at(rb_cYARP, rb_intern("RegularExpressionNode")));
    }
    case YP_NODE_REQUIRED_DESTRUCTURED_PARAMETER_NODE: {
      VALUE argv[4];

      // parameters
      argv[0] = rb_ary_new();
      for (size_t index = 0; index < ((yp_required_destructured_parameter_node_t *)node)->parameters.size; index++) {
        rb_ary_push(argv[0], yp_node_new(parser, ((yp_required_destructured_parameter_node_t *)node)->parameters.nodes[index], encoding));
      }

      // opening
      argv[1] = yp_token_new(parser, &((yp_required_destructured_parameter_node_t *)node)->opening, encoding);

      // closing
      argv[2] = yp_token_new(parser, &((yp_required_destructured_parameter_node_t *)node)->closing, encoding);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("RequiredDestructuredParameterNode")));
    }
    case YP_NODE_REQUIRED_PARAMETER_NODE: {
      VALUE argv[1];

      // location
      argv[0] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(1, argv, rb_const_get_at(rb_cYARP, rb_intern("RequiredParameterNode")));
    }
    case YP_NODE_RESCUE_MODIFIER_NODE: {
      VALUE argv[4];

      // expression
      argv[0] = yp_node_new(parser, (yp_node_t *)((yp_rescue_modifier_node_t *)node)->expression, encoding);

      // rescue_keyword
      argv[1] = yp_token_new(parser, &((yp_rescue_modifier_node_t *)node)->rescue_keyword, encoding);

      // rescue_expression
      argv[2] = yp_node_new(parser, (yp_node_t *)((yp_rescue_modifier_node_t *)node)->rescue_expression, encoding);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("RescueModifierNode")));
    }
    case YP_NODE_RESCUE_NODE: {
      VALUE argv[7];

      // rescue_keyword
      argv[0] = yp_token_new(parser, &((yp_rescue_node_t *)node)->rescue_keyword, encoding);

      // exceptions
      argv[1] = rb_ary_new();
      for (size_t index = 0; index < ((yp_rescue_node_t *)node)->exceptions.size; index++) {
        rb_ary_push(argv[1], yp_node_new(parser, ((yp_rescue_node_t *)node)->exceptions.nodes[index], encoding));
      }

      // equal_greater
      argv[2] = ((yp_rescue_node_t *)node)->equal_greater.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_rescue_node_t *)node)->equal_greater, encoding);

      // exception
      argv[3] = ((yp_rescue_node_t *)node)->exception == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_rescue_node_t *)node)->exception, encoding);

      // statements
      argv[4] = ((yp_rescue_node_t *)node)->statements == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_rescue_node_t *)node)->statements, encoding);

      // consequent
      argv[5] = ((yp_rescue_node_t *)node)->consequent == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_rescue_node_t *)node)->consequent, encoding);

      // location
      argv[6] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(7, argv, rb_const_get_at(rb_cYARP, rb_intern("RescueNode")));
    }
    case YP_NODE_REST_PARAMETER_NODE: {
      VALUE argv[3];

      // operator
      argv[0] = yp_token_new(parser, &((yp_rest_parameter_node_t *)node)->operator, encoding);

      // name
      argv[1] = ((yp_rest_parameter_node_t *)node)->name.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_rest_parameter_node_t *)node)->name, encoding);

      // location
      argv[2] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(3, argv, rb_const_get_at(rb_cYARP, rb_intern("RestParameterNode")));
    }
    case YP_NODE_RETRY_NODE: {
      VALUE argv[1];

      // location
      argv[0] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(1, argv, rb_const_get_at(rb_cYARP, rb_intern("RetryNode")));
    }
    case YP_NODE_RETURN_NODE: {
      VALUE argv[3];

      // keyword
      argv[0] = yp_token_new(parser, &((yp_return_node_t *)node)->keyword, encoding);

      // arguments
      argv[1] = ((yp_return_node_t *)node)->arguments == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_return_node_t *)node)->arguments, encoding);

      // location
      argv[2] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(3, argv, rb_const_get_at(rb_cYARP, rb_intern("ReturnNode")));
    }
    case YP_NODE_SCOPE_NODE: {
      VALUE argv[2];

      // locals
      argv[0] = rb_ary_new();
      for (size_t index = 0; index < ((yp_scope_node_t *)node)->locals.size; index++) {
        rb_ary_push(argv[0], yp_token_new(parser, &((yp_scope_node_t *)node)->locals.tokens[index], encoding));
      }

      // location
      argv[1] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(2, argv, rb_const_get_at(rb_cYARP, rb_intern("ScopeNode")));
    }
    case YP_NODE_SELF_NODE: {
      VALUE argv[1];

      // location
      argv[0] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(1, argv, rb_const_get_at(rb_cYARP, rb_intern("SelfNode")));
    }
    case YP_NODE_SINGLETON_CLASS_NODE: {
      VALUE argv[7];

      // scope
      argv[0] = yp_node_new(parser, (yp_node_t *)((yp_singleton_class_node_t *)node)->scope, encoding);

      // class_keyword
      argv[1] = yp_token_new(parser, &((yp_singleton_class_node_t *)node)->class_keyword, encoding);

      // operator
      argv[2] = yp_token_new(parser, &((yp_singleton_class_node_t *)node)->operator, encoding);

      // expression
      argv[3] = yp_node_new(parser, (yp_node_t *)((yp_singleton_class_node_t *)node)->expression, encoding);

      // statements
      argv[4] = ((yp_singleton_class_node_t *)node)->statements == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_singleton_class_node_t *)node)->statements, encoding);

      // end_keyword
      argv[5] = yp_token_new(parser, &((yp_singleton_class_node_t *)node)->end_keyword, encoding);

      // location
      argv[6] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(7, argv, rb_const_get_at(rb_cYARP, rb_intern("SingletonClassNode")));
    }
    case YP_NODE_SOURCE_ENCODING_NODE: {
      VALUE argv[1];

      // location
      argv[0] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(1, argv, rb_const_get_at(rb_cYARP, rb_intern("SourceEncodingNode")));
    }
    case YP_NODE_SOURCE_FILE_NODE: {
      VALUE argv[2];

      // filepath
      argv[0] = yp_string_new(&((yp_source_file_node_t *)node)->filepath, encoding);

      // location
      argv[1] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(2, argv, rb_const_get_at(rb_cYARP, rb_intern("SourceFileNode")));
    }
    case YP_NODE_SOURCE_LINE_NODE: {
      VALUE argv[1];

      // location
      argv[0] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(1, argv, rb_const_get_at(rb_cYARP, rb_intern("SourceLineNode")));
    }
    case YP_NODE_SPLAT_NODE: {
      VALUE argv[3];

      // operator
      argv[0] = yp_token_new(parser, &((yp_splat_node_t *)node)->operator, encoding);

      // expression
      argv[1] = ((yp_splat_node_t *)node)->expression == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_splat_node_t *)node)->expression, encoding);

      // location
      argv[2] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(3, argv, rb_const_get_at(rb_cYARP, rb_intern("SplatNode")));
    }
    case YP_NODE_STATEMENTS_NODE: {
      VALUE argv[2];

      // body
      argv[0] = rb_ary_new();
      for (size_t index = 0; index < ((yp_statements_node_t *)node)->body.size; index++) {
        rb_ary_push(argv[0], yp_node_new(parser, ((yp_statements_node_t *)node)->body.nodes[index], encoding));
      }

      // location
      argv[1] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(2, argv, rb_const_get_at(rb_cYARP, rb_intern("StatementsNode")));
    }
    case YP_NODE_STRING_CONCAT_NODE: {
      VALUE argv[3];

      // left
      argv[0] = yp_node_new(parser, (yp_node_t *)((yp_string_concat_node_t *)node)->left, encoding);

      // right
      argv[1] = yp_node_new(parser, (yp_node_t *)((yp_string_concat_node_t *)node)->right, encoding);

      // location
      argv[2] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(3, argv, rb_const_get_at(rb_cYARP, rb_intern("StringConcatNode")));
    }
    case YP_NODE_STRING_INTERPOLATED_NODE: {
      VALUE argv[4];

      // opening
      argv[0] = yp_token_new(parser, &((yp_string_interpolated_node_t *)node)->opening, encoding);

      // statements
      argv[1] = ((yp_string_interpolated_node_t *)node)->statements == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_string_interpolated_node_t *)node)->statements, encoding);

      // closing
      argv[2] = yp_token_new(parser, &((yp_string_interpolated_node_t *)node)->closing, encoding);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("StringInterpolatedNode")));
    }
    case YP_NODE_STRING_NODE: {
      VALUE argv[5];

      // opening
      argv[0] = ((yp_string_node_t *)node)->opening.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_string_node_t *)node)->opening, encoding);

      // content
      argv[1] = yp_token_new(parser, &((yp_string_node_t *)node)->content, encoding);

      // closing
      argv[2] = ((yp_string_node_t *)node)->closing.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_string_node_t *)node)->closing, encoding);

      // unescaped
      argv[3] = yp_string_new(&((yp_string_node_t *)node)->unescaped, encoding);

      // location
      argv[4] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(5, argv, rb_const_get_at(rb_cYARP, rb_intern("StringNode")));
    }
    case YP_NODE_SUPER_NODE: {
      VALUE argv[6];

      // keyword
      argv[0] = yp_token_new(parser, &((yp_super_node_t *)node)->keyword, encoding);

      // lparen
      argv[1] = ((yp_super_node_t *)node)->lparen.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_super_node_t *)node)->lparen, encoding);

      // arguments
      argv[2] = ((yp_super_node_t *)node)->arguments == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_super_node_t *)node)->arguments, encoding);

      // rparen
      argv[3] = ((yp_super_node_t *)node)->rparen.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_super_node_t *)node)->rparen, encoding);

      // block
      argv[4] = ((yp_super_node_t *)node)->block == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_super_node_t *)node)->block, encoding);

      // location
      argv[5] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(6, argv, rb_const_get_at(rb_cYARP, rb_intern("SuperNode")));
    }
    case YP_NODE_SYMBOL_NODE: {
      VALUE argv[5];

      // opening
      argv[0] = ((yp_symbol_node_t *)node)->opening.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_symbol_node_t *)node)->opening, encoding);

      // value
      argv[1] = yp_token_new(parser, &((yp_symbol_node_t *)node)->value, encoding);

      // closing
      argv[2] = ((yp_symbol_node_t *)node)->closing.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_symbol_node_t *)node)->closing, encoding);

      // unescaped
      argv[3] = yp_string_new(&((yp_symbol_node_t *)node)->unescaped, encoding);

      // location
      argv[4] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(5, argv, rb_const_get_at(rb_cYARP, rb_intern("SymbolNode")));
    }
    case YP_NODE_TRUE_NODE: {
      VALUE argv[1];

      // location
      argv[0] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(1, argv, rb_const_get_at(rb_cYARP, rb_intern("TrueNode")));
    }
    case YP_NODE_UNDEF_NODE: {
      VALUE argv[3];

      // names
      argv[0] = rb_ary_new();
      for (size_t index = 0; index < ((yp_undef_node_t *)node)->names.size; index++) {
        rb_ary_push(argv[0], yp_node_new(parser, ((yp_undef_node_t *)node)->names.nodes[index], encoding));
      }

      // keyword_loc
      argv[1] = location_new(parser, ((yp_undef_node_t *)node)->keyword_loc.start, ((yp_undef_node_t *)node)->keyword_loc.end);

      // location
      argv[2] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(3, argv, rb_const_get_at(rb_cYARP, rb_intern("UndefNode")));
    }
    case YP_NODE_UNLESS_NODE: {
      VALUE argv[6];

      // keyword
      argv[0] = yp_token_new(parser, &((yp_unless_node_t *)node)->keyword, encoding);

      // predicate
      argv[1] = yp_node_new(parser, (yp_node_t *)((yp_unless_node_t *)node)->predicate, encoding);

      // statements
      argv[2] = ((yp_unless_node_t *)node)->statements == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_unless_node_t *)node)->statements, encoding);

      // consequent
      argv[3] = ((yp_unless_node_t *)node)->consequent == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_unless_node_t *)node)->consequent, encoding);

      // end_keyword
      argv[4] = ((yp_unless_node_t *)node)->end_keyword.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_unless_node_t *)node)->end_keyword, encoding);

      // location
      argv[5] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(6, argv, rb_const_get_at(rb_cYARP, rb_intern("UnlessNode")));
    }
    case YP_NODE_UNTIL_NODE: {
      VALUE argv[4];

      // keyword
      argv[0] = yp_token_new(parser, &((yp_until_node_t *)node)->keyword, encoding);

      // predicate
      argv[1] = yp_node_new(parser, (yp_node_t *)((yp_until_node_t *)node)->predicate, encoding);

      // statements
      argv[2] = ((yp_until_node_t *)node)->statements == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_until_node_t *)node)->statements, encoding);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("UntilNode")));
    }
    case YP_NODE_WHEN_NODE: {
      VALUE argv[4];

      // when_keyword
      argv[0] = yp_token_new(parser, &((yp_when_node_t *)node)->when_keyword, encoding);

      // conditions
      argv[1] = rb_ary_new();
      for (size_t index = 0; index < ((yp_when_node_t *)node)->conditions.size; index++) {
        rb_ary_push(argv[1], yp_node_new(parser, ((yp_when_node_t *)node)->conditions.nodes[index], encoding));
      }

      // statements
      argv[2] = ((yp_when_node_t *)node)->statements == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_when_node_t *)node)->statements, encoding);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("WhenNode")));
    }
    case YP_NODE_WHILE_NODE: {
      VALUE argv[4];

      // keyword
      argv[0] = yp_token_new(parser, &((yp_while_node_t *)node)->keyword, encoding);

      // predicate
      argv[1] = yp_node_new(parser, (yp_node_t *)((yp_while_node_t *)node)->predicate, encoding);

      // statements
      argv[2] = ((yp_while_node_t *)node)->statements == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_while_node_t *)node)->statements, encoding);

      // location
      argv[3] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(4, argv, rb_const_get_at(rb_cYARP, rb_intern("WhileNode")));
    }
    case YP_NODE_X_STRING_NODE: {
      VALUE argv[5];

      // opening
      argv[0] = yp_token_new(parser, &((yp_x_string_node_t *)node)->opening, encoding);

      // content
      argv[1] = yp_token_new(parser, &((yp_x_string_node_t *)node)->content, encoding);

      // closing
      argv[2] = yp_token_new(parser, &((yp_x_string_node_t *)node)->closing, encoding);

      // unescaped
      argv[3] = yp_string_new(&((yp_x_string_node_t *)node)->unescaped, encoding);

      // location
      argv[4] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(5, argv, rb_const_get_at(rb_cYARP, rb_intern("XStringNode")));
    }
    case YP_NODE_YIELD_NODE: {
      VALUE argv[5];

      // keyword
      argv[0] = yp_token_new(parser, &((yp_yield_node_t *)node)->keyword, encoding);

      // lparen
      argv[1] = ((yp_yield_node_t *)node)->lparen.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_yield_node_t *)node)->lparen, encoding);

      // arguments
      argv[2] = ((yp_yield_node_t *)node)->arguments == NULL ? Qnil : yp_node_new(parser, (yp_node_t *)((yp_yield_node_t *)node)->arguments, encoding);

      // rparen
      argv[3] = ((yp_yield_node_t *)node)->rparen.type == YP_TOKEN_NOT_PROVIDED ? Qnil : yp_token_new(parser, &((yp_yield_node_t *)node)->rparen, encoding);

      // location
      argv[4] = location_new(parser, node->location.start, node->location.end);

      return rb_class_new_instance(5, argv, rb_const_get_at(rb_cYARP, rb_intern("YieldNode")));
    }
    default:
      rb_raise(rb_eRuntimeError, "unknown node type: %d", node->type);
  }
}
